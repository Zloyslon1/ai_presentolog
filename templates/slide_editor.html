{% extends "base.html" %}

{% block title %}–†–µ–¥–∞–∫—Ç–æ—Ä —Å–ª–∞–π–¥–æ–≤{% endblock %}

{% block content %}
<style>
/* Editable content styles */
#editableContent {
    min-height: 100%;
    color: #111827;
}

#editableContent:empty:before {
    content: attr(placeholder);
    color: #9CA3AF;
    pointer-events: none;
}

#editableContent h1 {
    font-size: 2.5rem;
    font-weight: 700;
    line-height: 1.2;
    margin-bottom: 1rem;
    color: #111827;
}

#editableContent h2 {
    font-size: 2rem;
    font-weight: 600;
    line-height: 1.3;
    margin-bottom: 0.75rem;
    color: #111827;
}

#editableContent h3 {
    font-size: 1.5rem;
    font-weight: 600;
    line-height: 1.4;
    margin-bottom: 0.5rem;
    color: #111827;
}

#editableContent h4 {
    font-size: 1.25rem;
    font-weight: 600;
    line-height: 1.4;
    margin-bottom: 0.5rem;
    color: #111827;
}

#editableContent p {
    font-size: 1.125rem;
    line-height: 1.6;
    margin-bottom: 0.75rem;
    color: #374151;
}

#editableContent ul, #editableContent ol {
    margin-left: 1.5rem;
    margin-bottom: 0.75rem;
}

#editableContent li {
    margin-bottom: 0.25rem;
}

/* Image Selection and Manipulation Styles */
.image-wrapper {
    position: absolute;
    cursor: pointer;
    pointer-events: auto; /* Allow clicks on wrapper */
    /* z-index is controlled by parent container */
}

/* Background images need higher stacking within their layer */
#previewImagesBackground .image-wrapper {
    z-index: 5;
}

/* Foreground images are already above text */
#previewImagesForeground .image-wrapper {
    z-index: 25;
}

.image-wrapper.selected {
    outline: 2px solid #3B82F6;
    outline-offset: 2px;
}

.image-wrapper img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    pointer-events: none; /* Clicks go through img to wrapper */
}

/* Resize Handles */
.resize-handle {
    position: absolute;
    width: 8px;
    height: 8px;
    background: white;
    border: 2px solid #3B82F6;
    z-index: 10;
    pointer-events: auto;
}

.resize-handle.top-left {
    top: -4px;
    left: -4px;
    cursor: nwse-resize;
}

.resize-handle.top-right {
    top: -4px;
    right: -4px;
    cursor: nesw-resize;
}

.resize-handle.bottom-left {
    bottom: -4px;
    left: -4px;
    cursor: nesw-resize;
}

.resize-handle.bottom-right {
    bottom: -4px;
    right: -4px;
    cursor: nwse-resize;
}

.resize-handle.top {
    top: -4px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize;
}

.resize-handle.bottom {
    bottom: -4px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize;
}

.resize-handle.left {
    top: 50%;
    left: -4px;
    transform: translateY(-50%);
    cursor: ew-resize;
}

.resize-handle.right {
    top: 50%;
    right: -4px;
    transform: translateY(-50%);
    cursor: ew-resize;
}

/* Rotation Handle */
.rotate-handle {
    position: absolute;
    top: -30px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 20px;
    background: white;
    border: 2px solid #10B981;
    border-radius: 50%;
    cursor: grab;
    z-index: 11;
    pointer-events: auto;
    display: none;
}

.rotate-handle:active {
    cursor: grabbing;
}

.rotate-handle::after {
    content: '‚Üª';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    color: #10B981;
}

.resize-handle {
    display: none;
}

.image-wrapper.selected .resize-handle,
.image-wrapper.selected .rotate-handle {
    display: block;
}

/* Dragging state */
.image-wrapper.dragging {
    cursor: move !important;
    opacity: 0.8;
}

.image-wrapper.resizing {
    opacity: 0.8;
}

/* Dimension tooltip */
.dimension-tooltip {
    position: fixed;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    display: none;
}

.dimension-tooltip.active {
    display: block;
}

/* Aspect ratio lock indicator */
.aspect-lock-indicator {
    position: absolute;
    top: -24px;
    right: -24px;
    background: #3B82F6;
    color: white;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    pointer-events: none;
    display: none;
}

.image-wrapper.selected .aspect-lock-indicator {
    display: flex;
}

/* Table Wrapper Styles */
.table-wrapper {
    position: absolute;
    cursor: move;
    pointer-events: auto;
    background: #f9fafb;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    overflow: visible;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

/* Arrow Wrapper Styles */
.arrow-wrapper {
    position: absolute;
    cursor: move;
    pointer-events: auto;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
}

.arrow-wrapper.selected {
    outline: 2px solid #F97316;
    outline-offset: 2px;
}

.arrow-handle {
    transition: transform 0.1s ease;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
}

.arrow-handle:hover {
    transform: scale(1.2);
}

.arrow-handle:active {
    cursor: grabbing !important;
}

.table-wrapper.selected {
    outline: 2px solid #8B5CF6;
    outline-offset: 2px;
}

/* Drag handle bar at top of table */
.table-wrapper .table-drag-handle {
    height: 16px;
    background: linear-gradient(to bottom, #e5e7eb, #d1d5db);
    border-bottom: 1px solid #9ca3af;
    cursor: move;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px 4px 0 0;
}

.table-wrapper .table-drag-handle::before {
    content: '‚â°‚â°‚â°';
    color: #6b7280;
    font-size: 10px;
    letter-spacing: 2px;
}

.table-wrapper .table-drag-handle:hover {
    background: linear-gradient(to bottom, #d1d5db, #9ca3af);
}

.table-wrapper.selected .table-drag-handle {
    background: linear-gradient(to bottom, #c4b5fd, #a78bfa);
}

.table-wrapper.selected .table-drag-handle::before {
    color: #4c1d95;
}

.table-wrapper table {
    width: 100%;
    height: auto;
    border-collapse: collapse;
    table-layout: fixed;
    font-size: 12px;
    line-height: 1.2;
    background: white;
}

.table-wrapper th,
.table-wrapper td {
    border: 1px solid #d1d5db;
    padding: 1px 3px;
    text-align: left;
    overflow: hidden;
    white-space: pre-wrap;
    word-wrap: break-word;
    word-break: break-word;
    vertical-align: top;
    cursor: text;
    height: auto;
    line-height: 1.2;
    outline: none;
}

.table-wrapper th:focus,
.table-wrapper td:focus {
    cursor: text;
    outline: 2px solid #8B5CF6;
    outline-offset: -2px;
    background: #faf5ff;
}

/* Editable cell placeholder */
.table-wrapper td:empty::before,
.table-wrapper th:empty::before {
    content: '';
    display: inline-block;
    min-height: 0.5em;
}

.table-wrapper th {
    background: #f3f4f6;
    font-weight: 600;
}

.table-wrapper .resize-handle {
    border-color: #8B5CF6;
}

.table-wrapper.selected .resize-handle {
    display: block;
}

.table-wrapper.dragging {
    cursor: move !important;
    opacity: 0.8;
}

.table-wrapper.resizing {
    opacity: 0.8;
}

/* Column resize handles for table wrapper */
.table-wrapper .col-resize-handle {
    position: absolute;
    top: 6px;
    width: 6px;
    height: calc(100% - 12px);
    cursor: col-resize;
    background: transparent;
    z-index: 10;
}

.table-wrapper .col-resize-handle:hover {
    background: rgba(139, 92, 246, 0.3);
}

.table-wrapper .col-resize-handle.resizing {
    background: rgba(139, 92, 246, 0.5);
}

/* Edge resize handles for table */
.table-wrapper .edge-resize-handle {
    position: absolute;
    background: transparent;
    z-index: 11;
}

/* Left/Right edge handles (horizontal resize) */
.table-wrapper .edge-resize-handle.left,
.table-wrapper .edge-resize-handle.right {
    top: 10px;
    width: 8px;
    height: calc(100% - 20px);
    cursor: ew-resize;
}

.table-wrapper .edge-resize-handle.left {
    left: -4px;
}

.table-wrapper .edge-resize-handle.right {
    right: -4px;
}

/* Top/Bottom edge handles (vertical resize) */
.table-wrapper .edge-resize-handle.top,
.table-wrapper .edge-resize-handle.bottom {
    left: 10px;
    width: calc(100% - 20px);
    height: 8px;
    cursor: ns-resize;
}

.table-wrapper .edge-resize-handle.top {
    top: -4px;
}

.table-wrapper .edge-resize-handle.bottom {
    bottom: -4px;
}

.table-wrapper .edge-resize-handle:hover {
    background: rgba(59, 130, 246, 0.4);
}

.table-wrapper .edge-resize-handle.resizing {
    background: rgba(59, 130, 246, 0.6);
}

/* Corner resize handles for table */
.table-wrapper .corner-resize-handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #8B5CF6;
    border: 1px solid white;
    border-radius: 2px;
    z-index: 12;
    cursor: nwse-resize;
}

.table-wrapper .corner-resize-handle.top-left {
    top: -3px;
    left: -3px;
    cursor: nwse-resize;
}

.table-wrapper .corner-resize-handle.top-right {
    top: -3px;
    right: -3px;
    cursor: nesw-resize;
}

.table-wrapper .corner-resize-handle.bottom-left {
    bottom: -3px;
    left: -3px;
    cursor: nesw-resize;
}

.table-wrapper .corner-resize-handle.bottom-right {
    bottom: -3px;
    right: -3px;
    cursor: nwse-resize;
}

.table-wrapper .corner-resize-handle:hover {
    background: #7C3AED;
    transform: scale(1.2);
}

/* Full-screen layout styles */
.fullscreen-container {
    width: 100%;
    max-width: 100vw;
    padding: 0 1rem;
}

.editor-grid {
    display: block;
    max-height: calc(100vh - 10rem);
}

@media (max-width: 1440px) {
    .editor-grid {
        /* single column, no changes needed */
    }
}

@media (max-width: 1024px) {
    .editor-grid {
        /* single column, no changes needed */
    }
}

/* Horizontal slide buttons */
.slide-buttons-row {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 0.5rem;
    background: #f3f4f6;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    max-height: 80px;
    overflow-y: auto;
}

.slide-btn {
    min-width: 40px;
    height: 36px;
    padding: 0.25rem 0.75rem;
    border-radius: 0.375rem;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
    border: 2px solid transparent;
    background: white;
    color: #374151;
}

.slide-btn:hover {
    background: #e5e7eb;
}

.slide-btn.active {
    background: #3b82f6;
    color: white;
    border-color: #2563eb;
}

.slide-btn-add {
    background: #10b981;
    color: white;
}

.slide-btn-add:hover {
    background: #059669;
}

.sidebar-panel {
    display: flex;
    flex-direction: column;
}

.sidebar-panel > div {
    flex: 1;
}



.center-panel {
    display: flex;
    flex-direction: column;
    max-height: calc(100vh - 12rem);
    overflow-y: auto;
}

.preview-container {
    width: 100%;
    max-height: 60vh;
}

/* List styles in contenteditable */
#editableContent ul {
    list-style-type: disc;
    padding-left: 2em;
    margin: 0.5em 0;
    color: inherit;
}

#editableContent ol {
    list-style-type: decimal;
    padding-left: 2em;
    margin: 0.5em 0;
    color: inherit;
}

#editableContent li {
    margin: 0.25em 0;
    color: inherit;
}

/* Preview Toolbar Styles */
.preview-toolbar {
    flex-shrink: 0;
}

.toolbar-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    padding: 6px 10px;
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s ease;
    min-width: 50px;
}

.toolbar-btn:hover {
    background: #f3f4f6;
    border-color: #9ca3af;
}

.toolbar-btn.active {
    background: #dbeafe;
    border-color: #3b82f6;
}

.toolbar-dropdown {
    position: relative;
}

.toolbar-dropdown-content {
    position: absolute;
    top: 100%;
    left: 0;
    margin-top: 4px;
    background: white;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    z-index: 100;
    min-width: 200px;
}

.toolbar-dropdown-content.hidden {
    display: none;
}

/* Image drop zone active state */
#imageDropZone.drag-over {
    border-color: #3b82f6;
    background: #dbeafe;
}
</style>
<div class="fullscreen-container">
    <div class="mb-6 flex justify-between items-center">
        <h1 class="text-3xl font-bold text-gray-900">–†–µ–¥–∞–∫—Ç–æ—Ä —Å–ª–∞–π–¥–æ–≤</h1>
        <div class="flex gap-3 items-center">
            <!-- Save status indicator -->
            <div id="saveStatus" class="text-sm">
                <span id="saveStatusText" class="text-gray-600"></span>
            </div>
            <button id="manualSaveBtn" onclick="manualSave()" class="px-3 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 text-sm">
                üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
            </button>
            <button onclick="window.location.href='/'" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                ‚Üê –ù–∞–∑–∞–¥
            </button>
            <button id="createBtn" onclick="openDownloadModal()" class="px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700">
                ‚¨á –°–∫–∞—á–∞—Ç—å PDF
            </button>
        </div>
    </div>

    <!-- Progress bar -->
    <div id="progressBar" class="hidden mb-6">
        <div class="w-full bg-gray-200 rounded-full h-2.5">
            <div id="progressBarFill" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <p id="progressText" class="text-sm text-gray-600 mt-2 text-center">–û–±—Ä–∞–±–æ—Ç–∫–∞...</p>
    </div>

    <div class="editor-grid">
        <!-- Slide Editor (Center Panel) -->
        <div class="center-panel">
            <div class="bg-white rounded-lg shadow p-8 lg:p-10 flex-1">
                <!-- Horizontal Slide Buttons -->
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="text-lg font-bold">–°–ª–∞–π–¥ <span id="currentSlideNumber">1</span></h2>
                        <button onclick="deleteCurrentSlide()" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                            üóë –£–¥–∞–ª–∏—Ç—å
                        </button>
                    </div>
                    <div id="slidesList" class="slide-buttons-row">
                        <!-- Slide buttons will be rendered here -->
                    </div>
                </div>

                <!-- Formatting Toolbar (above preview) - REMOVED, now in each editor block -->

                <!-- Two-column layout: Editors left (1/3), Preview right (2/3) -->
                <div class="flex gap-4" style="height: calc(100vh - 280px);">
                    <!-- Left: Text Editors (1/3 width) -->
                    <div class="w-1/3 flex flex-col gap-2 overflow-hidden">
                        <!-- Title Editor -->
                        <div class="border rounded-lg overflow-hidden flex-shrink-0">
                            <div class="bg-blue-500 text-white px-3 py-1 text-sm font-semibold flex items-center justify-between">
                                <div class="flex items-center gap-2">
                                    <span>–ó–∞–≥–æ–ª–æ–≤–æ–∫</span>
                                    <span class="text-xs opacity-75">(32px)</span>
                                </div>
                            </div>
                            <!-- Compact Toolbar for Title -->
                            <div class="flex gap-1 flex-wrap bg-blue-50 p-1 border-b items-center">
                                <button type="button" onclick="formatTextInEditor('editorTitle', 'bold')" class="px-2 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 font-bold text-xs" title="–ñ–∏—Ä–Ω—ã–π">B</button>
                                <button type="button" onclick="formatTextInEditor('editorTitle', 'italic')" class="px-2 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 italic text-xs" title="–ö—É—Ä—Å–∏–≤">I</button>
                                <button type="button" onclick="formatTextInEditor('editorTitle', 'underline')" class="px-2 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 underline text-xs" title="–ü–æ–¥—á—ë—Ä–∫–Ω—É—Ç—ã–π">U</button>
                                <input type="color" id="titleTextColor" value="#000000" class="h-6 w-6 rounded border cursor-pointer" onmousedown="saveSelection()" onchange="applyTextColorToEditor('editorTitle', this.value)" title="–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞">
                                <span class="border-l mx-1 h-4"></span>
                                <button type="button" onclick="clearFormattingInEditor('editorTitle')" class="px-1 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 text-xs" title="–û—á–∏—Å—Ç–∏—Ç—å">‚úï</button>
                            </div>
                            <div id="editorTitle" 
                                 contenteditable="true"
                                 class="p-3 min-h-[60px] max-h-[100px] overflow-y-auto focus:outline-none focus:bg-blue-50 text-xl font-bold"
                                 oninput="syncBlocksToPreview()"
                                 placeholder="–í–≤–µ–¥–∏—Ç–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫..."></div>
                        </div>
                        
                        <!-- Main Text Editor - flexible height with scroll -->
                        <div class="border rounded-lg overflow-hidden flex-1 flex flex-col min-h-0">
                            <div class="bg-green-500 text-white px-3 py-1 text-sm font-semibold flex items-center justify-between flex-shrink-0">
                                <div class="flex items-center gap-2">
                                    <span>–û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç</span>
                                    <span class="text-xs opacity-75">(18px)</span>
                                </div>
                            </div>
                            <!-- Compact Toolbar for Main Text -->
                            <div class="flex gap-1 flex-wrap bg-green-50 p-1 border-b items-center flex-shrink-0">
                                <button type="button" onclick="formatTextInEditor('editorMainText', 'bold')" class="px-2 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 font-bold text-xs" title="–ñ–∏—Ä–Ω—ã–π">B</button>
                                <button type="button" onclick="formatTextInEditor('editorMainText', 'italic')" class="px-2 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 italic text-xs" title="–ö—É—Ä—Å–∏–≤">I</button>
                                <button type="button" onclick="formatTextInEditor('editorMainText', 'underline')" class="px-2 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 underline text-xs" title="–ü–æ–¥—á—ë—Ä–∫–Ω—É—Ç—ã–π">U</button>
                                <input type="color" id="mainTextColor" value="#000000" class="h-6 w-6 rounded border cursor-pointer" onmousedown="saveSelection()" onchange="applyTextColorToEditor('editorMainText', this.value)" title="–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞">
                                <span class="border-l mx-1 h-4"></span>
                                <select onchange="applyListStyleToEditor('editorMainText', 'ul', this.value); this.selectedIndex=0;" class="px-1 py-0.5 bg-white border border-gray-300 rounded text-xs" title="–ú–∞—Ä–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫">
                                    <option value="" disabled selected>‚Ä¢</option>
                                    <option value="disc">‚Ä¢ –ö—Ä—É–≥</option>
                                    <option value="circle">‚óã –ü—É—Å—Ç–æ–π</option>
                                    <option value="square">‚ñ† –ö–≤–∞–¥—Ä–∞—Ç</option>
                                    <option value="remove">‚úï –£–±—Ä–∞—Ç—å</option>
                                </select>
                                <select onchange="applyListStyleToEditor('editorMainText', 'ol', this.value); this.selectedIndex=0;" class="px-1 py-0.5 bg-white border border-gray-300 rounded text-xs" title="–ù—É–º–µ—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫">
                                    <option value="" disabled selected>1.</option>
                                    <option value="decimal">1, 2, 3</option>
                                    <option value="lower-alpha">a, b, c</option>
                                    <option value="upper-alpha">A, B, C</option>
                                    <option value="remove">‚úï –£–±—Ä–∞—Ç—å</option>
                                </select>
                                <span class="border-l mx-1 h-4"></span>
                                <button type="button" onclick="clearFormattingInEditor('editorMainText')" class="px-1 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 text-xs" title="–û—á–∏—Å—Ç–∏—Ç—å">‚úï</button>
                            </div>
                            <div id="editorMainText" 
                                 contenteditable="true"
                                 class="p-3 flex-1 overflow-y-auto focus:outline-none focus:bg-green-50"
                                 oninput="syncBlocksToPreview()"
                                 placeholder="–í–≤–µ–¥–∏—Ç–µ –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç..."></div>
                        </div>
                        
                        <!-- Comment Editor -->
                        <div class="border rounded-lg overflow-hidden flex-shrink-0">
                            <div class="bg-gray-500 text-white px-3 py-1 text-sm font-semibold flex items-center justify-between">
                                <div class="flex items-center gap-2">
                                    <span>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π</span>
                                    <span class="text-xs opacity-75">(14px)</span>
                                </div>
                            </div>
                            <!-- Compact Toolbar for Comment -->
                            <div class="flex gap-1 flex-wrap bg-gray-100 p-1 border-b items-center">
                                <button type="button" onclick="formatTextInEditor('editorComment', 'bold')" class="px-2 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 font-bold text-xs" title="–ñ–∏—Ä–Ω—ã–π">B</button>
                                <button type="button" onclick="formatTextInEditor('editorComment', 'italic')" class="px-2 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 italic text-xs" title="–ö—É—Ä—Å–∏–≤">I</button>
                                <button type="button" onclick="formatTextInEditor('editorComment', 'underline')" class="px-2 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 underline text-xs" title="–ü–æ–¥—á—ë—Ä–∫–Ω—É—Ç—ã–π">U</button>
                                <input type="color" id="commentTextColor" value="#6B7280" class="h-6 w-6 rounded border cursor-pointer" onmousedown="saveSelection()" onchange="applyTextColorToEditor('editorComment', this.value)" title="–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞">
                                <span class="border-l mx-1 h-4"></span>
                                <button type="button" onclick="clearFormattingInEditor('editorComment')" class="px-1 py-0.5 bg-white border border-gray-300 rounded hover:bg-gray-100 text-xs" title="–û—á–∏—Å—Ç–∏—Ç—å">‚úï</button>
                            </div>
                            <div id="editorComment" 
                                 contenteditable="true"
                                 class="p-3 min-h-[50px] max-h-[80px] overflow-y-auto focus:outline-none focus:bg-gray-50 text-sm text-gray-600"
                                 oninput="syncBlocksToPreview()"
                                 placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π..."></div>
                        </div>
                    </div>
                    
                    <!-- Right: Slide Preview with Toolbar (2/3 width) -->
                    <div class="w-2/3 flex flex-col">
                        <!-- Toolbar above preview -->
                        <div class="preview-toolbar flex items-center gap-1 mb-2 p-2 bg-gray-100 rounded-lg flex-wrap">
                            <!-- Background dropdown -->
                            <div class="toolbar-dropdown relative">
                                <button onclick="toggleToolbarDropdown('bgDropdown')" class="toolbar-btn" title="–§–æ–Ω">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                    </svg>
                                    <span class="text-xs">–§–æ–Ω</span>
                                </button>
                                <div id="bgDropdown" class="toolbar-dropdown-content hidden">
                                    <div class="p-3 w-64">
                                        <h4 class="font-semibold text-sm mb-2">–§–æ–Ω —Å–ª–∞–π–¥–∞</h4>
                                        <div class="space-y-2">
                                            <label class="flex items-center cursor-pointer hover:bg-gray-50 p-1 rounded">
                                                <input type="radio" name="bgType" value="none" checked onchange="changeBackgroundType('none')" class="mr-2">
                                                <span class="text-sm">–ë–µ–∑ —Ñ–æ–Ω–∞ (–±–µ–ª—ã–π)</span>
                                            </label>
                                            <label class="flex items-center cursor-pointer hover:bg-gray-50 p-1 rounded">
                                                <input type="radio" name="bgType" value="solid" onchange="changeBackgroundType('solid')" class="mr-2">
                                                <span class="text-sm">–û–¥–Ω–æ—Ç–æ–Ω–Ω—ã–π —Ü–≤–µ—Ç</span>
                                            </label>
                                            <label class="flex items-center cursor-pointer hover:bg-gray-50 p-1 rounded">
                                                <input type="radio" name="bgType" value="gradient" onchange="changeBackgroundType('gradient')" class="mr-2">
                                                <span class="text-sm">–ì—Ä–∞–¥–∏–µ–Ω—Ç</span>
                                            </label>
                                            <label class="flex items-center cursor-pointer hover:bg-gray-50 p-1 rounded">
                                                <input type="radio" name="bgType" value="image" onchange="changeBackgroundType('image')" class="mr-2">
                                                <span class="text-sm">–ö–∞—Ä—Ç–∏–Ω–∫–∞</span>
                                            </label>
                                        </div>
                                        <!-- Solid color picker -->
                                        <div id="solidColorPicker" class="hidden mt-3 pt-2 border-t">
                                            <label class="block text-xs text-gray-600 mb-1">–¶–≤–µ—Ç —Ñ–æ–Ω–∞</label>
                                            <input type="color" id="bgColor" value="#FFFFFF" class="w-full h-10 rounded border cursor-pointer" onchange="updateBackground()">
                                        </div>
                                        <!-- Gradient picker -->
                                        <div id="gradientPicker" class="hidden mt-3 pt-2 border-t space-y-2">
                                            <div class="flex gap-2">
                                                <div class="flex-1">
                                                    <label class="block text-xs text-gray-600 mb-1">–¶–≤–µ—Ç 1</label>
                                                    <input type="color" id="gradientColor1" value="#667eea" class="w-full h-8 rounded border cursor-pointer" onchange="updateBackground()">
                                                </div>
                                                <div class="flex-1">
                                                    <label class="block text-xs text-gray-600 mb-1">–¶–≤–µ—Ç 2</label>
                                                    <input type="color" id="gradientColor2" value="#764ba2" class="w-full h-8 rounded border cursor-pointer" onchange="updateBackground()">
                                                </div>
                                            </div>
                                            <select id="gradientDirection" class="w-full p-2 border rounded text-sm" onchange="updateBackground()">
                                                <option value="to right">–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π ‚Üí</option>
                                                <option value="to bottom">–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π ‚Üì</option>
                                                <option value="to bottom right">–î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π ‚Üò</option>
                                            </select>
                                        </div>
                                        <!-- Image background picker -->
                                        <div id="imageBgPicker" class="hidden mt-3 pt-2 border-t space-y-2">
                                            <input type="file" id="bgImageInput" accept="image/*" class="hidden" onchange="handleBackgroundImageUpload(event)">
                                            <button type="button" onclick="document.getElementById('bgImageInput').click()" class="w-full px-2 py-2 bg-green-500 text-white rounded text-sm hover:bg-green-600">
                                                + –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                                            </button>
                                            <div id="bgImagePreview" class="text-xs text-gray-500"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Font dropdown -->
                            <div class="toolbar-dropdown relative">
                                <button onclick="toggleToolbarDropdown('fontDropdown')" class="toolbar-btn" title="–®—Ä–∏—Ñ—Ç">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"/>
                                    </svg>
                                    <span class="text-xs">–®—Ä–∏—Ñ—Ç</span>
                                </button>
                                <div id="fontDropdown" class="toolbar-dropdown-content hidden">
                                    <div class="p-3 w-72">
                                        <h4 class="font-semibold text-sm mb-2">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —à—Ä–∏—Ñ—Ç–∞</h4>
                                        <!-- Font Family -->
                                        <div class="mb-3">
                                            <label class="block text-xs text-gray-600 mb-1">–®—Ä–∏—Ñ—Ç</label>
                                            <select id="fontFamily" class="w-full p-2 border border-gray-300 rounded text-sm" onchange="changeFontFamily()">
                                                <optgroup label="–°–∏—Å—Ç–µ–º–Ω—ã–µ">
                                                    <option value="Arial" selected>Arial</option>
                                                    <option value="Times New Roman">Times New Roman</option>
                                                    <option value="Calibri">Calibri</option>
                                                    <option value="Georgia">Georgia</option>
                                                    <option value="Verdana">Verdana</option>
                                                    <option value="Helvetica">Helvetica</option>
                                                </optgroup>
                                                <optgroup label="Google Fonts">
                                                    <option data-google="true" value="Roboto">Roboto</option>
                                                    <option data-google="true" value="Open Sans">Open Sans</option>
                                                    <option data-google="true" value="Montserrat">Montserrat</option>
                                                    <option data-google="true" value="Poppins">Poppins</option>
                                                    <option data-google="true" value="Inter">Inter</option>
                                                    <option data-google="true" value="Playfair Display">Playfair Display</option>
                                                    <option data-google="true" value="PT Sans">PT Sans</option>
                                                    <option data-google="true" value="Nunito">Nunito</option>
                                                </optgroup>
                                            </select>
                                        </div>
                                        <!-- Font Sizes -->
                                        <div class="space-y-2">
                                            <div>
                                                <div class="flex justify-between text-xs mb-1">
                                                    <span class="text-blue-600">–ó–∞–≥–æ–ª–æ–≤–æ–∫</span>
                                                    <span id="titleFontSizeValue" class="text-gray-600">32px</span>
                                                </div>
                                                <input type="range" id="titleFontSize" min="16" max="72" value="32" class="w-full h-2 bg-blue-200 rounded-lg cursor-pointer" oninput="applyBlockFontSize('title', this.value)">
                                            </div>
                                            <div>
                                                <div class="flex justify-between text-xs mb-1">
                                                    <span class="text-green-600">–û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç</span>
                                                    <span id="mainTextFontSizeValue" class="text-gray-600">18px</span>
                                                </div>
                                                <input type="range" id="mainTextFontSize" min="10" max="48" value="18" class="w-full h-2 bg-green-200 rounded-lg cursor-pointer" oninput="applyBlockFontSize('mainText', this.value)">
                                            </div>
                                            <div>
                                                <div class="flex justify-between text-xs mb-1">
                                                    <span class="text-gray-600">–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π</span>
                                                    <span id="commentFontSizeValue" class="text-gray-600">14px</span>
                                                </div>
                                                <input type="range" id="commentFontSize" min="8" max="32" value="14" class="w-full h-2 bg-gray-300 rounded-lg cursor-pointer" oninput="applyBlockFontSize('comment', this.value)">
                                            </div>
                                        </div>
                                        <!-- Text Alignment -->
                                        <div class="mt-3 pt-2 border-t">
                                            <label class="block text-xs text-gray-600 mb-1">–í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ</label>
                                            <div class="flex gap-1">
                                                <button id="posHorizLeft" onclick="changeTextPosition(null, 'left')" class="flex-1 p-2 border rounded hover:bg-gray-50 bg-blue-100 border-blue-500" title="–ü–æ –ª–µ–≤–æ–º—É –∫—Ä–∞—é">
                                                    <svg class="w-4 h-4 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h10M4 18h14"/></svg>
                                                </button>
                                                <button id="posHorizCenter" onclick="changeTextPosition(null, 'center')" class="flex-1 p-2 border rounded hover:bg-gray-50" title="–ü–æ —Ü–µ–Ω—Ç—Ä—É">
                                                    <svg class="w-4 h-4 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M7 12h10M5 18h14"/></svg>
                                                </button>
                                                <button id="posHorizRight" onclick="changeTextPosition(null, 'right')" class="flex-1 p-2 border rounded hover:bg-gray-50" title="–ü–æ –ø—Ä–∞–≤–æ–º—É –∫—Ä–∞—é">
                                                    <svg class="w-4 h-4 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M10 12h10M6 18h14"/></svg>
                                                </button>
                                                <button id="posHorizJustify" onclick="changeTextPosition(null, 'justify')" class="flex-1 p-2 border rounded hover:bg-gray-50" title="–ü–æ —à–∏—Ä–∏–Ω–µ">
                                                    <svg class="w-4 h-4 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Image upload dropdown -->
                            <div class="toolbar-dropdown relative">
                                <button onclick="toggleToolbarDropdown('imageDropdown')" class="toolbar-btn" title="–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/>
                                    </svg>
                                    <span class="text-xs">–ö–∞—Ä—Ç–∏–Ω–∫–∞</span>
                                </button>
                                <div id="imageDropdown" class="toolbar-dropdown-content hidden">
                                    <div class="p-3 w-64">
                                        <h4 class="font-semibold text-sm mb-2">–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</h4>
                                        <input type="file" id="imageUploadInput" accept="image/*" multiple class="hidden" onchange="handleImageUpload(event)">
                                        <div id="imageDropZone" onclick="document.getElementById('imageUploadInput').click()" 
                                             class="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center cursor-pointer hover:border-blue-400 hover:bg-blue-50 transition-colors">
                                            <svg class="w-8 h-8 mx-auto text-gray-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                            </svg>
                                            <p class="text-sm text-gray-600">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–ª–∏ –∫–ª–∏–∫–Ω–∏—Ç–µ</p>
                                        </div>
                                        <div id="imagesList" class="space-y-1 max-h-32 overflow-y-auto mt-2">
                                            <!-- Images will be listed here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Tables dropdown -->
                            <div class="toolbar-dropdown relative">
                                <button onclick="toggleToolbarDropdown('tableDropdown')" class="toolbar-btn" title="–¢–∞–±–ª–∏—Ü—ã">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                                    </svg>
                                    <span class="text-xs">–¢–∞–±–ª–∏—Ü–∞</span>
                                </button>
                                <div id="tableDropdown" class="toolbar-dropdown-content hidden">
                                    <div class="p-3 w-48">
                                        <h4 class="font-semibold text-sm mb-2">–¢–∞–±–ª–∏—Ü—ã</h4>
                                        <button onclick="showTableModal(); closeAllDropdowns();" class="w-full px-3 py-2 bg-purple-500 text-white rounded text-sm hover:bg-purple-600 mb-2">
                                            + –î–æ–±–∞–≤–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É
                                        </button>
                                        <div id="tablesList" class="space-y-1 max-h-24 overflow-y-auto">
                                            <!-- Tables will be listed here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Arrows dropdown -->
                            <div class="toolbar-dropdown relative">
                                <button onclick="toggleToolbarDropdown('arrowDropdown')" class="toolbar-btn" title="–°—Ç—Ä–µ–ª–∫–∏">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"/>
                                    </svg>
                                    <span class="text-xs">–°—Ç—Ä–µ–ª–∫–∞</span>
                                </button>
                                <div id="arrowDropdown" class="toolbar-dropdown-content hidden">
                                    <div class="p-3 w-48">
                                        <h4 class="font-semibold text-sm mb-2">–°—Ç—Ä–µ–ª–∫–∏</h4>
                                        <button onclick="showArrowModal(); closeAllDropdowns();" class="w-full px-3 py-2 bg-orange-500 text-white rounded text-sm hover:bg-orange-600 mb-2">
                                            + –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–µ–ª–∫—É
                                        </button>
                                        <div id="arrowsList" class="space-y-1 max-h-24 overflow-y-auto">
                                            <!-- Arrows will be listed here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Accent dropdown -->
                            <div class="toolbar-dropdown relative">
                                <button onclick="toggleToolbarDropdown('accentDropdown')" class="toolbar-btn" title="–ê–∫—Ü–µ–Ω—Ç">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <span class="text-xs">–ê–∫—Ü–µ–Ω—Ç</span>
                                </button>
                                <div id="accentDropdown" class="toolbar-dropdown-content hidden">
                                    <div class="p-3 w-48">
                                        <h4 class="font-semibold text-sm mb-2">–ê–∫—Ü–µ–Ω—Ç–Ω—ã–µ –±–ª–æ–∫–∏</h4>
                                        <button onclick="showAccentBoxModal(); closeAllDropdowns();" class="w-full px-3 py-2 bg-indigo-500 text-white rounded text-sm hover:bg-indigo-600 mb-2">
                                            + –î–æ–±–∞–≤–∏—Ç—å –∞–∫—Ü–µ–Ω—Ç
                                        </button>
                                        <div id="accentBoxesList" class="space-y-1 max-h-24 overflow-y-auto">
                                            <!-- Accent boxes will be listed here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="flex-1"></div>
                            
                            <!-- Page format -->
                            <select id="pageOrientation" class="p-1.5 border border-gray-300 rounded text-xs bg-white" onchange="applyPageOrientation()">
                                <option value="16:9">16:9</option>
                                <option value="4:3">4:3</option>
                                <option value="1:1">1:1</option>
                                <option value="9:16">9:16</option>
                            </select>
                            
                            <!-- Apply to all button -->
                            <button onclick="applyToAll()" class="px-2 py-1.5 bg-blue-500 text-white rounded text-xs hover:bg-blue-600" title="–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–æ –≤—Å–µ–º">
                                –ö–æ –≤—Å–µ–º
                            </button>
                        </div>
                        
                        <!-- Slide Preview -->
                        <div class="flex-1 flex items-start justify-center overflow-hidden">
                            <div id="slidePreview" class="border-2 border-blue-400 rounded-lg bg-white relative" style="aspect-ratio: 16/9; width: 100%; max-height: 100%;" onclick="handleSlidePreviewClick(event)">
                            <!-- Text display container (not editable here) -->
                            <div id="textLayerContainer" class="absolute inset-0 p-8 flex flex-col" style="z-index: 10;">
                                <div id="previewTitle" class="font-bold text-3xl text-gray-900 mb-2"></div>
                                <div id="previewMainText" class="text-lg text-gray-700 flex-1"></div>
                                <div id="previewComment" class="text-sm text-gray-500 mt-auto"></div>
                            </div>
                            <!-- Images layer -->
                            <div id="previewImages" class="absolute inset-0" style="z-index: 20; pointer-events: none;"></div>
                            <!-- Arrows layer -->
                            <div id="previewArrows" class="absolute inset-0" style="z-index: 18; pointer-events: none;"></div>
                            <!-- Tables layer -->
                            <div id="previewTables" class="absolute inset-0" style="z-index: 15; pointer-events: none;"></div>
                            <!-- Accent Boxes layer -->
                            <div id="previewAccentBoxes" class="absolute inset-0" style="z-index: 12; pointer-events: none;"></div>
                            </div>
                        </div>
                        <!-- Dimension Tooltip -->
                        <div id="dimensionTooltip" class="dimension-tooltip"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Hidden vertical alignment buttons (for JS compatibility) -->
        <div class="hidden">
            <button id="posVertTop"></button>
            <button id="posVertCenter"></button>
            <button id="posVertBottom"></button>
        </div>
    </div>
</div>

<!-- Table Modal -->
<div id="tableModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-sm w-full">
        <h3 class="text-lg font-bold mb-4">–î–æ–±–∞–≤–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É</h3>
        <div class="space-y-4">
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">–°—Ç—Ä–æ–∫–∏</label>
                    <input type="number" id="tableRows" min="1" max="20" value="3" class="w-full p-2 border border-gray-300 rounded-lg text-center text-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">–°—Ç–æ–ª–±—Ü—ã</label>
                    <input type="number" id="tableColumns" min="1" max="10" value="3" class="w-full p-2 border border-gray-300 rounded-lg text-center text-lg">
                </div>
            </div>
            <p class="text-xs text-gray-500 text-center">–¢–∞–±–ª–∏—Ü–∞ –ø–æ—è–≤–∏—Ç—Å—è –≤ —Ü–µ–Ω—Ç—Ä–µ —Å–ª–∞–π–¥–∞. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.</p>
        </div>
        <div class="flex gap-2 mt-6">
            <button onclick="addTable()" class="flex-1 px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600">–î–æ–±–∞–≤–∏—Ç—å</button>
            <button onclick="closeTableModal()" class="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<!-- Table Cell Editor Modal -->
<div id="tableCellEditorModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-4xl w-full max-h-[80vh] overflow-y-auto">
        <h3 class="text-lg font-bold mb-4">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã</h3>
        
        <!-- Add Row/Column Buttons -->
        <div class="flex gap-2 mb-4 flex-wrap">
            <button onclick="addTableRow()" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                + –°—Ç—Ä–æ–∫–∞
            </button>
            <button onclick="addTableColumn()" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                + –°—Ç–æ–ª–±–µ—Ü
            </button>
            <span class="border-l mx-1"></span>
            <span id="tableDimensions" class="text-sm text-gray-600 self-center"></span>
            <span class="ml-auto text-xs text-gray-500 self-center">–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ ‚úï —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å —Å—Ç—Ä–æ–∫—É/—Å—Ç–æ–ª–±–µ—Ü</span>
        </div>
        
        <div id="tableCellGrid" class="space-y-2 mb-4">
            <!-- Cell grid will be dynamically generated -->
        </div>
        
        <!-- Background Color Controls -->
        <div class="mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
            <h4 class="text-sm font-semibold text-gray-700 mb-3">–¶–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏ —Ç–∞–±–ª–∏—Ü—ã</h4>
            <div class="flex gap-2 items-center">
                <input type="color" id="cellBgColor" value="#FFFFFF" class="h-10 w-20 rounded border cursor-pointer" onchange="applyCellBgToAll()">
                <span id="cellBgColorValue" class="text-sm text-gray-600">#FFFFFF</span>
            </div>
        </div>
        
        <div class="flex gap-2 mt-6">
            <button onclick="saveCellData()" class="flex-1 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button onclick="closeCellEditor()" class="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<!-- Arrow Modal -->
<div id="arrowModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-md w-full">
        <h3 class="text-lg font-bold mb-4">–î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–µ–ª–∫—É</h3>
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">–¢–∏–ø —Å—Ç—Ä–µ–ª–∫–∏</label>
                <select id="arrowType" class="w-full p-2 border border-gray-300 rounded-lg">
                    <option value="straight">–ü—Ä—è–º–∞—è</option>
                    <option value="bent">–° –∏–∑–ª–æ–º–æ–º</option>
                    <option value="curved">–ò–∑–æ–≥–Ω—É—Ç–∞—è</option>
                </select>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-700">–ù–∞—á–∞–ª–æ X</label>
                    <input type="number" id="arrowStartX" value="100" class="w-full p-2 border border-gray-300 rounded">
                </div>
                <div>
                    <label class="block text-sm text-gray-700">–ù–∞—á–∞–ª–æ Y</label>
                    <input type="number" id="arrowStartY" value="150" class="w-full p-2 border border-gray-300 rounded">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-700">–ö–æ–Ω–µ—Ü X</label>
                    <input type="number" id="arrowEndX" value="300" class="w-full p-2 border border-gray-300 rounded">
                </div>
                <div>
                    <label class="block text-sm text-gray-700">–ö–æ–Ω–µ—Ü Y</label>
                    <input type="number" id="arrowEndY" value="150" class="w-full p-2 border border-gray-300 rounded">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-700">–¶–≤–µ—Ç</label>
                    <input type="color" id="arrowColor" value="#000000" class="w-full p-1 border border-gray-300 rounded h-10">
                </div>
                <div>
                    <label class="block text-sm text-gray-700">–¢–æ–ª—â–∏–Ω–∞ (PT)</label>
                    <input type="number" id="arrowStroke" min="1" max="10" value="2" class="w-full p-2 border border-gray-300 rounded">
                </div>
            </div>
        </div>
        <div class="flex gap-2 mt-6">
            <button onclick="addArrow()" class="flex-1 px-4 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600">–î–æ–±–∞–≤–∏—Ç—å</button>
            <button onclick="closeArrowModal()" class="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<!-- Accent Box Modal -->
<div id="accentBoxModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-md w-full max-h-[90vh] overflow-y-auto">
        <h3 id="accentBoxModalTitle" class="text-lg font-bold mb-4">–ê–∫—Ü–µ–Ω—Ç–Ω—ã–π –±–ª–æ–∫</h3>
        <div class="space-y-3">
            <div>
                <label class="block text-sm font-medium mb-1">–¢–µ–∫—Å—Ç</label>
                <div id="accentText" contenteditable="true" class="w-full p-2 border rounded text-sm min-h-[60px] max-h-[120px] overflow-y-auto focus:outline-none focus:ring-2 focus:ring-blue-500"></div>
            </div>
            
            <!-- Font Settings -->
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-xs text-gray-600 mb-1">–®—Ä–∏—Ñ—Ç</label>
                    <select id="accentFontFamily" onchange="updateAccentTextPreview()" class="w-full p-1.5 border rounded text-sm">
                        <option value="Arial">Arial</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Roboto">Roboto</option>
                        <option value="Open Sans">Open Sans</option>
                        <option value="Montserrat">Montserrat</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs text-gray-600 mb-1">–†–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞</label>
                    <input type="number" id="accentFontSize" value="14" min="8" max="72" onchange="updateAccentTextPreview()" oninput="updateAccentTextPreview()" class="w-full p-1.5 border rounded text-sm">
                </div>
            </div>
            
            <!-- Text Formatting -->
            <div>
                <label class="block text-xs text-gray-600 mb-1">–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ</label>
                <div class="flex gap-1">
                    <button type="button" id="accentBold" onclick="toggleAccentFormat('bold')" 
                            class="px-3 py-1.5 border rounded text-sm font-bold hover:bg-gray-100">B</button>
                    <button type="button" id="accentItalic" onclick="toggleAccentFormat('italic')" 
                            class="px-3 py-1.5 border rounded text-sm italic hover:bg-gray-100">I</button>
                    <button type="button" id="accentUnderline" onclick="toggleAccentFormat('underline')" 
                            class="px-3 py-1.5 border rounded text-sm underline hover:bg-gray-100">U</button>
                </div>
            </div>
            
            <!-- Colors -->
            <div class="grid grid-cols-3 gap-2">
                <div>
                    <label class="block text-xs text-gray-600 mb-1">–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞</label>
                    <input type="color" id="accentTextColor" value="#1E1B4B" oninput="updateAccentTextPreview()" class="w-full h-8 rounded cursor-pointer">
                </div>
                <div>
                    <label class="block text-xs text-gray-600 mb-1">–¶–≤–µ—Ç —Ñ–æ–Ω–∞</label>
                    <input type="color" id="accentBgColor" value="#E0E7FF" oninput="updateAccentTextPreview()" class="w-full h-8 rounded cursor-pointer">
                </div>
                <div>
                    <label class="block text-xs text-gray-600 mb-1">–¶–≤–µ—Ç —Ä–∞–º–∫–∏</label>
                    <input type="color" id="accentBorderColor" value="#4F46E5" oninput="updateAccentTextPreview()" class="w-full h-8 rounded cursor-pointer">
                </div>
            </div>
            
            <!-- Position -->
            <div class="grid grid-cols-4 gap-2">
                <div>
                    <label class="block text-xs text-gray-600 mb-1">X</label>
                    <input type="number" id="accentX" value="50" class="w-full p-1.5 border rounded text-sm">
                </div>
                <div>
                    <label class="block text-xs text-gray-600 mb-1">Y</label>
                    <input type="number" id="accentY" value="200" class="w-full p-1.5 border rounded text-sm">
                </div>
                <div>
                    <label class="block text-xs text-gray-600 mb-1">–®–∏—Ä–∏–Ω–∞</label>
                    <input type="number" id="accentWidth" value="300" class="w-full p-1.5 border rounded text-sm">
                </div>
                <div>
                    <label class="block text-xs text-gray-600 mb-1">–í—ã—Å–æ—Ç–∞</label>
                    <input type="number" id="accentHeight" value="100" class="w-full p-1.5 border rounded text-sm">
                </div>
            </div>
        </div>
        <div class="flex gap-2 mt-4">
            <button id="accentBoxSubmitBtn" onclick="saveAccentBox()" class="flex-1 px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600">–î–æ–±–∞–≤–∏—Ç—å</button>
            <button onclick="closeAccentBoxModal()" class="flex-1 px-4 py-2 bg-gray-300 rounded-lg hover:bg-gray-400">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<!-- PDF Download Modal -->
<div id="downloadModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-md w-full">
        <h3 class="text-lg font-bold mb-4">–°–∫–∞—á–∞—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é</h3>
        <p class="text-gray-600 mb-6">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –∑–∞–≥—Ä—É–∑–∫–∏:</p>
        
        <div id="downloadOptions" class="space-y-3">
            <button onclick="downloadSinglePDF()" class="w-full p-4 border-2 border-blue-500 rounded-lg hover:bg-blue-50 transition flex items-center gap-3">
                <span class="text-3xl">üìÑ</span>
                <div class="text-left">
                    <div class="font-semibold text-blue-700">–û–¥–∏–Ω PDF –¥–æ–∫—É–º–µ–Ω—Ç</div>
                    <div class="text-sm text-gray-500">–í—Å–µ —Å–ª–∞–π–¥—ã –≤ –æ–¥–Ω–æ–º —Ñ–∞–π–ª–µ</div>
                </div>
            </button>
            
            <button onclick="downloadZipPDFs()" class="w-full p-4 border-2 border-green-500 rounded-lg hover:bg-green-50 transition flex items-center gap-3">
                <span class="text-3xl">üìÅ</span>
                <div class="text-left">
                    <div class="font-semibold text-green-700">ZIP –∞—Ä—Ö–∏–≤</div>
                    <div class="text-sm text-gray-500">–ö–∞–∂–¥—ã–π —Å–ª–∞–π–¥ –æ—Ç–¥–µ–ª—å–Ω—ã–º PDF</div>
                </div>
            </button>
        </div>
        
        <!-- Progress indicator -->
        <div id="downloadProgress" class="hidden mt-4">
            <div class="w-full bg-gray-200 rounded-full h-2.5">
                <div id="downloadProgressBar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <p id="downloadProgressText" class="text-sm text-gray-600 mt-2 text-center">–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...</p>
        </div>
        
        <button id="cancelDownloadBtn" onclick="cancelDownload()" class="w-full mt-4 px-4 py-2 bg-gray-300 rounded-lg hover:bg-gray-400">–û—Ç–º–µ–Ω–∞</button>
    </div>
</div>

<!-- Full-screen loading overlay for PDF generation -->
<div id="pdfLoadingOverlay" class="hidden fixed inset-0 bg-white flex flex-col items-center justify-center" style="z-index: 999999;">
    <div class="text-center">
        <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-blue-500 mx-auto mb-4"></div>
        <h2 class="text-2xl font-bold text-gray-700 mb-2">–°–æ–∑–¥–∞–Ω–∏–µ PDF</h2>
        <p id="pdfLoadingText" class="text-gray-500">–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–ª–∞–π–¥–æ–≤...</p>
        <div class="w-64 bg-gray-200 rounded-full h-2 mt-4">
            <div id="pdfLoadingProgress" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
    </div>
</div>

<script>
let slides = {{ slides_data | tojson }};
let currentSlideIndex = 0;
const presentationUrl = '{{ presentation_url }}';
let generatedPresentationId = null;  // Track generated presentation

// Settings state
let presentationSettings = {
    pageOrientation: 'horizontal',
    defaultFont: 'Arial',
    defaultFontSize: 18,
    defaultTextPosition: {
        vertical: 'top',
        horizontal: 'left'
    }
};

// Get job ID for settings persistence
const urlParams = new URLSearchParams(window.location.search);
const jobId = urlParams.get('job_id') || 'default';

// Auto-save state
let saveTimer = null;
let pendingSave = false;
let lastSavedTime = null;
let isSaving = false;

// Responsive scaling state
const BASELINE_PREVIEW_WIDTH = 800; // Reference width for default font sizes
let currentScaleFactor = 1.0;
let resizeDebounceTimer = null;

// Selection preservation for auto-save
let savedSelection = null;
let activeEditorId = 'editorMainText'; // Track which editor block is active

function getActiveEditor() {
    // Return the currently focused editor block, or the last active one
    const editors = ['editorTitle', 'editorMainText', 'editorComment'];
    for (const id of editors) {
        const el = document.getElementById(id);
        if (el && document.activeElement === el) {
            activeEditorId = id;
            return el;
        }
    }
    // Return the last active or default to main text
    return document.getElementById(activeEditorId) || document.getElementById('editorMainText');
}

// Toolbar dropdown functions
function toggleToolbarDropdown(dropdownId) {
    const dropdown = document.getElementById(dropdownId);
    if (!dropdown) return;
    
    const wasHidden = dropdown.classList.contains('hidden');
    
    // Close all dropdowns first
    closeAllDropdowns();
    
    // Toggle this one
    if (wasHidden) {
        dropdown.classList.remove('hidden');
    }
}

function closeAllDropdowns() {
    const dropdowns = document.querySelectorAll('.toolbar-dropdown-content');
    dropdowns.forEach(d => d.classList.add('hidden'));
}

// Close dropdowns when clicking outside
document.addEventListener('click', function(e) {
    if (!e.target.closest('.toolbar-dropdown')) {
        closeAllDropdowns();
    }
});

// Setup image drop zone drag & drop
function setupImageDropZone() {
    const dropZone = document.getElementById('imageDropZone');
    if (!dropZone) return;
    
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('drag-over');
    });
    
    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('drag-over');
    });
    
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('drag-over');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleImageFiles(files);
        }
    });
}

function handleImageFiles(files) {
    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = function(e) {
                addImageToSlide(e.target.result, file.name);
            };
            reader.readAsDataURL(file);
        }
    }
}

function saveSelection() {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
        savedSelection = selection.getRangeAt(0);
        // Also track which editor is active
        const activeEl = document.activeElement;
        if (activeEl && ['editorTitle', 'editorMainText', 'editorComment'].includes(activeEl.id)) {
            activeEditorId = activeEl.id;
        }
    }
}

function restoreSelection() {
    if (savedSelection) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(savedSelection);
    }
}

// Initialize
let isFirstLoad = true;
let pageLoadTime = Date.now();  // Track when page loaded
const LAST_SLIDE_KEY = 'lastViewedSlide_' + jobId;  // Key for localStorage
document.addEventListener('DOMContentLoaded', async () => {
    loadSettings();
    
    // Load from backend
    await loadFromBackend();
    
    initializeSlideData();
    
    renderSlidesList();
    
    // Restore last viewed slide or default to 0
    const storedSlideIndex = localStorage.getItem(LAST_SLIDE_KEY);
    const lastSlideIndex = storedSlideIndex !== null ? parseInt(storedSlideIndex) : 0;
    const slideToLoad = Math.min(lastSlideIndex, slides.length - 1);
    loadSlide(Math.max(0, slideToLoad));
    
    isFirstLoad = false;
    
    // Check if we have a generated presentation from previous run
    if (jobId && jobId !== 'default') {
        checkForGeneratedPresentation(jobId);
    }
    
    // Add click handler to slide preview for smart click routing
    const slidePreview = document.getElementById('slidePreview');
    if (slidePreview) {
        // Use capture phase to intercept clicks before they reach targets
        slidePreview.addEventListener('click', handleSlidePreviewClick, true);
    }
    
    // Setup Tab key for list indentation in all editor blocks
    const editorBlocks = ['editorTitle', 'editorMainText', 'editorComment'];
    editorBlocks.forEach(id => {
        const editor = document.getElementById(id);
        if (editor) {
            editor.addEventListener('keydown', handleEditorKeydown);
            editor.addEventListener('focus', () => { 
                activeEditorId = id;
                updateAlignmentButtonsForActiveBlock();
            });
        }
    });
    
    // Setup drag-and-drop for slide preview
    setupPreviewDragDrop();
    
    // Setup file input handlers
    setupFileInputHandlers();
    
    // Start auto-save timer
    startAutoSave();
    
    // Setup responsive scaling
    setupResponsiveScaling();
    
    // Setup image drop zone
    setupImageDropZone();
});

function checkForGeneratedPresentation(jobId) {
    // Check if this job already generated a presentation
    fetch(`/api/job/${jobId}`)
        .then(response => response.json())
        .then(job => {
            if (job.generated_presentation_id) {
                generatedPresentationId = job.generated_presentation_id;
                // Show update button, hide create button
                document.getElementById('createBtn').classList.add('hidden');
                document.getElementById('updateBtn').classList.remove('hidden');
            }
        })
        .catch(err => console.error('Error checking job:', err));
}

function renderSlidesList() {
    const container = document.getElementById('slidesList');
    if (slides.length === 0) {
        container.innerHTML = '<div class="p-2 text-gray-500 text-sm">–ù–µ—Ç —Å–ª–∞–π–¥–æ–≤</div>';
        return;
    }
    
    // Render horizontal buttons with slide numbers
    let buttonsHtml = slides.map((slide, index) => {
        const isActive = index === currentSlideIndex ? 'active' : '';
        return `<button onclick="loadSlide(${index})" class="slide-btn ${isActive}" title="–°–ª–∞–π–¥ ${index + 1}">${index + 1}</button>`;
    }).join('');
    
    // Add "New slide" button at the end
    buttonsHtml += `<button onclick="addNewSlide()" class="slide-btn slide-btn-add" title="–î–æ–±–∞–≤–∏—Ç—å —Å–ª–∞–π–¥">+</button>`;
    
    container.innerHTML = buttonsHtml;
}

function loadSlide(index) {
    // Save current slide first (BUT NOT on first load when inputs are empty!)
    if (currentSlideIndex >= 0 && currentSlideIndex < slides.length && !isFirstLoad) {
        saveCurrentSlide();
    }

    currentSlideIndex = index;
    
    // Save last viewed slide to localStorage
    try {
        localStorage.setItem(LAST_SLIDE_KEY, index.toString());
    } catch (e) {
        console.warn('Failed to save last slide index:', e);
    }
    
    const slide = slides[index];

    document.getElementById('currentSlideNumber').textContent = index + 1;
    
    // Load content into 3 editor blocks
    const editorTitle = document.getElementById('editorTitle');
    const editorMainText = document.getElementById('editorMainText');
    const editorComment = document.getElementById('editorComment');
    
    // Handle migration from old format
    if (slide.titleText !== undefined || slide.mainTextContent !== undefined || slide.commentText !== undefined) {
        // New 3-block format
        editorTitle.innerHTML = slide.titleText || '';
        editorMainText.innerHTML = slide.mainTextContent || '';
        editorComment.innerHTML = slide.commentText || '';
    } else if (slide.content) {
        // Migration from old single content format - extract title from h1
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = slide.content;
        const h1 = tempDiv.querySelector('h1');
        if (h1) {
            editorTitle.innerHTML = h1.innerHTML;
            h1.remove();
        } else {
            editorTitle.innerHTML = '';
        }
        // Add 2 blank lines at start of main text
        let mainContent = tempDiv.innerHTML || '';
        mainContent = mainContent.replace(/^(<br\s*\/?>|<p><br><\/p>|\s)+/i, ''); // Strip existing breaks
        if (mainContent.trim()) {
            mainContent = '<br><br>' + mainContent;
        }
        editorMainText.innerHTML = mainContent;
        editorComment.innerHTML = '';
    } else if (slide.title || slide.mainText) {
        // Migration from very old format
        editorTitle.innerHTML = slide.title || '';
        // Add 2 blank lines at start of main text
        let mainContent = slide.mainText || '';
        mainContent = mainContent.replace(/^(<br\s*\/?>|<p><br><\/p>|\s)+/i, ''); // Strip existing breaks
        if (mainContent.trim()) {
            mainContent = '<br><br>' + mainContent;
        }
        editorMainText.innerHTML = mainContent;
        editorComment.innerHTML = '';
        console.log(`  Migrated from title/mainText fields`);
    } else {
        // New slide with no content
        editorTitle.innerHTML = '–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ª–∞–π–¥–∞';
        editorMainText.innerHTML = '–ù–∞—á–Ω–∏—Ç–µ –ø–µ—á–∞—Ç–∞—Ç—å...';
        editorComment.innerHTML = '';
        console.log(`  Using default content`);
    }
    
    // Sync to preview
    syncBlocksToPreview();
    
    // Load font sizes
    loadFontSizesFromSlide(slide);
    
    // Load block alignments
    applyAllBlockAlignments();
    
    // Load slide-specific settings
    if (slide.fontFamily) {
        document.getElementById('fontFamily').value = slide.fontFamily;
    }
    
    // Load background settings
    const background = slide.background || { type: 'none', color: '#FFFFFF' };
    const bgType = background.type || 'none';
    document.querySelector(`input[name="bgType"][value="${bgType}"]`).checked = true;
    
    if (bgType === 'solid') {
        document.getElementById('bgColor').value = background.color || '#FFFFFF';
        document.getElementById('solidColorPicker').classList.remove('hidden');
        document.getElementById('gradientPicker').classList.add('hidden');
        document.getElementById('imageBgPicker').classList.add('hidden');
    } else if (bgType === 'gradient' && background.gradient) {
        document.getElementById('gradientColor1').value = background.gradient.color1 || '#667eea';
        document.getElementById('gradientColor2').value = background.gradient.color2 || '#764ba2';
        document.getElementById('gradientDirection').value = background.gradient.direction || 'to right';
        document.getElementById('solidColorPicker').classList.add('hidden');
        document.getElementById('gradientPicker').classList.remove('hidden');
        document.getElementById('imageBgPicker').classList.add('hidden');
    } else if (bgType === 'image') {
        document.getElementById('solidColorPicker').classList.add('hidden');
        document.getElementById('gradientPicker').classList.add('hidden');
        document.getElementById('imageBgPicker').classList.remove('hidden');
        if (background.imageUrl) {
            const info = document.getElementById('bgImagePreview');
            if (info) info.textContent = '–§–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ';
        }
    } else {
        document.getElementById('solidColorPicker').classList.add('hidden');
        document.getElementById('gradientPicker').classList.add('hidden');
        document.getElementById('imageBgPicker').classList.add('hidden');
    }
    
    // Load text alignment settings
    const textPosition = slide.textPosition || presentationSettings.defaultTextPosition || { vertical: 'top', horizontal: 'left' };
    presentationSettings.defaultTextPosition = textPosition;
    updateAlignmentButtons(textPosition.vertical, textPosition.horizontal);

    // Ensure Google Fonts are loaded when switching slides
    changeFontFamily();

    updateSlidePreview();
    updateImagesList();
    updateTablesList();
    updateArrowsList();
    updateAccentBoxesList();
    updateTextBlocksList();
    renderSlidesList();
}

function saveCurrentSlide() {
    // Ensure defaultTextPosition exists
    if (!presentationSettings.defaultTextPosition) {
        presentationSettings.defaultTextPosition = {
            vertical: 'top',
            horizontal: 'left'
        };
    }
    
    const editorTitle = document.getElementById('editorTitle');
    const editorMainText = document.getElementById('editorMainText');
    const editorComment = document.getElementById('editorComment');
    
    slides[currentSlideIndex] = {
        ...slides[currentSlideIndex],
        titleText: editorTitle ? editorTitle.innerHTML : '',
        mainTextContent: editorMainText ? editorMainText.innerHTML : '',
        commentText: editorComment ? editorComment.innerHTML : '',
        titleFontSize: parseInt(document.getElementById('titleFontSize')?.value) || 32,
        mainTextFontSize: parseInt(document.getElementById('mainTextFontSize')?.value) || 18,
        commentFontSize: parseInt(document.getElementById('commentFontSize')?.value) || 14,
        blockAlignments: slides[currentSlideIndex].blockAlignments || {
            title: { horizontal: 'left' },
            mainText: { horizontal: 'left' },
            comment: { horizontal: 'left' }
        },
        fontFamily: document.getElementById('fontFamily').value,
        background: slides[currentSlideIndex].background || { type: 'none', color: '#FFFFFF' },
        textPosition: {
            vertical: presentationSettings.defaultTextPosition.vertical,
            horizontal: presentationSettings.defaultTextPosition.horizontal
        },
        images: slides[currentSlideIndex].images || [],
        tables: slides[currentSlideIndex].tables || [],
        arrows: slides[currentSlideIndex].arrows || [],
        accentBoxes: slides[currentSlideIndex].accentBoxes || [],
        textBlocks: slides[currentSlideIndex].textBlocks || []
    };
    
    // console.log(`SAVE FONT SIZES: title=${slides[currentSlideIndex].titleFontSize}, mainText=${slides[currentSlideIndex].mainTextFontSize}`);
    
    // All saves go to backend now
    saveToBackend();
}

function updateSlidePreview() {
    // Preview IS the editor now, so we only need to:
    // 1. Apply styles
    // 2. Apply background
    // 3. Render images
    // 4. Render tables
    
    updatePreviewStyles();
    
    // Apply background to preview
    const currentBackground = slides[currentSlideIndex]?.background || { type: 'none', color: '#FFFFFF' };
    const preview = document.getElementById('slidePreview');
    if (currentBackground.type === 'solid') {
        preview.style.backgroundImage = '';
        preview.style.background = currentBackground.color;
    } else if (currentBackground.type === 'gradient' && currentBackground.gradient) {
        const g = currentBackground.gradient;
        preview.style.backgroundImage = '';
        preview.style.background = `linear-gradient(${g.direction}, ${g.color1}, ${g.color2})`;
    } else if (currentBackground.type === 'image' && currentBackground.imageUrl) {
        preview.style.backgroundImage = `url(${currentBackground.imageUrl})`;
        preview.style.backgroundSize = 'cover';
        preview.style.backgroundPosition = 'center center';
        preview.style.backgroundColor = '';
    } else {
        preview.style.backgroundImage = '';
        preview.style.background = '#FFFFFF';
    }
    
    // Render images in layers
    renderPreviewImages();
    
    // Render tables
    renderPreviewTables();
    
    // Render arrows
    renderPreviewArrows();
    
    // Render accent boxes
    renderPreviewAccentBoxes();
    
    // Render text blocks
    renderPreviewTextBlocks();
}

function renderPreviewImages() {
    const images = slides[currentSlideIndex].images || [];
    const imagesContainer = document.getElementById('previewImages');
    
    // Clear existing images
    imagesContainer.innerHTML = '';
    
    // Deselect all images when re-rendering
    deselectAllImages();
    
    // Render all images (always on top of text)
    images.forEach(img => {
        const wrapper = createImageWrapper(img);
        imagesContainer.appendChild(wrapper);
    });
    
    // Initialize Interact.js on all new image wrappers
    setTimeout(() => {
        if (typeof interact !== 'undefined') {
            initializeImageInteractions();
        }
    }, 50);
}

// Handle file upload
function handleImageUpload(event) {
    const files = event.target.files;
    if (!files || files.length === 0) return;
    
    Array.from(files).forEach(file => {
        if (!file.type.startsWith('image/')) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            addImageToSlide(e.target.result);
        };
        reader.readAsDataURL(file);
    });
    
    // Clear input so same file can be selected again
    event.target.value = '';
}

// Add image to current slide
function addImageToSlide(imageUrl) {
    const image = {
        id: 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        url: imageUrl,
        position: { x: 50, y: 50 },
        size: { width: 200, height: 150 },
        rotation: 0,
        aspectLocked: true,
        aspectRatio: 200 / 150
    };
    
    if (!slides[currentSlideIndex].images) {
        slides[currentSlideIndex].images = [];
    }
    slides[currentSlideIndex].images.push(image);
    
    updateImagesList();
    renderPreviewImages();
    saveSlides();
}

function createImageWrapper(imageData) {
    // Create wrapper div
    const wrapper = document.createElement('div');
    wrapper.className = 'image-wrapper';
    wrapper.dataset.imageId = imageData.id;
    wrapper.style.left = `${imageData.position.x}px`;
    wrapper.style.top = `${imageData.position.y}px`;
    wrapper.style.width = `${imageData.size.width}px`;
    wrapper.style.height = `${imageData.size.height}px`;
    wrapper.style.pointerEvents = 'auto';
    
    // Apply rotation if exists
    if (imageData.rotation) {
        wrapper.style.transform = `rotate(${imageData.rotation}deg)`;
        wrapper.dataset.rotation = imageData.rotation;
    } else {
        wrapper.dataset.rotation = '0';
    }
    
    // Create image element
    const imgEl = document.createElement('img');
    imgEl.src = imageData.url;
    imgEl.onerror = function() {
        this.style.border = '2px dashed #ccc';
        this.style.background = '#f0f0f0';
        this.alt = 'Image failed to load';
    };
    wrapper.appendChild(imgEl);
    
    // Create resize handles
    const handles = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];
    handles.forEach(handlePos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${handlePos}`;
        handle.dataset.handle = handlePos;
        wrapper.appendChild(handle);
    });
    
    // Create rotation handle
    const rotateHandle = document.createElement('div');
    rotateHandle.className = 'rotate-handle';
    rotateHandle.dataset.handle = 'rotate';
    wrapper.appendChild(rotateHandle);
    
    // Create aspect ratio lock indicator
    if (imageData.aspectLocked !== false) {
        const lockIndicator = document.createElement('div');
        lockIndicator.className = 'aspect-lock-indicator';
        lockIndicator.innerHTML = 'üîí';
        lockIndicator.title = 'Aspect ratio locked';
        wrapper.appendChild(lockIndicator);
    }
    
    // Click to select
    wrapper.onclick = function(e) {
        selectImage(imageData.id);
        e.stopPropagation();
    };
    
    return wrapper;
}

function formatMainText(text) {
    // This function is now deprecated - contenteditable handles formatting directly
    // Kept for backward compatibility with old data
    if (!text) return '';
    
    // If text contains HTML tags, return as-is
    if (/<[a-z][\s\S]*>/i.test(text)) {
        return text;
    }
    
    // Otherwise, treat as plain text and preserve line breaks
    return text.replace(/\n/g, '<br>');
}

function updatePreviewStyles() {
    const fontFamily = document.getElementById('fontFamily').value;
    
    // Apply font family to ALL editor blocks
    const editorIds = ['editorTitle', 'editorMainText', 'editorComment'];
    editorIds.forEach(editorId => {
        const editor = document.getElementById(editorId);
        if (editor) {
            editor.style.fontFamily = fontFamily;
            
            // Also apply to all child elements
            const allElements = editor.querySelectorAll('*');
            allElements.forEach(el => {
                el.style.fontFamily = fontFamily;
            });
        }
    });
    
    // Apply font family to ALL preview blocks
    const previewIds = ['previewTitle', 'previewMainText', 'previewComment'];
    previewIds.forEach(previewId => {
        const preview = document.getElementById(previewId);
        if (preview) {
            preview.style.fontFamily = fontFamily;
            
            // Also apply to all child elements
            const allElements = preview.querySelectorAll('*');
            allElements.forEach(el => {
                el.style.fontFamily = fontFamily;
            });
        }
    });
    
    // Apply text alignment from presentationSettings
    const textPosition = presentationSettings.defaultTextPosition || { vertical: 'top', horizontal: 'left' };
    
    // Apply horizontal alignment to text container
    const textContainer = document.getElementById('textLayerContainer');
    if (textContainer) {
        textContainer.style.textAlign = textPosition.horizontal || 'left';
    }
}

function addNewSlide() {
    const newSlide = {
        content: '<h1>–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ª–∞–π–¥–∞</h1><p>–ù–∞—á–Ω–∏—Ç–µ –ø–µ—á–∞—Ç–∞—Ç—å...</p>',
        role: 'CONTENT',
        images: [],
        tables: [],
        arrows: [],
        accentBoxes: [],
        textBlocks: [],
        background: { type: 'none', color: '#FFFFFF' }
    };
    
    slides.push(newSlide);
    renderSlidesList();
    loadSlide(slides.length - 1);
}

function deleteCurrentSlide() {
    if (slides.length <= 1) {
        alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–ª–∞–π–¥!');
        return;
    }
    
    if (!confirm(`–£–¥–∞–ª–∏—Ç—å —Å–ª–∞–π–¥ ${currentSlideIndex + 1}?`)) {
        return;
    }
    
    slides.splice(currentSlideIndex, 1);
    currentSlideIndex = Math.max(0, currentSlideIndex - 1);
    renderSlidesList();
    loadSlide(currentSlideIndex);
}

function applyToAll() {
    // Gather current slide settings
    const currentSlide = slides[currentSlideIndex];
    const fontFamily = document.getElementById('fontFamily').value;
    
    // Ensure defaultTextPosition exists
    if (!presentationSettings.defaultTextPosition) {
        presentationSettings.defaultTextPosition = {
            vertical: 'top',
            horizontal: 'left'
        };
    }
    const textPosition = presentationSettings.defaultTextPosition;
    
    // Get current background settings
    const background = currentSlide.background || { type: 'none', color: '#FFFFFF' };
    
    // Apply to all slides (preserve content-specific items)
    slides = slides.map(slide => ({
        ...slide,                    // Keep all existing properties
        fontFamily: fontFamily,
        textPosition: {...textPosition},
        background: {...background}  // Apply background settings
        // Explicitly preserve: content, images, tables, arrows, accentBoxes
    }));
    
    // Save and update
    saveToBackend();
    updateSlidePreview();
    alert('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫–æ –≤—Å–µ–º —Å–ª–∞–π–¥–∞–º!');
}

function applyTemplateToAll() {
    const template = document.getElementById('templateSelect').value;
    slides = slides.map(slide => ({
        ...slide,
        template: template
    }));
}

async function generatePresentation(isUpdate = false) {
    // Save current slide
    saveCurrentSlide();
    
    // Show progress
    document.getElementById('progressBar').classList.remove('hidden');
    document.getElementById('progressBarFill').style.width = '20%';
    
    if (isUpdate && generatedPresentationId) {
        document.getElementById('progressText').textContent = '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏...';
    } else {
        document.getElementById('progressText').textContent = '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–ª–∞–π–¥–æ–≤...';
    }
    
    try {
        const response = await fetch('/process_slides', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                slides: slides,
                presentation_url: presentationUrl,
                existing_presentation_id: isUpdate ? generatedPresentationId : null,
                settings: presentationSettings
            })
        });
        
        document.getElementById('progressBarFill').style.width = '50%';
        document.getElementById('progressText').textContent = isUpdate ? '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏...' : '–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏...';
        
        const result = await response.json();
        
        document.getElementById('progressBarFill').style.width = '100%';
        document.getElementById('progressText').textContent = '–ì–æ—Ç–æ–≤–æ!';
        
        if (result.job_id) {
            window.location.href = `/job/${result.job_id}`;
        } else if (result.error) {
            alert('–û—à–∏–±–∫–∞: ' + result.error);
            document.getElementById('progressBar').classList.add('hidden');
        }
        
    } catch (error) {
        console.error('Error:', error);
        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ ' + (isUpdate ? '–æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏' : '—Å–æ–∑–¥–∞–Ω–∏–∏') + ' –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏: ' + error);
        document.getElementById('progressBar').classList.add('hidden');
    }
}

// Initialize slide data with default values
function initializeSlideData() {
    // Ensure defaultTextPosition exists
    if (!presentationSettings.defaultTextPosition) {
        presentationSettings.defaultTextPosition = {
            vertical: 'top',
            horizontal: 'left'
        };
    }
    
    slides = slides.map(slide => ({
        ...slide,
        fontFamily: slide.fontFamily || presentationSettings.defaultFont,
        textColor: slide.textColor || '#000000',
        textPosition: slide.textPosition || {...presentationSettings.defaultTextPosition},
        images: slide.images || [],
        tables: slide.tables || [],
        arrows: slide.arrows || [],
        accentBoxes: slide.accentBoxes || [],
        textBlocks: slide.textBlocks || []
    }));
}

// Settings persistence functions
function saveSettings() {
    presentationSettings.defaultFont = document.getElementById('fontFamily').value;
    
    try {
        localStorage.setItem(
            'presentation_settings_' + jobId,
            JSON.stringify(presentationSettings)
        );
    } catch (e) {
        console.warn('Failed to save settings to localStorage:', e);
    }
}

// Settings persistence functions
function saveSettings() {
    presentationSettings.defaultFont = document.getElementById('fontFamily').value;
    // Settings are now saved with slides to backend
}

function loadSettings() {
    // Settings are loaded from backend with slides
}

// Slides data persistence functions - ALL HANDLED BY BACKEND NOW
function saveSlides() {
    // Trigger backend save immediately
    saveToBackend();
}

function loadSlidesFromStorage() {
    // No longer used - all data comes from backend
    console.log('localStorage loading disabled - using backend only');
}

// Backend persistence functions
async function loadFromBackend() {
    if (!jobId || jobId === 'default') {
        console.warn('No job ID provided');
        return;
    }
    
    try {
        const response = await fetch(`/api/load_slides?job_id=${jobId}`);
        if (response.ok) {
            const data = await response.json();
            
            if (data.slides && data.slides.length > 0) {
                
                // Use backend data
                slides = data.slides;
                if (data.settings) {
                    presentationSettings = {
                        pageOrientation: data.settings.pageOrientation || 'horizontal',
                        defaultFont: data.settings.defaultFont || 'Arial',
                        defaultFontSize: data.settings.defaultFontSize || 18,
                        defaultTextPosition: {
                            vertical: data.settings.defaultTextPosition?.vertical || 'top',
                            horizontal: data.settings.defaultTextPosition?.horizontal || 'left'
                        }
                    };
                }
                lastSavedTime = new Date(data.last_updated);
                updateLastSavedIndicator();
            } else {
                console.log('No slides in backend, using defaults');
            }
        } else {
            console.warn('Failed to load from backend');
            showLocalStorageFallbackWarning();
        }
    } catch (error) {
        console.error('Error loading from backend:', error);
        showLocalStorageFallbackWarning();
    }
}

async function saveToBackend() {
    if (!jobId || jobId === 'default' || isSaving) {
        console.log('Skipping backend save (no job ID or already saving)');
        return;
    }
    
    // Don't save during first load - data might be stale
    if (isFirstLoad) {
        console.log('Skipping backend save (first load not complete)');
        return;
    }
    
    // Don't save within 3 seconds of page load to prevent overwriting good data
    const timeSinceLoad = Date.now() - pageLoadTime;
    if (timeSinceLoad < 3000) {
        console.log(`Skipping backend save (only ${timeSinceLoad}ms since page load)`);
        return;
    }
    
    // Save selection before operation
    saveSelection();
    
    isSaving = true;
    updateSavingIndicator(true);
    
    try {
        // Ensure current slide data is saved before sending to backend
        if (currentSlideIndex >= 0 && currentSlideIndex < slides.length) {
            const editorTitle = document.getElementById('editorTitle');
            const editorMainText = document.getElementById('editorMainText');
            const editorComment = document.getElementById('editorComment');
            
            // Save all 3 blocks to slide data
            slides[currentSlideIndex].titleText = editorTitle ? editorTitle.innerHTML : '';
            slides[currentSlideIndex].mainTextContent = editorMainText ? editorMainText.innerHTML : '';
            slides[currentSlideIndex].commentText = editorComment ? editorComment.innerHTML : '';
            
            // Save font sizes from sliders
            slides[currentSlideIndex].titleFontSize = parseInt(document.getElementById('titleFontSize')?.value) || 32;
            slides[currentSlideIndex].mainTextFontSize = parseInt(document.getElementById('mainTextFontSize')?.value) || 18;
            slides[currentSlideIndex].commentFontSize = parseInt(document.getElementById('commentFontSize')?.value) || 14;
            
            // console.log(`SAVE: Slide ${currentSlideIndex} - titleText len: ${slides[currentSlideIndex].titleText.length}, mainTextContent len: ${slides[currentSlideIndex].mainTextContent.length}`);
            // console.log(`SAVE: mainTextContent preview: ${slides[currentSlideIndex].mainTextContent.substring(0, 100)}...`);
            // console.log(`SAVE FONT SIZES: title=${slides[currentSlideIndex].titleFontSize}, mainText=${slides[currentSlideIndex].mainTextFontSize}`);
        }
        
        const response = await fetch('/api/save_slides', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                job_id: jobId,
                slides: slides,
                settings: presentationSettings,
                presentation_url: presentationUrl
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            lastSavedTime = new Date(data.timestamp);
            updateLastSavedIndicator();
            console.log(`Saved ${data.slides_count} slides to backend`);
        } else {
            const error = await response.json();
            console.error('Failed to save to backend:', error);
            showSaveError();
        }
    } catch (error) {
        console.error('Error saving to backend:', error);
        showSaveError();
    } finally {
        isSaving = false;
        updateSavingIndicator(false);
        
        // Restore selection after save completes
        setTimeout(() => {
            restoreSelection();
        }, 50);
    }
}

function triggerAutoSave() {
    pendingSave = true;
    
    if (saveTimer) {
        clearTimeout(saveTimer);
    }
    
    // Debounce: save 10 seconds after last change
    saveTimer = setTimeout(async () => {
        if (pendingSave) {
            await saveToBackend();
            pendingSave = false;
        }
    }, 10000); // 10 seconds
}

function startAutoSave() {
    // Periodic save every 30 seconds
    setInterval(async () => {
        if (slides && slides.length > 0 && !isSaving) {
            await saveToBackend();
        }
    }, 30000); // 30 seconds
}

// Responsive scaling setup
function setupResponsiveScaling() {
    const preview = document.getElementById('slidePreview');
    
    // Try modern ResizeObserver first
    if (typeof ResizeObserver !== 'undefined') {
        const resizeObserver = new ResizeObserver((entries) => {
            // Debounce the callback
            if (resizeDebounceTimer) {
                clearTimeout(resizeDebounceTimer);
            }
            
            resizeDebounceTimer = setTimeout(() => {
                for (let entry of entries) {
                    console.log('Preview resized to:', entry.contentRect.width, 'x', entry.contentRect.height);
                    updatePreviewStyles();
                }
            }, 150); // 150ms debounce
        });
        
        resizeObserver.observe(preview);
        console.log('ResizeObserver initialized for responsive scaling');
    } else {
        // Fallback to window resize event for older browsers
        console.log('ResizeObserver not available, using window resize fallback');
        window.addEventListener('resize', () => {
            if (resizeDebounceTimer) {
                clearTimeout(resizeDebounceTimer);
            }
            
            resizeDebounceTimer = setTimeout(() => {
                updatePreviewStyles();
            }, 200); // 200ms debounce for window resize
        });
    }
    
    // Initial calculation
    setTimeout(() => {
        updatePreviewStyles();
    }, 100);
}

function manualSave() {
    if (saveTimer) {
        clearTimeout(saveTimer);
    }
    saveToBackend();
}

// Page orientation control
function applyPageOrientation() {
    const orientation = document.getElementById('pageOrientation').value;
    const preview = document.getElementById('slidePreview');
    
    // Get old dimensions before changing
    const oldWidth = preview.offsetWidth;
    const oldHeight = preview.offsetHeight;
    
    presentationSettings.pageOrientation = orientation;
    
    // Define aspect ratios
    const aspectRatios = {
        '16:9': '16/9',
        '4:3': '4/3',
        '1:1': '1/1',
        '9:16': '9/16',
        // Legacy support
        'horizontal': '16/9',
        'vertical': '9/16'
    };
    
    const ratio = aspectRatios[orientation] || aspectRatios['16:9'];
    
    // Reset all styles first
    preview.style.width = '';
    preview.style.height = '';
    preview.style.maxWidth = '';
    preview.style.maxHeight = '';
    
    // Set the aspect ratio
    preview.style.aspectRatio = ratio;
    
    // For horizontal formats (16:9, 4:3), use full width
    if (orientation === '16:9' || orientation === '4:3' || orientation === 'horizontal') {
        preview.style.width = '100%';
        preview.style.height = 'auto';
    }
    // For square (1:1), constrain by height
    else if (orientation === '1:1') {
        preview.style.width = 'auto';
        preview.style.height = '100%';
        preview.style.maxWidth = '100%';
    }
    // For vertical (9:16), constrain by height
    else if (orientation === '9:16' || orientation === 'vertical') {
        preview.style.width = 'auto';
        preview.style.height = '100%';
        preview.style.maxWidth = '100%';
    }
    
    saveSettings();
    
    // After layout settles, adjust element positions to fit new bounds
    setTimeout(() => {
        const newWidth = preview.offsetWidth;
        const newHeight = preview.offsetHeight;
        
        if (oldWidth > 0 && oldHeight > 0 && newWidth > 0 && newHeight > 0) {
            adjustElementsToNewBounds(oldWidth, oldHeight, newWidth, newHeight);
        }
        
        updatePreviewStyles();
        renderPreviewImages();
        renderPreviewTables();
        renderPreviewAccentBoxes();
    }, 100); // Small delay to allow layout to settle
}

// Adjust images and accent boxes to fit within new preview bounds
function adjustElementsToNewBounds(oldWidth, oldHeight, newWidth, newHeight) {
    const slide = slides[currentSlideIndex];
    if (!slide) return;
    
    const scaleX = newWidth / oldWidth;
    const scaleY = newHeight / oldHeight;
    
    // Adjust images
    if (slide.images && slide.images.length > 0) {
        slide.images.forEach(img => {
            // Scale position
            img.position.x = Math.round(img.position.x * scaleX);
            img.position.y = Math.round(img.position.y * scaleY);
            
            // Scale size
            img.size.width = Math.round(img.size.width * scaleX);
            img.size.height = Math.round(img.size.height * scaleY);
            
            // Ensure within bounds
            img.position.x = Math.max(0, Math.min(img.position.x, newWidth - 50));
            img.position.y = Math.max(0, Math.min(img.position.y, newHeight - 50));
        });
    }
    
    // Adjust accent boxes
    if (slide.accentBoxes && slide.accentBoxes.length > 0) {
        slide.accentBoxes.forEach(box => {
            // Scale position
            box.position.x = Math.round(box.position.x * scaleX);
            box.position.y = Math.round(box.position.y * scaleY);
            
            // Scale size
            box.size.width = Math.round(box.size.width * scaleX);
            box.size.height = Math.round(box.size.height * scaleY);
            
            // Ensure within bounds
            box.position.x = Math.max(0, Math.min(box.position.x, newWidth - 50));
            box.position.y = Math.max(0, Math.min(box.position.y, newHeight - 30));
        });
    }
    
    // Adjust tables
    if (slide.tables && slide.tables.length > 0) {
        slide.tables.forEach(table => {
            // Scale position
            table.position.x = Math.round(table.position.x * scaleX);
            table.position.y = Math.round(table.position.y * scaleY);
            
            // Scale column widths
            if (table.columnWidths) {
                table.columnWidths = table.columnWidths.map(w => Math.max(30, Math.round(w * scaleX)));
            }
            
            // Ensure within bounds
            table.position.x = Math.max(0, Math.min(table.position.x, newWidth - 100));
            table.position.y = Math.max(0, Math.min(table.position.y, newHeight - 50));
        });
    }
    
    debouncedSave();
}

// Font selection control
function changeFontFamily() {
    const select = document.getElementById('fontFamily');
    const fontFamily = select.value;
    presentationSettings.defaultFont = fontFamily;

    const selectedOption = select.selectedOptions && select.selectedOptions[0];
    const isGoogleFont = selectedOption && selectedOption.dataset && selectedOption.dataset.google === 'true';

    if (isGoogleFont) {
        // Load Google Font via WebFont Loader if available, else fallback to CSS link
        if (window.WebFont && window.WebFont.load) {
            WebFont.load({ google: { families: [fontFamily] } });
        } else {
            const familyParam = fontFamily.replace(/ /g, '+');
            const href = `https://fonts.googleapis.com/css2?family=${familyParam}:wght@400;700&display=swap`;
            if (!document.querySelector(`link[data-font="${familyParam}"]`)) {
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = href;
                link.setAttribute('data-font', familyParam);
                document.head.appendChild(link);
            }
        }
    }
    updatePreviewStyles();
    saveSettings();
}

// Update alignment button styles
function updateAlignmentButtons(vertical, horizontal) {
    // Update vertical buttons
    ['posVertTop', 'posVertCenter', 'posVertBottom'].forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.classList.remove('bg-blue-100', 'border-blue-500');
            btn.classList.add('hover:bg-gray-50');
        }
    });
    if (vertical) {
        const vBtnId = 'posVert' + vertical.charAt(0).toUpperCase() + vertical.slice(1);
        const vBtn = document.getElementById(vBtnId);
        if (vBtn) {
            vBtn.classList.add('bg-blue-100', 'border-blue-500');
            vBtn.classList.remove('hover:bg-gray-50');
        }
    }
    
    // Update horizontal buttons
    ['posHorizLeft', 'posHorizCenter', 'posHorizRight', 'posHorizJustify'].forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.classList.remove('bg-blue-100', 'border-blue-500');
            btn.classList.add('hover:bg-gray-50');
        }
    });
    if (horizontal) {
        const hBtnId = horizontal === 'left' ? 'posHorizLeft' : 
                       horizontal === 'center' ? 'posHorizCenter' : 
                       horizontal === 'justify' ? 'posHorizJustify' : 'posHorizRight';
        const hBtn = document.getElementById(hBtnId);
        if (hBtn) {
            hBtn.classList.add('bg-blue-100', 'border-blue-500');
            hBtn.classList.remove('hover:bg-gray-50');
        }
    }
}

// Text positioning control - now works per block
function changeTextPosition(vertical, horizontal) {
    // Ensure defaultTextPosition exists
    if (!presentationSettings.defaultTextPosition) {
        presentationSettings.defaultTextPosition = { vertical: 'top', horizontal: 'left' };
    }
    
    // Get active editor block
    const activeEditor = getActiveEditor();
    const blockType = getBlockTypeFromEditor(activeEditor);
    
    // Initialize block alignments if not exists
    if (!slides[currentSlideIndex].blockAlignments) {
        slides[currentSlideIndex].blockAlignments = {
            title: { horizontal: 'left' },
            mainText: { horizontal: 'left' },
            comment: { horizontal: 'left' }
        };
    }
    
    // Handle horizontal alignment - apply to active block
    if (horizontal !== null && blockType) {
        slides[currentSlideIndex].blockAlignments[blockType].horizontal = horizontal;
        
        // Apply to editor block
        if (activeEditor) {
            activeEditor.style.textAlign = horizontal;
        }
        
        // Apply to corresponding preview element
        applyBlockAlignmentToPreview(blockType, horizontal);
    }
    
    // Handle vertical alignment (applies to entire text container)
    if (vertical !== null) {
        presentationSettings.defaultTextPosition.vertical = vertical;
        applyVerticalAlignment(vertical);
    }
    
    // Update button styles
    updateAlignmentButtons(
        presentationSettings.defaultTextPosition.vertical,
        horizontal || presentationSettings.defaultTextPosition.horizontal
    );
    
    saveCurrentSlide();
}

// Get block type from editor element
function getBlockTypeFromEditor(editor) {
    if (!editor) return null;
    if (editor.id === 'editorTitle') return 'title';
    if (editor.id === 'editorMainText') return 'mainText';
    if (editor.id === 'editorComment') return 'comment';
    return null;
}

// Apply alignment to a specific preview block
function applyBlockAlignmentToPreview(blockType, horizontal) {
    const previewIds = {
        'title': 'previewTitle',
        'mainText': 'previewMainText',
        'comment': 'previewComment'
    };
    
    const preview = document.getElementById(previewIds[blockType]);
    if (preview) {
        preview.style.textAlign = horizontal;
    }
}

// Apply vertical alignment to text container
function applyVerticalAlignment(vertical) {
    const container = document.getElementById('textLayerContainer');
    if (!container) return;
    
    const vAlignMap = {
        'top': 'flex-start',
        'center': 'center',
        'bottom': 'flex-end'
    };
    
    container.style.justifyContent = vAlignMap[vertical] || 'flex-start';
}

// Apply all block alignments when loading slide
function applyAllBlockAlignments() {
    const slide = slides[currentSlideIndex];
    if (!slide) return;
    
    const alignments = slide.blockAlignments || {
        title: { horizontal: 'left' },
        mainText: { horizontal: 'left' },
        comment: { horizontal: 'left' }
    };
    
    // Apply to editors
    const editorTitle = document.getElementById('editorTitle');
    const editorMainText = document.getElementById('editorMainText');
    const editorComment = document.getElementById('editorComment');
    
    if (editorTitle) editorTitle.style.textAlign = alignments.title.horizontal;
    if (editorMainText) editorMainText.style.textAlign = alignments.mainText.horizontal;
    if (editorComment) editorComment.style.textAlign = alignments.comment.horizontal;
    
    // Apply to preview
    const previewTitle = document.getElementById('previewTitle');
    const previewMainText = document.getElementById('previewMainText');
    const previewComment = document.getElementById('previewComment');
    
    if (previewTitle) previewTitle.style.textAlign = alignments.title.horizontal;
    if (previewMainText) previewMainText.style.textAlign = alignments.mainText.horizontal;
    if (previewComment) previewComment.style.textAlign = alignments.comment.horizontal;
    
    // Apply vertical alignment
    const textPosition = slide.textPosition || { vertical: 'top' };
    applyVerticalAlignment(textPosition.vertical);
}

// Update alignment buttons to show current block's alignment
function updateAlignmentButtonsForActiveBlock() {
    const slide = slides[currentSlideIndex];
    if (!slide) return;
    
    const blockType = getBlockTypeFromEditor(getActiveEditor());
    if (!blockType) return;
    
    const alignments = slide.blockAlignments || {
        title: { horizontal: 'left' },
        mainText: { horizontal: 'left' },
        comment: { horizontal: 'left' }
    };
    
    const horizontal = alignments[blockType]?.horizontal || 'left';
    const vertical = slide.textPosition?.vertical || 'top';
    
    updateAlignmentButtons(vertical, horizontal);
}

// Background control
function changeBackgroundType(type) {
    document.getElementById('solidColorPicker').classList.toggle('hidden', type !== 'solid');
    document.getElementById('gradientPicker').classList.toggle('hidden', type !== 'gradient');
    document.getElementById('imageBgPicker').classList.toggle('hidden', type !== 'image');
    updateBackground();
}

function updateBackground() {
    const bgType = document.querySelector('input[name="bgType"]:checked').value;
    const preview = document.getElementById('slidePreview');
    
    let background = { type: bgType };
    
    if (bgType === 'none') {
        preview.style.backgroundImage = '';
        preview.style.background = '#FFFFFF';
        background.color = '#FFFFFF';
    } else if (bgType === 'solid') {
        const color = document.getElementById('bgColor').value;
        preview.style.backgroundImage = '';
        preview.style.background = color;
        background.color = color;
    } else if (bgType === 'gradient') {
        const c1 = document.getElementById('gradientColor1').value;
        const c2 = document.getElementById('gradientColor2').value;
        const dir = document.getElementById('gradientDirection').value;
        preview.style.backgroundImage = '';
        preview.style.background = `linear-gradient(${dir}, ${c1}, ${c2})`;
        background.gradient = { color1: c1, color2: c2, direction: dir };
        background.color = c1;
    } else if (bgType === 'image') {
        const currentBg = slides[currentSlideIndex].background || {};
        const imageUrl = currentBg.imageUrl || background.imageUrl;
        if (imageUrl) {
            preview.style.backgroundImage = `url(${imageUrl})`;
            preview.style.backgroundSize = 'cover';
            preview.style.backgroundPosition = 'center center';
            preview.style.backgroundColor = '';
            background.imageUrl = imageUrl;
        } else {
            preview.style.backgroundImage = '';
            preview.style.background = '#FFFFFF';
            background.color = '#FFFFFF';
        }
    }
    
    // Do NOT save huge background images into localStorage to avoid QuotaExceededError
    try {
        if (bgType !== 'image') {
            slides[currentSlideIndex].background = background;
            saveSlides();
        } else {
            slides[currentSlideIndex].background = background;
        }
    } catch (e) {
        console.warn('Failed to persist background settings:', e);
        slides[currentSlideIndex].background = background;
    }
}

function handleBackgroundImageUpload(event) {
    const file = event.target.files && event.target.files[0];
    if (!file || !file.type.startsWith('image/')) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        const dataUrl = e.target.result;
        
        // Only store background image in slides, do not push to localStorage directly (too big)
        slides[currentSlideIndex].background = {
            type: 'image',
            imageUrl: dataUrl
        };
        
        const preview = document.getElementById('slidePreview');
        preview.style.backgroundImage = `url(${dataUrl})`;
        preview.style.backgroundSize = 'cover';
        preview.style.backgroundPosition = 'center center';
        preview.style.backgroundColor = '';
        
        const info = document.getElementById('bgImagePreview');
        if (info) {
            info.textContent = '–§–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ';
        }
        
        try {
            // Try lightweight save of metadata only (without image) to avoid quota issues
            const originalBg = slides[currentSlideIndex].background;
            slides[currentSlideIndex].background = { type: 'image' };
            saveSlides();
            slides[currentSlideIndex].background = originalBg;
        } catch (e2) {
            console.warn('Skipping localStorage save for background image (too large):', e2);
        }
    };
    reader.readAsDataURL(file);
    
    event.target.value = '';
}

// Text formatting functions for contenteditable editor
function formatText(command) {
    // Restore selection before applying format
    restoreSelection();
    
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    // Check if we're in a table cell
    const range = selection.getRangeAt(0);
    let node = range.commonAncestorContainer;
    let tableCell = null;
    
    while (node && node.nodeType !== Node.DOCUMENT_NODE) {
        if (node.tagName === 'TH' || node.tagName === 'TD') {
            tableCell = node;
            break;
        }
        node = node.parentNode;
    }
    
    if (tableCell) {
        // We're in a table cell - format works directly
        document.execCommand(command, false, null);
        syncCellToData(tableCell);
    } else {
        // Normal editor content
        const editor = getActiveEditor();
        editor.focus();
        document.execCommand(command, false, null);
        syncContentToData();
    }
}

// Format text in a specific editor
function formatTextInEditor(editorId, command) {
    const editor = document.getElementById(editorId);
    if (!editor) return;
    
    // Focus the editor first
    editor.focus();
    
    // Apply the formatting command
    document.execCommand(command, false, null);
    
    // Sync to preview
    syncBlocksToPreview();
}

// Apply text color to a specific editor
function applyTextColorToEditor(editorId, color) {
    const editor = document.getElementById(editorId);
    if (!editor) return;
    
    // Restore any saved selection first
    if (savedSelection) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(savedSelection);
    }
    
    // Focus the editor
    editor.focus();
    
    // Check if there's any selection
    const selection = window.getSelection();
    if (selection.rangeCount === 0 || selection.isCollapsed) {
        // No selection - apply to the whole editor content
        const range = document.createRange();
        range.selectNodeContents(editor);
        selection.removeAllRanges();
        selection.addRange(range);
    }
    
    // Apply color
    document.execCommand('foreColor', false, color);
    
    // Sync to preview
    syncBlocksToPreview();
}

// Clear formatting in a specific editor
function clearFormattingInEditor(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return;
    
    // Focus the editor
    editor.focus();
    
    // Remove formatting
    document.execCommand('removeFormat', false, null);
    
    // Sync to preview
    syncBlocksToPreview();
}

// Apply list style to a specific editor
function applyListStyleToEditor(editorId, listType, listStyle) {
    const editor = document.getElementById(editorId);
    if (!editor) return;
    
    // Focus the editor
    editor.focus();
    
    if (listStyle === 'remove') {
        // Remove list formatting
        const selection = window.getSelection();
        if (!selection.rangeCount) return;
        
        const range = selection.getRangeAt(0);
        let node = range.commonAncestorContainer;
        
        while (node && node !== editor) {
            if (node.tagName === 'UL' || node.tagName === 'OL') {
                const command = node.tagName === 'UL' ? 'insertUnorderedList' : 'insertOrderedList';
                document.execCommand(command, false, null);
                break;
            }
            node = node.parentNode;
        }
    } else {
        // Apply list
        const command = listType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
        document.execCommand(command, false, null);
        
        // Apply style
        setTimeout(() => {
            const selection = window.getSelection();
            if (!selection.anchorNode) return;
            
            let node = selection.anchorNode;
            while (node && node !== editor) {
                if (node.tagName === 'UL' || node.tagName === 'OL') {
                    node.style.listStyleType = listStyle;
                    break;
                }
                node = node.parentNode;
            }
            syncBlocksToPreview();
        }, 10);
    }
    
    // Sync to preview
    syncBlocksToPreview();
}

// Selection preservation - using the version from auto-save feature above (line 1168)

// Apply text color to selected text
function applyTextColor() {
    const color = document.getElementById('selectionTextColor').value;
    
    // Restore selection before applying
    restoreSelection();
    
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    // Focus editor to ensure execCommand works
    const editor = getActiveEditor();
    
    // Check if we're in a table cell
    const range = selection.getRangeAt(0);
    let node = range.commonAncestorContainer;
    let tableCell = null;
    
    while (node && node.nodeType !== Node.DOCUMENT_NODE) {
        if (node.tagName === 'TH' || node.tagName === 'TD') {
            tableCell = node;
            break;
        }
        node = node.parentNode;
    }
    
    // Apply color to selected text using foreColor command
    document.execCommand('foreColor', false, color);
    
    if (tableCell) {
        syncCellToData(tableCell);
    } else {
        syncContentToData();
    }
}

// Toggle list - only selected text becomes list item
function toggleList(listType) {
    const editor = getActiveEditor();
    editor.focus();
    
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    
    // Check if we're already in a list
    let node = range.commonAncestorContainer;
    while (node && node !== editor) {
        if (node.tagName === 'UL' || node.tagName === 'OL') {
            // Already in list - use execCommand to toggle off
            const command = listType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
            document.execCommand(command, false, null);
            syncContentToData();
            return;
        }
        node = node.parentNode;
    }
    
    // Not in a list - check if there's selected text
    if (!range.collapsed) {
        // Text is selected - wrap only selected text in list
        const selectedText = range.toString().trim();
        
        if (selectedText) {
            // Split by newlines to create multiple list items
            const lines = selectedText.split('\n').filter(line => line.trim());
            
            // Create list HTML
            const listTag = listType === 'ul' ? 'ul' : 'ol';
            let listHTML = `<${listTag}>`;
            
            if (lines.length > 1) {
                lines.forEach(line => {
                    listHTML += `<li>${line.trim()}</li>`;
                });
            } else {
                listHTML += `<li>${selectedText}</li>`;
            }
            listHTML += `</${listTag}>`;
            
            // Delete selected content and insert list
            document.execCommand('insertHTML', false, listHTML);
        }
    } else {
        // No selection - use standard execCommand for current line
        const command = listType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
        document.execCommand(command, false, null);
    }
    
    syncContentToData();
}

// Apply list with specific style from dropdown
function applyListStyle(listType) {
    const editor = getActiveEditor();
    editor.focus();
    
    // Get selected style
    const styleDropdown = listType === 'ul' 
        ? document.getElementById('bulletListStyle')
        : document.getElementById('numberListStyle');
    const listStyle = styleDropdown.value;
    
    if (!listStyle) return;
    
    const selection = window.getSelection();
    if (!selection.rangeCount) {
        styleDropdown.selectedIndex = 0;
        return;
    }
    
    const range = selection.getRangeAt(0);
    
    // Handle "remove" option - remove list formatting
    if (listStyle === 'remove') {
        removeListFormatting();
        styleDropdown.selectedIndex = 0;
        return;
    }
    
    // Check if we're already in a list
    let node = range.commonAncestorContainer;
    let existingList = null;
    
    while (node && node !== editor) {
        if (node.tagName === 'UL' || node.tagName === 'OL') {
            existingList = node;
            break;
        }
        node = node.parentNode;
    }
    
    if (existingList) {
        // Already in a list
        const currentType = existingList.tagName.toLowerCase();
        const newType = listType;
        
        if (currentType !== newType) {
            // Convert list type using execCommand (toggle off current, toggle on new)
            // First toggle off current
            const offCommand = currentType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
            document.execCommand(offCommand, false, null);
            // Then toggle on new
            const onCommand = newType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
            document.execCommand(onCommand, false, null);
            
            // Apply style after conversion
            setTimeout(() => {
                let node = selection.anchorNode;
                while (node && node !== editor) {
                    if (node.tagName === 'UL' || node.tagName === 'OL') {
                        node.style.listStyleType = listStyle;
                        break;
                    }
                    node = node.parentNode;
                }
                syncContentToData();
            }, 10);
        } else {
            // Same type - just update style
            existingList.style.listStyleType = listStyle;
            syncContentToData();
        }
    } else if (!range.collapsed) {
        // Text is selected - wrap only selected text in list
        const selectedText = range.toString().trim();
        
        if (selectedText) {
            const lines = selectedText.split('\n').filter(line => line.trim());
            const listTag = listType === 'ul' ? 'ul' : 'ol';
            let listHTML = `<${listTag} style="list-style-type: ${listStyle};">`;
            
            if (lines.length > 1) {
                lines.forEach(line => {
                    listHTML += `<li>${line.trim()}</li>`;
                });
            } else {
                listHTML += `<li>${selectedText}</li>`;
            }
            listHTML += `</${listTag}>`;
            
            document.execCommand('insertHTML', false, listHTML);
            syncContentToData();
        }
    } else {
        // No selection, not in list - create new list
        const command = listType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
        document.execCommand(command, false, null);
        
        // Find the created list and apply style
        setTimeout(() => {
            let node = selection.anchorNode;
            while (node && node !== editor) {
                if (node.tagName === 'UL' || node.tagName === 'OL') {
                    node.style.listStyleType = listStyle;
                    break;
                }
                node = node.parentNode;
            }
            syncContentToData();
        }, 10);
    }
    
    // Reset dropdown to placeholder
    styleDropdown.selectedIndex = 0;
}

// Remove list formatting from current position
function removeListFormatting() {
    const editor = getActiveEditor();
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    let node = range.commonAncestorContainer;
    
    while (node && node !== editor) {
        if (node.tagName === 'UL') {
            document.execCommand('insertUnorderedList', false, null);
            syncContentToData();
            return;
        }
        if (node.tagName === 'OL') {
            document.execCommand('insertOrderedList', false, null);
            syncContentToData();
            return;
        }
        node = node.parentNode;
    }
}

// Clear all formatting including lists
function clearAllFormatting() {
    const editor = getActiveEditor();
    editor.focus();
    
    // First remove list if we're in one
    removeListFormatting();
    
    // Then remove other formatting
    document.execCommand('removeFormat', false, null);
    
    syncContentToData();
}

// Handle Tab key for list indentation
function handleEditorKeydown(e) {
    if (e.key === 'Tab') {
        e.preventDefault();
        
        const editor = getActiveEditor();
        const selection = window.getSelection();
        if (!selection.rangeCount) return;
        
        const range = selection.getRangeAt(0);
        let node = range.commonAncestorContainer;
        
        // Check if we're inside a list
        let listItem = null;
        while (node && node !== editor) {
            if (node.tagName === 'LI') {
                listItem = node;
                break;
            }
            node = node.parentNode;
        }
        
        if (listItem) {
            // Inside a list - indent or outdent
            if (e.shiftKey) {
                // Shift+Tab - outdent
                document.execCommand('outdent', false, null);
            } else {
                // Tab - indent
                document.execCommand('indent', false, null);
            }
        } else {
            // Not in a list - just insert tab spaces
            document.execCommand('insertText', false, '    ');
        }
        
        syncContentToData();
    }
}

// Indent list item (increase nesting level)
function indentList() {
    const editor = getActiveEditor();
    editor.focus();
    document.execCommand('indent', false, null);
    syncContentToData();
}

// Outdent list item (decrease nesting level)
function outdentList() {
    const editor = getActiveEditor();
    editor.focus();
    document.execCommand('outdent', false, null);
    syncContentToData();
}

// Apply format from dropdown (like in Word) - uses execCommand for Ctrl+Z support
function applyFormat() {
    const formatValue = document.getElementById('formatSelector').value;
    const editor = getActiveEditor();
    editor.focus();
    
    // Use formatBlock command - this supports Ctrl+Z properly
    document.execCommand('formatBlock', false, formatValue);
    
    // Update styles and save
    setTimeout(() => {
        updatePreviewStyles();
        syncContentToData();
        updateFormatSelector();
    }, 10);
}

// Apply heading level to selected text/paragraph (LEGACY - kept for compatibility)
function applyHeading() {
    // This is now handled by applyFormat()
    applyFormat();
}



// Sync 3 editor blocks to preview and data
function syncBlocksToPreview() {
    const editorTitle = document.getElementById('editorTitle');
    const editorMainText = document.getElementById('editorMainText');
    const editorComment = document.getElementById('editorComment');
    
    const previewTitle = document.getElementById('previewTitle');
    const previewMainText = document.getElementById('previewMainText');
    const previewComment = document.getElementById('previewComment');
    
    // Sync content to preview
    if (previewTitle && editorTitle) {
        previewTitle.innerHTML = editorTitle.innerHTML || '';
    }
    if (previewMainText && editorMainText) {
        previewMainText.innerHTML = editorMainText.innerHTML || '';
    }
    if (previewComment && editorComment) {
        previewComment.innerHTML = editorComment.innerHTML || '';
    }
    
    // Apply font sizes to preview from sliders
    applyFontSizesToPreview();
    
    // Apply alignments to preview
    applyAllBlockAlignments();
    
    // Save to slide data
    if (slides[currentSlideIndex]) {
        slides[currentSlideIndex].titleText = editorTitle ? editorTitle.innerHTML : '';
        slides[currentSlideIndex].mainTextContent = editorMainText ? editorMainText.innerHTML : '';
        slides[currentSlideIndex].commentText = editorComment ? editorComment.innerHTML : '';
        
        // NOTE: Font sizes are NOT saved here to avoid overwriting during slide load
        // Font sizes are saved in applyBlockFontSize() when user changes the slider
        
        // Trigger auto-save
        if (typeof triggerAutoSave === 'function') {
            triggerAutoSave();
        }
    }
}

// Apply font size to a specific block
function applyBlockFontSize(blockType, size) {
    const sizeInt = parseInt(size);
    
    // Update display value
    const valueEl = document.getElementById(blockType + 'FontSizeValue');
    if (valueEl) {
        valueEl.textContent = sizeInt + 'px';
    }
    
    // Map block type to element IDs
    const editorIds = {
        'title': 'editorTitle',
        'mainText': 'editorMainText',
        'comment': 'editorComment'
    };
    const previewIds = {
        'title': 'previewTitle',
        'mainText': 'previewMainText',
        'comment': 'previewComment'
    };
    
    // Apply to editor block
    const editor = document.getElementById(editorIds[blockType]);
    if (editor) {
        editor.style.fontSize = sizeInt + 'px';
        // Don't override min-height for mainText as it uses flex layout
    }
    
    // Apply to preview
    const preview = document.getElementById(previewIds[blockType]);
    if (preview) {
        preview.style.fontSize = sizeInt + 'px';
    }
    
    // Save to slide data
    if (slides[currentSlideIndex]) {
        slides[currentSlideIndex][blockType + 'FontSize'] = sizeInt;
        if (typeof triggerAutoSave === 'function') {
            triggerAutoSave();
        }
    }
}

// Apply all font sizes to preview elements
function applyFontSizesToPreview() {
    const slide = slides[currentSlideIndex];
    if (!slide) return;
    
    const titleSize = slide.titleFontSize || 32;
    const mainTextSize = slide.mainTextFontSize || 18;
    const commentSize = slide.commentFontSize || 14;
    
    // Apply to preview
    const previewTitle = document.getElementById('previewTitle');
    const previewMainText = document.getElementById('previewMainText');
    const previewComment = document.getElementById('previewComment');
    
    if (previewTitle) previewTitle.style.fontSize = titleSize + 'px';
    if (previewMainText) previewMainText.style.fontSize = mainTextSize + 'px';
    if (previewComment) previewComment.style.fontSize = commentSize + 'px';
    
    // Apply to editors
    const editorTitle = document.getElementById('editorTitle');
    const editorMainText = document.getElementById('editorMainText');
    const editorComment = document.getElementById('editorComment');
    
    if (editorTitle) editorTitle.style.fontSize = titleSize + 'px';
    if (editorMainText) editorMainText.style.fontSize = mainTextSize + 'px';
    if (editorComment) editorComment.style.fontSize = commentSize + 'px';
}

// Load font sizes from slide data and update sliders
function loadFontSizesFromSlide(slide) {
    const titleSize = slide.titleFontSize || 32;
    const mainTextSize = slide.mainTextFontSize || 18;
    const commentSize = slide.commentFontSize || 14;
    
    // console.log(`LOAD FONT SIZES: title=${titleSize}, mainText=${mainTextSize}, comment=${commentSize}`);
    
    // Update sliders
    const titleSlider = document.getElementById('titleFontSize');
    const mainTextSlider = document.getElementById('mainTextFontSize');
    const commentSlider = document.getElementById('commentFontSize');
    
    if (titleSlider) {
        titleSlider.value = titleSize;
        document.getElementById('titleFontSizeValue').textContent = titleSize + 'px';
    }
    if (mainTextSlider) {
        mainTextSlider.value = mainTextSize;
        document.getElementById('mainTextFontSizeValue').textContent = mainTextSize + 'px';
    }
    if (commentSlider) {
        commentSlider.value = commentSize;
        document.getElementById('commentFontSizeValue').textContent = commentSize + 'px';
    }
    
    // Apply to elements
    applyFontSizesToPreview();
}

// Legacy function - keep for compatibility
function syncContentToData() {
    syncBlocksToPreview();
}

// Handle keyboard shortcuts
document.addEventListener('DOMContentLoaded', function() {
    // Setup keyboard shortcuts for all editor blocks
    const editorIds = ['editorTitle', 'editorMainText', 'editorComment'];
    editorIds.forEach(editorId => {
        const editor = document.getElementById(editorId);
        if (editor) {
            // Keyboard shortcuts
            editor.addEventListener('keydown', function(e) {
                // Ctrl+B for bold
                if (e.ctrlKey && e.key === 'b') {
                    e.preventDefault();
                    formatText('bold');
                }
                // Ctrl+I for italic
                else if (e.ctrlKey && e.key === 'i') {
                    e.preventDefault();
                    formatText('italic');
                }
                // Ctrl+U for underline
                else if (e.ctrlKey && e.key === 'u') {
                    e.preventDefault();
                    formatText('underline');
                }
            });
            
            // Update format selector on cursor movement AND selection change
            editor.addEventListener('click', updateFormatSelector);
            editor.addEventListener('keyup', updateFormatSelector);
            editor.addEventListener('mouseup', updateFormatSelector);
        }
    });
    
    // Also listen to selectionchange event for immediate detection
    document.addEventListener('selectionchange', function() {
        const selection = window.getSelection();
        // Only update if selection is within one of our editors
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const container = range.commonAncestorContainer;
            const editors = ['editorTitle', 'editorMainText', 'editorComment'];
            for (const id of editors) {
                const editor = document.getElementById(id);
                if (editor && editor.contains(container)) {
                    updateFormatSelector();
                    break;
                }
            }
        }
    });
});

// Update format dropdown to show current block type
function updateFormatSelector() {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const editor = getActiveEditor();
    let node = selection.anchorNode;
    
    // If we have a selection (not just cursor), check the start of selection
    const range = selection.getRangeAt(0);
    if (!range.collapsed) {
        // Text is selected - use the node at selection start
        node = range.startContainer;
    }
    
    // Walk up the tree to find the block element
    while (node && node !== editor) {
        if (node.nodeType === Node.ELEMENT_NODE) {
            const tagName = node.tagName;
            if (tagName === 'H1' || tagName === 'H2' || tagName === 'H3' || tagName === 'H4' || tagName === 'P') {
                const dropdown = document.getElementById('formatSelector');
                if (dropdown) {
                    dropdown.value = tagName.toLowerCase();
                }
                return;
            }
        }
        node = node.parentNode;
    }
    
    // Default to 'p' if no match
    const dropdown = document.getElementById('formatSelector');
    if (dropdown) {
        dropdown.value = 'p';
    }
}

// LEGACY: Keep old name for compatibility
function updateHeadingSelector() {
    updateFormatSelector();
}

// Update font size slider to show current text size
function updateFontSizeSlider(element) {
    if (!element) return;
    
    // Get computed font size
    const computedStyle = window.getComputedStyle(element);
    const fontSize = parseInt(computedStyle.fontSize);
    
    if (fontSize) {
        const slider = document.getElementById('fontSize');
        const display = document.getElementById('fontSizeValue');
        if (slider && display) {
            slider.value = fontSize;
            display.textContent = fontSize;
            // Brief highlight to show detection
            slider.style.accentColor = '#3B82F6';
            setTimeout(() => {
                slider.style.accentColor = '';
            }, 200);
        }
    }
}

// Apply font size to selected text
function applyFontSizeToSelection() {
    const fontSize = document.getElementById('fontSize').value;
    
    // Restore selection before applying
    restoreSelection();
    
    const selection = window.getSelection();
    
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    
    // Check if we're in a table cell
    let node = range.commonAncestorContainer;
    let tableCell = null;
    let container = null;
    
    while (node && node.nodeType !== Node.DOCUMENT_NODE) {
        if (node.tagName === 'TH' || node.tagName === 'TD') {
            tableCell = node;
            container = tableCell;
            break;
        }
        if (node.id === 'editorTitle' || node.id === 'editorMainText' || node.id === 'editorComment') {
            container = node;
            break;
        }
        node = node.parentNode;
    }
    
    if (!container) return;
    
    // If text is selected, apply size
    if (!range.collapsed) {
        // Use execCommand to apply font size
        document.execCommand('fontSize', false, '7'); // Use a value that we'll override
        
        // Find and update all font elements that were just created
        const fontElements = container.querySelectorAll('font[size="7"]');
        fontElements.forEach(font => {
            font.removeAttribute('size');
            font.style.fontSize = fontSize + 'px';
        });
        
        // Also handle if selection already has inline styles
        const selectedElement = range.commonAncestorContainer;
        if (selectedElement.nodeType === Node.ELEMENT_NODE) {
            selectedElement.style.fontSize = fontSize + 'px';
        } else if (selectedElement.parentElement && selectedElement.parentElement !== container) {
            selectedElement.parentElement.style.fontSize = fontSize + 'px';
        }
        
        if (tableCell) {
            syncCellToData(tableCell);
        } else {
            syncContentToData();
        }
    } else {
        // No selection - apply to current block or cell
        if (tableCell) {
            tableCell.style.fontSize = fontSize + 'px';
            syncCellToData(tableCell);
        } else {
            let node = range.startContainer;
            const editor = getActiveEditor();
            while (node && node !== editor) {
                if (node.nodeType === Node.ELEMENT_NODE && 
                    (node.tagName === 'H1' || node.tagName === 'H2' || node.tagName === 'H3' || 
                     node.tagName === 'H4' || node.tagName === 'P')) {
                    node.style.fontSize = fontSize + 'px';
                    syncContentToData();
                    break;
                }
                node = node.parentNode;
            }
        }
    }
}

// Image management functions
let currentImageMode = 'url'; // Track active tab
let currentEditingImageId = null; // Track image being edited
let currentImageAspectRatio = null; // Store aspect ratio

function showImageModal() {
    currentEditingImageId = null;
    resetImageModal();
    document.getElementById('imageModal').classList.remove('hidden');
}

function closeImageModal() {
    document.getElementById('imageModal').classList.add('hidden');
    resetImageModal();
}

function resetImageModal() {
    // Reset controls
    document.getElementById('imageX').value = '100';
    document.getElementById('imageY').value = '100';
    document.getElementById('imageWidth').value = '200';
    document.getElementById('imageHeight').value = '150';
    document.getElementById('imageAspectLock').checked = true;
    document.querySelector('input[name="imageLayer"][value="background"]').checked = true;
    currentImageAspectRatio = null;
}

function switchImageTab(mode) {
    currentImageMode = mode;
    
    // Update tab buttons and content visibility
    const tabs = {
        'url': { btn: 'tabUrl', content: 'tabContentUrl' },
        'dragdrop': { btn: 'tabDragDrop', content: 'tabContentDragDrop' },
        'upload': { btn: 'tabUpload', content: 'tabContentUpload' }
    };
    
    Object.keys(tabs).forEach(tab => {
        const btn = document.getElementById(tabs[tab].btn);
        const content = document.getElementById(tabs[tab].content);
        
        if (!btn || !content) return;
        
        if (tab === mode) {
            btn.classList.add('border-blue-500', 'text-blue-500', 'font-medium');
            btn.classList.remove('border-transparent', 'text-gray-500');
            content.classList.remove('hidden');
        } else {
            btn.classList.remove('border-blue-500', 'text-blue-500', 'font-medium');
            btn.classList.add('border-transparent', 'text-gray-500');
            content.classList.add('hidden');
        }
    });
}

function handleImageSizeChange(changedDimension) {
    const aspectLocked = document.getElementById('imageAspectLock').checked;
    
    if (!aspectLocked || !currentImageAspectRatio) {
        return;
    }
    
    const widthInput = document.getElementById('imageWidth');
    const heightInput = document.getElementById('imageHeight');
    
    if (changedDimension === 'width') {
        const newWidth = parseInt(widthInput.value);
        const newHeight = Math.round(newWidth / currentImageAspectRatio);
        heightInput.value = newHeight;
    } else {
        const newHeight = parseInt(heightInput.value);
        const newWidth = Math.round(newHeight * currentImageAspectRatio);
        widthInput.value = newWidth;
    }
}

function validateImageFile(file) {
    const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'];
    const maxSize = 5 * 1024 * 1024; // 5MB
    
    if (!validTypes.includes(file.type)) {
        alert('File type not supported. Use JPG, PNG, GIF, WebP, or SVG');
        return false;
    }
    
    if (file.size > maxSize) {
        alert('File exceeds 5MB limit. Please use a smaller image');
        return false;
    }
    
    return true;
}

function processImageFile(file) {
    if (!validateImageFile(file)) {
        return;
    }
    
    const reader = new FileReader();
    
    reader.onload = function(e) {
        const dataUrl = e.target.result;
        document.getElementById('imageUrl').value = dataUrl;
        
        // Load image to get dimensions
        const img = new Image();
        img.onload = function() {
            currentImageAspectRatio = this.naturalWidth / this.naturalHeight;
            
            // Calculate default size (50% of slide width, assuming ~700px slide width)
            const defaultWidth = 300;
            const defaultHeight = Math.round(defaultWidth / currentImageAspectRatio);
            
            document.getElementById('imageWidth').value = defaultWidth;
            document.getElementById('imageHeight').value = defaultHeight;
        };
        img.src = dataUrl;
        
        // Show preview for upload tab
        if (currentImageMode === 'upload') {
            document.getElementById('fileUploadThumb').src = dataUrl;
            document.getElementById('fileUploadPreview').classList.remove('hidden');
        }
    };
    
    reader.onerror = function() {
        alert('Failed to load image. Try another file');
    };
    
    reader.readAsDataURL(file);
}

function addImage() {
    // Only allow saving changes to existing images via modal
    if (!currentEditingImageId) {
        alert('–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ Drag & Drop –Ω–∞ –ø—Ä–µ–≤—å—é —Å–ª–∞–π–¥–∞');
        return;
    }
    
    const image = slides[currentSlideIndex].images.find(img => img.id === currentEditingImageId);
    if (!image) return;
    
    const layer = document.querySelector('input[name="imageLayer"]:checked')?.value || image.layer || 'background';
    const width = parseInt(document.getElementById('imageWidth').value) || image.size.width;
    const height = parseInt(document.getElementById('imageHeight').value) || image.size.height;
    const aspectLocked = document.getElementById('imageAspectLock').checked;
    
    const updatedImage = {
        ...image,
        position: {
            x: parseInt(document.getElementById('imageX').value) || image.position.x,
            y: parseInt(document.getElementById('imageY').value) || image.position.y
        },
        size: { width, height },
        layer: layer,
        aspectRatio: image.aspectRatio || (width / height),
        aspectLocked: aspectLocked
    };
    
    const index = slides[currentSlideIndex].images.findIndex(img => img.id === currentEditingImageId);
    if (index !== -1) {
        slides[currentSlideIndex].images[index] = updatedImage;
    }
    
    updateImagesList();
    updateSlidePreview();
    closeImageModal();
}

function editImage(imageId) {
    const image = slides[currentSlideIndex].images.find(img => img.id === imageId);
    if (!image) return;
    
    currentEditingImageId = imageId;
    currentImageAspectRatio = image.aspectRatio || (image.size.width / image.size.height);
    
    // Fill modal with image data
    document.getElementById('imageX').value = image.position.x;
    document.getElementById('imageY').value = image.position.y;
    document.getElementById('imageWidth').value = image.size.width;
    document.getElementById('imageHeight').value = image.size.height;
    document.getElementById('imageAspectLock').checked = image.aspectLocked !== false;
    
    const layerRadio = document.querySelector(`input[name="imageLayer"][value="${image.layer || 'background'}"]`);
    if (layerRadio) layerRadio.checked = true;
    
    // Show modal
    document.getElementById('imageModal').classList.remove('hidden');
}

function removeImage(imageId) {
    slides[currentSlideIndex].images = slides[currentSlideIndex].images.filter(img => img.id !== imageId);
    updateImagesList();
    updateSlidePreview();
}

function updateImagesList() {
    const container = document.getElementById('imagesList');
    const images = slides[currentSlideIndex].images || [];
    
    if (images.length === 0) {
        container.innerHTML = '<div class="text-xs text-gray-500 p-2">–ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</div>';
        return;
    }
    
    container.innerHTML = images.map(img => {
        const thumbnailUrl = img.url.startsWith('data:') ? img.url : img.url;
        
        return `
            <div class="flex items-center gap-2 p-2 bg-gray-50 rounded text-xs">
                <img src="${thumbnailUrl}" class="w-10 h-10 object-cover rounded border" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2240%22 height=%2240%22%3E%3Crect fill=%22%23ddd%22 width=%2240%22 height=%2240%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2212%22%3EIMG%3C/text%3E%3C/svg%3E'">
                <span class="truncate flex-1">–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</span>
                <button onclick="removeImage('${img.id}')" class="text-red-500 hover:text-red-700 text-lg" title="–£–¥–∞–ª–∏—Ç—å">‚úï</button>
            </div>
        `;
    }).join('');
}

// Table management functions
let currentEditingTableId = null;

function showTableModal() {
    document.getElementById('tableModal').classList.remove('hidden');
}

function closeTableModal() {
    document.getElementById('tableModal').classList.add('hidden');
}

function addTable() {
    const rows = parseInt(document.getElementById('tableRows').value) || 3;
    const columns = parseInt(document.getElementById('tableColumns').value) || 3;
    
    // Auto-calculate size based on number of columns/rows
    const cellWidth = 100; // ~100px per column
    const cellHeight = 30; // ~30px per row
    const width = columns * cellWidth;
    const height = rows * cellHeight;
    
    // Position in center of slide
    const previewEl = document.getElementById('slidePreview');
    const previewWidth = previewEl ? previewEl.offsetWidth : 800;
    const previewHeight = previewEl ? previewEl.offsetHeight : 600;
    const x = Math.max(20, (previewWidth - width) / 2);
    const y = Math.max(20, (previewHeight - height) / 2);
    
    // Initialize column widths (equal distribution)
    const columnWidths = [];
    for (let i = 0; i < columns; i++) {
        columnWidths.push(cellWidth);
    }
    
    const table = {
        id: 'tbl_' + Date.now(),
        rows: rows,
        columns: columns,
        position: { x: x, y: y },
        size: { width: width, height: height },
        columnWidths: columnWidths,
        cellData: {}
    };
    
    if (!slides[currentSlideIndex].tables) {
        slides[currentSlideIndex].tables = [];
    }
    slides[currentSlideIndex].tables.push(table);
    
    closeTableModal();
    renderPreviewTables();
    saveSlides();
}

function editTableCells(tableId) {
    currentEditingTableId = tableId;
    const table = slides[currentSlideIndex].tables.find(t => t.id === tableId);
    if (!table) return;
    
    // Update dimensions display
    document.getElementById('tableDimensions').textContent = `${table.rows} x ${table.columns}`;
    
    // Generate cell grid
    regenerateCellGrid();
    
    document.getElementById('tableCellEditorModal').classList.remove('hidden');
}

function regenerateCellGrid() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    const grid = document.getElementById('tableCellGrid');
    let html = '<div class="overflow-x-auto"><table class="w-full border-collapse border">';
    
    // Header row with column delete buttons
    html += '<tr>';
    html += '<th class="border p-1 bg-gray-100 w-10"></th>'; // Empty corner cell
    for (let col = 0; col < table.columns; col++) {
        html += `<th class="border p-1 bg-gray-100 text-center">
            <div class="flex items-center justify-center gap-1">
                <span class="text-xs text-gray-500">–°${col + 1}</span>
                ${table.columns > 1 ? `<button onclick="removeTableColumnAt(${col})" class="text-red-500 hover:text-red-700 text-xs" title="–£–¥–∞–ª–∏—Ç—å —Å—Ç–æ–ª–±–µ—Ü ${col + 1}">‚úï</button>` : ''}
            </div>
        </th>`;
    }
    html += '</tr>';
    
    // Data rows with row delete buttons
    for (let row = 0; row < table.rows; row++) {
        html += '<tr>';
        // Row header with delete button
        html += `<td class="border p-1 bg-gray-100 text-center">
            <div class="flex items-center justify-center gap-1">
                <span class="text-xs text-gray-500">–†${row + 1}</span>
                ${table.rows > 1 ? `<button onclick="removeTableRowAt(${row})" class="text-red-500 hover:text-red-700 text-xs" title="–£–¥–∞–ª–∏—Ç—å —Å—Ç—Ä–æ–∫—É ${row + 1}">‚úï</button>` : ''}
            </div>
        </td>`;
        for (let col = 0; col < table.columns; col++) {
            const cellKey = `${row}_${col}`;
            const cellValue = table.cellData[cellKey] || '';
            const escapedValue = cellValue.replace(/"/g, '&quot;');
            const bgColor = table.cellBgColors && table.cellBgColors[cellKey] ? table.cellBgColors[cellKey] : '#FFFFFF';
            html += `<td class="border p-1">
                <input type="text" 
                       id="cell_${cellKey}" 
                       value="${escapedValue}" 
                       class="w-full p-2 border rounded text-sm" 
                       style="background-color: ${bgColor};" 
                       placeholder="R${row+1}C${col+1}">
            </td>`;
        }
        html += '</tr>';
    }
    html += '</table></div>';
    grid.innerHTML = html;
    
    // Update dimensions display
    document.getElementById('tableDimensions').textContent = `${table.rows} x ${table.columns}`;
}

function addTableRow() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    // Save current cell data first
    saveCellDataTemporary();
    
    // Add new row
    table.rows++;
    
    // Initialize new row cells
    for (let col = 0; col < table.columns; col++) {
        const cellKey = `${table.rows - 1}_${col}`;
        table.cellData[cellKey] = '';
    }
    
    // Regenerate the grid
    regenerateCellGrid();
}

function addTableColumn() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    // Save current cell data first
    saveCellDataTemporary();
    
    // Add new column
    table.columns++;
    
    // Add column width (take from last column or default)
    const newColWidth = table.columnWidths && table.columnWidths.length > 0 
        ? table.columnWidths[table.columnWidths.length - 1] 
        : 100;
    if (!table.columnWidths) table.columnWidths = [];
    table.columnWidths.push(newColWidth);
    
    // Update table total width
    table.size.width += newColWidth;
    
    // Initialize new column cells
    for (let row = 0; row < table.rows; row++) {
        const cellKey = `${row}_${table.columns - 1}`;
        table.cellData[cellKey] = '';
    }
    
    // Regenerate the grid
    regenerateCellGrid();
}

function removeTableRow() {
    // Legacy function - remove last row
    removeTableRowAt(-1);
}

function removeTableRowAt(rowIndex) {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table || table.rows <= 1) {
        alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ–∫—É!');
        return;
    }
    
    // If -1, remove last row
    if (rowIndex === -1) rowIndex = table.rows - 1;
    
    // Save current cell data first
    saveCellDataTemporary();
    
    // Shift all rows after the deleted one up
    const newCellData = {};
    for (let row = 0; row < table.rows; row++) {
        for (let col = 0; col < table.columns; col++) {
            const oldKey = `${row}_${col}`;
            if (row < rowIndex) {
                // Keep rows before the deleted one
                newCellData[oldKey] = table.cellData[oldKey] || '';
            } else if (row > rowIndex) {
                // Shift rows after the deleted one
                const newKey = `${row - 1}_${col}`;
                newCellData[newKey] = table.cellData[oldKey] || '';
            }
            // Skip the deleted row
        }
    }
    
    table.cellData = newCellData;
    table.rows--;
    
    // Regenerate the grid
    regenerateCellGrid();
}

function removeTableColumn() {
    // Legacy function - remove last column
    removeTableColumnAt(-1);
}

function removeTableColumnAt(colIndex) {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table || table.columns <= 1) {
        alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å—Ç–æ–ª–±–µ—Ü!');
        return;
    }
    
    // If -1, remove last column
    if (colIndex === -1) colIndex = table.columns - 1;
    
    // Save current cell data first
    saveCellDataTemporary();
    
    // Remove column width and update table width
    if (table.columnWidths && table.columnWidths.length > colIndex) {
        const removedWidth = table.columnWidths[colIndex];
        table.columnWidths.splice(colIndex, 1);
        table.size.width -= removedWidth;
    }
    
    // Shift all columns after the deleted one left
    const newCellData = {};
    for (let row = 0; row < table.rows; row++) {
        for (let col = 0; col < table.columns; col++) {
            const oldKey = `${row}_${col}`;
            if (col < colIndex) {
                // Keep columns before the deleted one
                newCellData[oldKey] = table.cellData[oldKey] || '';
            } else if (col > colIndex) {
                // Shift columns after the deleted one
                const newKey = `${row}_${col - 1}`;
                newCellData[newKey] = table.cellData[oldKey] || '';
            }
            // Skip the deleted column
        }
    }
    
    table.cellData = newCellData;
    table.columns--;
    
    // Regenerate the grid
    regenerateCellGrid();
}

function saveCellDataTemporary() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    // Collect cell data from inputs
    for (let row = 0; row < table.rows; row++) {
        for (let col = 0; col < table.columns; col++) {
            const cellKey = `${row}_${col}`;
            const input = document.getElementById(`cell_${cellKey}`);
            if (input) {
                table.cellData[cellKey] = input.value;
            }
        }
    }
}

function saveCellData() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    // Collect cell data from inputs
    for (let row = 0; row < table.rows; row++) {
        for (let col = 0; col < table.columns; col++) {
            const cellKey = `${row}_${col}`;
            const input = document.getElementById(`cell_${cellKey}`);
            if (input) {
                table.cellData[cellKey] = input.value;
            }
        }
    }
    
    closeCellEditor();
    updateTablesList();
    renderPreviewTables();
    saveSlides();
}

function closeCellEditor() {
    document.getElementById('tableCellEditorModal').classList.add('hidden');
    currentEditingTableId = null;
}

// Cell background color tracking
let currentSelectedCell = { row: -1, col: -1 };

// Update color value display when color picker changes
document.addEventListener('DOMContentLoaded', () => {
    const cellBgColorInput = document.getElementById('cellBgColor');
    if (cellBgColorInput) {
        cellBgColorInput.addEventListener('input', (e) => {
            document.getElementById('cellBgColorValue').textContent = e.target.value.toUpperCase();
        });
    }
});

function applyCellBgToCell() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    const color = document.getElementById('cellBgColor').value;
    const activeInput = document.activeElement;
    
    // Get cell coordinates from the focused input
    if (activeInput && activeInput.id && activeInput.id.startsWith('cell_')) {
        const cellKey = activeInput.id.replace('cell_', '');
        
        // Initialize cellBgColors if not present
        if (!table.cellBgColors) {
            table.cellBgColors = {};
        }
        
        table.cellBgColors[cellKey] = color;
        
        // Visual feedback - update the input background
        activeInput.style.backgroundColor = color;
        
        alert(`–¶–≤–µ—Ç —Ñ–æ–Ω–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω –∫ —è—á–µ–π–∫–µ ${cellKey}`);
    } else {
        alert('–í—ã–±–µ—Ä–∏—Ç–µ —è—á–µ–π–∫—É, –∫–ª–∏–∫–Ω—É–≤ –Ω–∞ –Ω–µ–µ');
    }
}

function applyCellBgToRow() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    const color = document.getElementById('cellBgColor').value;
    const activeInput = document.activeElement;
    
    if (activeInput && activeInput.id && activeInput.id.startsWith('cell_')) {
        const cellKey = activeInput.id.replace('cell_', '');
        const row = parseInt(cellKey.split('_')[0]);
        
        // Initialize cellBgColors if not present
        if (!table.cellBgColors) {
            table.cellBgColors = {};
        }
        
        // Apply to all cells in the row
        for (let col = 0; col < table.columns; col++) {
            const key = `${row}_${col}`;
            table.cellBgColors[key] = color;
            
            // Visual feedback
            const input = document.getElementById(`cell_${key}`);
            if (input) {
                input.style.backgroundColor = color;
            }
        }
        
        alert(`–¶–≤–µ—Ç —Ñ–æ–Ω–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω –∫ —Å—Ç—Ä–æ–∫–µ ${row + 1}`);
    } else {
        alert('–í—ã–±–µ—Ä–∏—Ç–µ —è—á–µ–π–∫—É –≤ –Ω—É–∂–Ω–æ–π —Å—Ç—Ä–æ–∫–µ');
    }
}

function applyCellBgToColumn() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    const color = document.getElementById('cellBgColor').value;
    const activeInput = document.activeElement;
    
    if (activeInput && activeInput.id && activeInput.id.startsWith('cell_')) {
        const cellKey = activeInput.id.replace('cell_', '');
        const col = parseInt(cellKey.split('_')[1]);
        
        // Initialize cellBgColors if not present
        if (!table.cellBgColors) {
            table.cellBgColors = {};
        }
        
        // Apply to all cells in the column
        for (let row = 0; row < table.rows; row++) {
            const key = `${row}_${col}`;
            table.cellBgColors[key] = color;
            
            // Visual feedback
            const input = document.getElementById(`cell_${key}`);
            if (input) {
                input.style.backgroundColor = color;
            }
        }
        
        alert(`–¶–≤–µ—Ç —Ñ–æ–Ω–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω –∫ —Å—Ç–æ–ª–±—Ü—É ${col + 1}`);
    } else {
        alert('–í—ã–±–µ—Ä–∏—Ç–µ —è—á–µ–π–∫—É –≤ –Ω—É–∂–Ω–æ–º —Å—Ç–æ–ª–±—Ü–µ');
    }
}

function applyCellBgToAll() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    const color = document.getElementById('cellBgColor').value;
    
    // Initialize cellBgColors if not present
    if (!table.cellBgColors) {
        table.cellBgColors = {};
    }
    
    // Apply to all cells
    for (let row = 0; row < table.rows; row++) {
        for (let col = 0; col < table.columns; col++) {
            const key = `${row}_${col}`;
            table.cellBgColors[key] = color;
            
            // Visual feedback
            const input = document.getElementById(`cell_${key}`);
            if (input) {
                input.style.backgroundColor = color;
            }
        }
    }
    
    // Update color value display
    document.getElementById('cellBgColorValue').textContent = color;
}

function removeTable(tableId) {
    slides[currentSlideIndex].tables = slides[currentSlideIndex].tables.filter(tbl => tbl.id !== tableId);
    updateTablesList();
    renderPreviewTables();
    saveSlides();
}

function updateTablesList() {
    const container = document.getElementById('tablesList');
    const tables = slides[currentSlideIndex].tables || [];
    
    if (tables.length === 0) {
        container.innerHTML = '<div class="text-xs text-gray-500 p-2">–ù–µ—Ç —Ç–∞–±–ª–∏—Ü</div>';
        return;
    }
    
    container.innerHTML = tables.map(tbl => `
        <div class="flex items-center justify-between p-2 bg-gray-50 rounded text-xs">
            <span>–¢–∞–±–ª–∏—Ü–∞ ${tbl.rows}x${tbl.columns}</span>
            <div class="flex gap-1">
                <button onclick="editTableCells('${tbl.id}')" class="text-blue-500 hover:text-blue-700" title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å">‚úé</button>
                <button onclick="removeTable('${tbl.id}')" class="text-red-500 hover:text-red-700" title="–£–¥–∞–ª–∏—Ç—å">‚úï</button>
            </div>
        </div>
    `).join('');
    
    // Re-render tables on preview
    renderPreviewTables();
}

// Table rendering functions
let selectedTableId = null;

function renderPreviewTables() {
    const tables = slides[currentSlideIndex].tables || [];
    const tablesContainer = document.getElementById('previewTables');
    
    // Clear existing tables
    tablesContainer.innerHTML = '';
    
    // Deselect all tables when re-rendering
    deselectAllTables();
    
    // Render all tables
    tables.forEach(tbl => {
        const wrapper = createTableWrapper(tbl);
        tablesContainer.appendChild(wrapper);
    });
    
    // Initialize Interact.js on all new table wrappers
    setTimeout(() => {
        if (typeof interact !== 'undefined') {
            initializeTableInteractions();
        }
    }, 50);
}

function createTableWrapper(tableData) {
    // Create wrapper div
    const wrapper = document.createElement('div');
    wrapper.className = 'table-wrapper';
    wrapper.dataset.tableId = tableData.id;
    wrapper.style.left = `${tableData.position.x}px`;
    wrapper.style.top = `${tableData.position.y}px`;
    
    // Initialize column widths if not present
    if (!tableData.columnWidths || tableData.columnWidths.length !== tableData.columns) {
        const defaultColWidth = Math.floor(tableData.size.width / tableData.columns);
        tableData.columnWidths = [];
        for (let i = 0; i < tableData.columns; i++) {
            tableData.columnWidths.push(defaultColWidth);
        }
    }
    
    // Calculate total width from column widths
    const totalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
    wrapper.style.width = `${totalWidth + 12}px`; // +12 for padding (6px on each side)
    wrapper.style.height = 'auto';
    wrapper.style.pointerEvents = 'auto';
    
    // Create drag handle bar at top
    const dragHandle = document.createElement('div');
    dragHandle.className = 'table-drag-handle';
    dragHandle.title = '–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã';
    wrapper.appendChild(dragHandle);
    
    // Create table element
    const tableEl = document.createElement('table');
    
    // Create colgroup for column widths
    const colgroup = document.createElement('colgroup');
    for (let col = 0; col < tableData.columns; col++) {
        const colEl = document.createElement('col');
        colEl.style.width = `${tableData.columnWidths[col]}px`;
        colEl.dataset.colIndex = col;
        colgroup.appendChild(colEl);
    }
    tableEl.appendChild(colgroup);
    
    for (let row = 0; row < tableData.rows; row++) {
        const tr = document.createElement('tr');
        for (let col = 0; col < tableData.columns; col++) {
            const td = row === 0 ? document.createElement('th') : document.createElement('td');
            const cellKey = `${row}_${col}`;
            
            // Make cell editable
            td.contentEditable = 'true';
            td.dataset.row = row;
            td.dataset.col = col;
            td.dataset.tableId = tableData.id;
            
            // Set cell content (supports HTML formatting)
            const cellContent = tableData.cellData[cellKey] || '';
            // Check if it's HTML or plain text
            if (cellContent.includes('<') && cellContent.includes('>')) {
                td.innerHTML = cellContent;
            } else {
                td.innerHTML = cellContent.replace(/\n/g, '<br>');
            }
            
            // Apply background color if set
            if (tableData.cellBgColors && tableData.cellBgColors[cellKey]) {
                td.style.backgroundColor = tableData.cellBgColors[cellKey];
            }
            
            // Handle input - sync to data
            td.addEventListener('input', (e) => {
                syncCellToData(e.target);
            });
            
            // Handle keydown for Enter
            td.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    // Allow default Enter behavior for line break
                    // Shift+Enter or just Enter both add line break
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    // Move to next/previous cell
                    navigateTableCell(e.target, e.shiftKey ? -1 : 1);
                } else if (e.key === 'Escape') {
                    e.target.blur();
                }
            });
            
            // Prevent table drag when editing
            td.addEventListener('mousedown', (e) => {
                e.stopPropagation();
            });
            
            tr.appendChild(td);
        }
        tableEl.appendChild(tr);
    }
    
    wrapper.appendChild(tableEl);
    
    // Apply saved font size if set
    if (tableData.fontSize && tableData.fontSize !== 12) {
        tableEl.style.fontSize = `${tableData.fontSize}px`;
    }
    
    // Create column resize handles (between columns)
    let xOffset = 6; // Start after left padding
    for (let col = 0; col < tableData.columns - 1; col++) {
        xOffset += tableData.columnWidths[col];
        const colHandle = document.createElement('div');
        colHandle.className = 'col-resize-handle';
        colHandle.dataset.colIndex = col;
        colHandle.style.left = `${xOffset + 3}px`; // center on column edge
        
        // Add mouse events for column resizing
        colHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            startColumnResize(e, tableData.id, col);
        });
        
        wrapper.appendChild(colHandle);
    }
    
    // Create edge resize handles for width (left/right) and height (top/bottom)
    // LEFT edge
    const leftEdge = document.createElement('div');
    leftEdge.className = 'edge-resize-handle left';
    leftEdge.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        startEdgeResize(e, tableData.id, 'left');
    });
    wrapper.appendChild(leftEdge);
    
    // RIGHT edge
    const rightEdge = document.createElement('div');
    rightEdge.className = 'edge-resize-handle right';
    rightEdge.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        startEdgeResize(e, tableData.id, 'right');
    });
    wrapper.appendChild(rightEdge);
    
    // TOP edge (for height)
    const topEdge = document.createElement('div');
    topEdge.className = 'edge-resize-handle top';
    topEdge.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        startEdgeResize(e, tableData.id, 'top');
    });
    wrapper.appendChild(topEdge);
    
    // BOTTOM edge (for height)
    const bottomEdge = document.createElement('div');
    bottomEdge.className = 'edge-resize-handle bottom';
    bottomEdge.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        startEdgeResize(e, tableData.id, 'bottom');
    });
    wrapper.appendChild(bottomEdge);
    
    // Create corner resize handles
    const corners = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    corners.forEach(corner => {
        const cornerHandle = document.createElement('div');
        cornerHandle.className = `corner-resize-handle ${corner}`;
        cornerHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            startCornerResize(e, tableData.id, corner);
        });
        wrapper.appendChild(cornerHandle);
    });
    
    // Click to select
    wrapper.onclick = function(e) {
        // Don't select when clicking on cells or resize handles (they handle their own editing)
        if (e.target.tagName === 'TH' || e.target.tagName === 'TD') {
            return;
        }
        if (e.target.classList.contains('col-resize-handle') || e.target.classList.contains('edge-resize-handle') || e.target.classList.contains('corner-resize-handle')) {
            return;
        }
        selectTable(tableData.id);
        e.stopPropagation();
    };
    
    // Double click - opens cell editor modal
    wrapper.ondblclick = function(e) {
        e.stopPropagation();
        editTableCells(tableData.id);
    };
    
    return wrapper;
}

// Column resize functionality
let isResizingColumn = false;
let resizingTableId = null;
let resizingColIndex = null;
let resizeStartX = 0;
let resizeStartWidths = []; // Store all column widths at start

function startColumnResize(e, tableId, colIndex) {
    e.preventDefault();
    isResizingColumn = true;
    resizingTableId = tableId;
    resizingColIndex = colIndex;
    resizeStartX = e.clientX;
    
    const tableData = getTableData(tableId);
    // Store a copy of all column widths at start
    resizeStartWidths = [...tableData.columnWidths];
    
    // Add highlight to resize handle
    const handle = e.target;
    handle.classList.add('resizing');
    
    document.addEventListener('mousemove', handleColumnResize);
    document.addEventListener('mouseup', stopColumnResize);
}

function handleColumnResize(e) {
    if (!isResizingColumn) return;
    
    const tableData = getTableData(resizingTableId);
    if (!tableData) return;
    
    const deltaX = e.clientX - resizeStartX;
    
    // Calculate new width for the current column
    const newWidth = Math.max(30, resizeStartWidths[resizingColIndex] + deltaX);
    
    // Update only the resized column, keep total table width
    tableData.columnWidths[resizingColIndex] = newWidth;
    
    // Recalculate total width
    const totalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
    tableData.size.width = totalWidth;
    
    // Update the table wrapper and column widths directly without full re-render
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${resizingTableId}"]`);
    if (wrapper) {
        wrapper.style.width = `${totalWidth + 12}px`; // +12 for padding
        
        // Update colgroup widths
        const cols = wrapper.querySelectorAll('col');
        tableData.columnWidths.forEach((w, i) => {
            if (cols[i]) cols[i].style.width = `${w}px`;
        });
        
        // Update column resize handle positions
        updateColumnHandlePositions(wrapper, tableData);
    }
    
    // Show tooltip
    showDimensionTooltip(
        e.clientX + 10,
        e.clientY + 10,
        `–°—Ç–æ–ª–±–µ—Ü ${resizingColIndex + 1}: ${newWidth}px`
    );
}

function stopColumnResize(e) {
    if (!isResizingColumn) return;
    
    isResizingColumn = false;
    hideDimensionTooltip();
    
    // Remove highlight from all resize handles
    document.querySelectorAll('.col-resize-handle.resizing').forEach(h => h.classList.remove('resizing'));
    
    document.removeEventListener('mousemove', handleColumnResize);
    document.removeEventListener('mouseup', stopColumnResize);
    
    resizingTableId = null;
    resizingColIndex = null;
    resizeStartWidths = [];
    
    debouncedSave();
}

// Edge resize functionality (left/right for width, top/bottom for height)
let isResizingEdge = false;
let resizingEdgeTableId = null;
let resizingEdgeSide = null; // 'left', 'right', 'top', 'bottom'
let edgeResizeStartX = 0;
let edgeResizeStartY = 0;
let edgeResizeStartWidth = 0;
let edgeResizeStartHeight = 0;
let edgeResizeStartPosition = { x: 0, y: 0 };
let edgeResizeStartFontSize = 12;

function startEdgeResize(e, tableId, side) {
    e.preventDefault();
    isResizingEdge = true;
    resizingEdgeTableId = tableId;
    resizingEdgeSide = side;
    edgeResizeStartX = e.clientX;
    edgeResizeStartY = e.clientY;
    
    const tableData = getTableData(tableId);
    if (!tableData) return;
    
    edgeResizeStartWidth = tableData.size.width;
    edgeResizeStartHeight = tableData.size.height || 100;
    edgeResizeStartPosition = { x: tableData.position.x, y: tableData.position.y };
    edgeResizeStartFontSize = tableData.fontSize || 12;
    
    // Prevent text selection
    document.body.style.userSelect = 'none';
    
    // Add highlight
    e.target.classList.add('resizing');
    
    document.addEventListener('mousemove', handleEdgeResize);
    document.addEventListener('mouseup', stopEdgeResize);
}

function handleEdgeResize(e) {
    if (!isResizingEdge) return;
    
    const tableData = getTableData(resizingEdgeTableId);
    if (!tableData) return;
    
    const deltaX = e.clientX - edgeResizeStartX;
    const deltaY = e.clientY - edgeResizeStartY;
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${resizingEdgeTableId}"]`);
    
    if (resizingEdgeSide === 'left') {
        // Resize width from left (scale columns proportionally, move position)
        const newWidth = Math.max(100, edgeResizeStartWidth - deltaX);
        const scale = newWidth / edgeResizeStartWidth;
        
        for (let i = 0; i < tableData.columns; i++) {
            tableData.columnWidths[i] = Math.max(30, Math.round(tableData.columnWidths[i] * scale / (tableData.size.width / edgeResizeStartWidth)));
        }
        
        const totalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
        tableData.size.width = totalWidth;
        tableData.position.x = edgeResizeStartPosition.x + (edgeResizeStartWidth - totalWidth);
        
        if (wrapper) {
            wrapper.style.width = `${totalWidth + 12}px`;
            wrapper.style.left = `${tableData.position.x}px`;
        }
        
        showDimensionTooltip(e.clientX + 10, e.clientY + 10, `–®–∏—Ä–∏–Ω–∞: ${totalWidth}px`);
        
    } else if (resizingEdgeSide === 'right') {
        // Resize width from right (scale columns proportionally)
        const newWidth = Math.max(100, edgeResizeStartWidth + deltaX);
        const scale = newWidth / edgeResizeStartWidth;
        
        for (let i = 0; i < tableData.columns; i++) {
            tableData.columnWidths[i] = Math.max(30, Math.round(tableData.columnWidths[i] * scale / (tableData.size.width / edgeResizeStartWidth)));
        }
        
        const totalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
        tableData.size.width = totalWidth;
        
        if (wrapper) {
            wrapper.style.width = `${totalWidth + 12}px`;
        }
        
        showDimensionTooltip(e.clientX + 10, e.clientY + 10, `–®–∏—Ä–∏–Ω–∞: ${totalWidth}px`);
        
    } else if (resizingEdgeSide === 'top') {
        // Resize height from top (change font size, move position)
        const newFontSize = Math.max(8, Math.min(48, edgeResizeStartFontSize - Math.round(deltaY / 5)));
        tableData.fontSize = newFontSize;
        tableData.position.y = edgeResizeStartPosition.y + deltaY;
        
        if (wrapper) {
            wrapper.style.top = `${tableData.position.y}px`;
            const tableEl = wrapper.querySelector('table');
            if (tableEl) tableEl.style.fontSize = `${newFontSize}px`;
        }
        
        showDimensionTooltip(e.clientX + 10, e.clientY + 10, `–†–∞–∑–º–µ—Ä: ${newFontSize}px`);
        
    } else if (resizingEdgeSide === 'bottom') {
        // Resize height from bottom (change font size)
        const newFontSize = Math.max(8, Math.min(48, edgeResizeStartFontSize + Math.round(deltaY / 5)));
        tableData.fontSize = newFontSize;
        
        if (wrapper) {
            const tableEl = wrapper.querySelector('table');
            if (tableEl) tableEl.style.fontSize = `${newFontSize}px`;
        }
        
        showDimensionTooltip(e.clientX + 10, e.clientY + 10, `–†–∞–∑–º–µ—Ä: ${newFontSize}px`);
    }
    
    // Update colgroup widths and handle positions
    if (wrapper && (resizingEdgeSide === 'left' || resizingEdgeSide === 'right')) {
        const cols = wrapper.querySelectorAll('col');
        tableData.columnWidths.forEach((w, i) => {
            if (cols[i]) cols[i].style.width = `${w}px`;
        });
        updateColumnHandlePositions(wrapper, tableData);
    }
}

function stopEdgeResize(e) {
    if (!isResizingEdge) return;
    
    isResizingEdge = false;
    document.body.style.userSelect = '';
    hideDimensionTooltip();
    
    // Remove highlight
    document.querySelectorAll('.edge-resize-handle.resizing').forEach(h => h.classList.remove('resizing'));
    
    document.removeEventListener('mousemove', handleEdgeResize);
    document.removeEventListener('mouseup', stopEdgeResize);
    
    resizingEdgeTableId = null;
    resizingEdgeSide = null;
    
    debouncedSave();
}

function updateColumnHandlePositions(wrapper, tableData) {
    const handles = wrapper.querySelectorAll('.col-resize-handle');
    let xOffset = 6; // Start after left padding
    for (let i = 0; i < tableData.columns - 1; i++) {
        xOffset += tableData.columnWidths[i];
        if (handles[i]) handles[i].style.left = `${xOffset + 3}px`;
    }
}

// Corner resize functionality (resize width AND height independently)
let isResizingCorner = false;
let resizingCornerTableId = null;
let resizingCornerPosition = null; // 'top-left', 'top-right', 'bottom-left', 'bottom-right'
let cornerResizeStartX = 0;
let cornerResizeStartY = 0;
let cornerResizeStartWidths = [];
let cornerResizeStartFontSize = 12;
let cornerResizeStartTotalWidth = 0;
let cornerResizeStartPosition = { x: 0, y: 0 };

function startCornerResize(e, tableId, corner) {
    e.preventDefault();
    isResizingCorner = true;
    resizingCornerTableId = tableId;
    resizingCornerPosition = corner;
    cornerResizeStartX = e.clientX;
    cornerResizeStartY = e.clientY;
    
    const tableData = getTableData(tableId);
    if (!tableData) return;
    
    cornerResizeStartWidths = [...tableData.columnWidths];
    cornerResizeStartTotalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
    cornerResizeStartFontSize = tableData.fontSize || 12;
    cornerResizeStartPosition = { x: tableData.position.x, y: tableData.position.y };
    
    // Prevent text selection
    document.body.style.userSelect = 'none';
    
    document.addEventListener('mousemove', handleCornerResize);
    document.addEventListener('mouseup', stopCornerResize);
}

function handleCornerResize(e) {
    if (!isResizingCorner) return;
    
    const tableData = getTableData(resizingCornerTableId);
    if (!tableData) return;
    
    const deltaX = e.clientX - cornerResizeStartX;
    const deltaY = e.clientY - cornerResizeStartY;
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${resizingCornerTableId}"]`);
    
    // Determine resize direction based on corner
    let widthDelta = 0;
    let heightDelta = 0;
    let moveX = false;
    let moveY = false;
    
    if (resizingCornerPosition.includes('left')) {
        widthDelta = -deltaX;
        moveX = true;
    } else {
        widthDelta = deltaX;
    }
    
    if (resizingCornerPosition.includes('top')) {
        heightDelta = -deltaY;
        moveY = true;
    } else {
        heightDelta = deltaY;
    }
    
    // Calculate new width (scale columns proportionally)
    const newTotalWidth = Math.max(100, cornerResizeStartTotalWidth + widthDelta);
    const widthScale = newTotalWidth / cornerResizeStartTotalWidth;
    
    for (let i = 0; i < tableData.columns; i++) {
        tableData.columnWidths[i] = Math.max(30, Math.round(cornerResizeStartWidths[i] * widthScale));
    }
    
    const actualTotalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
    tableData.size.width = actualTotalWidth;
    
    // Calculate new font size (height control)
    const newFontSize = Math.max(8, Math.min(48, cornerResizeStartFontSize + Math.round(heightDelta / 5)));
    tableData.fontSize = newFontSize;
    
    // Update position if resizing from left or top
    if (moveX) {
        tableData.position.x = cornerResizeStartPosition.x - (actualTotalWidth - cornerResizeStartTotalWidth);
    }
    if (moveY) {
        tableData.position.y = cornerResizeStartPosition.y + deltaY;
    }
    
    // Update visual
    if (wrapper) {
        wrapper.style.width = `${actualTotalWidth + 12}px`;
        wrapper.style.left = `${tableData.position.x}px`;
        wrapper.style.top = `${tableData.position.y}px`;
        
        // Update font size
        const tableEl = wrapper.querySelector('table');
        if (tableEl) {
            tableEl.style.fontSize = `${newFontSize}px`;
        }
        
        // Update colgroup widths
        const cols = wrapper.querySelectorAll('col');
        tableData.columnWidths.forEach((w, i) => {
            if (cols[i]) cols[i].style.width = `${w}px`;
        });
        
        // Update column resize handle positions
        updateColumnHandlePositions(wrapper, tableData);
    }
    
    // Show tooltip
    showDimensionTooltip(
        e.clientX + 10,
        e.clientY + 10,
        `${actualTotalWidth}px x ${newFontSize}px`
    );
}

function stopCornerResize(e) {
    if (!isResizingCorner) return;
    
    isResizingCorner = false;
    document.body.style.userSelect = '';
    hideDimensionTooltip();
    
    document.removeEventListener('mousemove', handleCornerResize);
    document.removeEventListener('mouseup', stopCornerResize);
    
    resizingCornerTableId = null;
    resizingCornerPosition = null;
    cornerResizeStartWidths = [];
    
    debouncedSave();
}

function selectTable(tableId) {
    deselectAllTables();
    deselectAllImages();
    
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${tableId}"]`);
    if (wrapper) {
        wrapper.classList.add('selected');
        selectedTableId = tableId;
    }
}

function deselectAllTables() {
    document.querySelectorAll('.table-wrapper.selected').forEach(el => {
        el.classList.remove('selected');
    });
    selectedTableId = null;
}

function getTableData(tableId) {
    const tables = slides[currentSlideIndex].tables || [];
    return tables.find(t => t.id === tableId);
}

// Sync cell content to data model (preserves HTML formatting)
function syncCellToData(cell) {
    const tableId = cell.dataset.tableId;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    
    const tableData = getTableData(tableId);
    if (!tableData) return;
    
    // Store the HTML content directly to preserve formatting
    const cellKey = `${row}_${col}`;
    tableData.cellData[cellKey] = cell.innerHTML;
    
    // Update table height based on content
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${tableId}"]`);
    if (wrapper) {
        // Get the actual rendered height of the table
        tableData.size.height = wrapper.offsetHeight;
    }
    
    // Debounce save
    debouncedSave();
}

// Navigate between cells with Tab key
function navigateTableCell(currentCell, direction) {
    const tableId = currentCell.dataset.tableId;
    const currentRow = parseInt(currentCell.dataset.row);
    const currentCol = parseInt(currentCell.dataset.col);
    
    const tableData = getTableData(tableId);
    if (!tableData) return;
    
    let newRow = currentRow;
    let newCol = currentCol + direction;
    
    // Handle column overflow
    if (newCol >= tableData.columns) {
        newCol = 0;
        newRow++;
    } else if (newCol < 0) {
        newCol = tableData.columns - 1;
        newRow--;
    }
    
    // Handle row overflow
    if (newRow >= tableData.rows) {
        newRow = 0;
    } else if (newRow < 0) {
        newRow = tableData.rows - 1;
    }
    
    // Find and focus the target cell
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${tableId}"]`);
    if (wrapper) {
        const targetCell = wrapper.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
        if (targetCell) {
            targetCell.focus();
            // Select all content in the cell
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(targetCell);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }
}

function initializeTableInteractions() {
    if (typeof interact === 'undefined') {
        console.error('Interact.js not loaded yet');
        return;
    }
    
    const wrappers = document.querySelectorAll('.table-wrapper');
    console.log('Initializing Interact.js on', wrappers.length, 'table wrappers');
    
    wrappers.forEach(wrapper => {
        const tableId = wrapper.dataset.tableId;
        const tableData = getTableData(tableId);
        
        if (!tableData) return;
        
        // Configure draggable - only from drag handle
        interact(wrapper)
            .draggable({
                inertia: false,
                allowFrom: '.table-drag-handle',
                modifiers: [
                    interact.modifiers.restrictRect({
                        restriction: 'parent',
                        endOnly: true
                    })
                ],
                listeners: {
                    start: (event) => {
                        event.target.classList.add('dragging');
                    },
                    move: (event) => {
                        const target = event.target;
                        const tableData = getTableData(tableId);
                        
                        // Update position
                        const x = (parseFloat(target.style.left) || 0) + event.dx;
                        const y = (parseFloat(target.style.top) || 0) + event.dy;
                        
                        target.style.left = `${x}px`;
                        target.style.top = `${y}px`;
                        
                        // Update data model
                        if (tableData) {
                            tableData.position.x = Math.round(x);
                            tableData.position.y = Math.round(y);
                        }
                        
                        // Show position tooltip
                        showDimensionTooltip(
                            event.clientX + 10,
                            event.clientY + 10,
                            `X: ${Math.round(x)}, Y: ${Math.round(y)}`
                        );
                    },
                    end: (event) => {
                        event.target.classList.remove('dragging');
                        hideDimensionTooltip();
                        debouncedSave();
                    }
                }
            });
    });
}

// Arrow management functions
function showArrowModal() {
    document.getElementById('arrowModal').classList.remove('hidden');
}

function closeArrowModal() {
    document.getElementById('arrowModal').classList.add('hidden');
}

function addArrow() {
    const arrow = {
        id: 'arr_' + Date.now(),
        type: document.getElementById('arrowType').value,
        startPoint: {
            x: parseInt(document.getElementById('arrowStartX').value),
            y: parseInt(document.getElementById('arrowStartY').value)
        },
        endPoint: {
            x: parseInt(document.getElementById('arrowEndX').value),
            y: parseInt(document.getElementById('arrowEndY').value)
        },
        color: document.getElementById('arrowColor').value,
        strokeWidth: parseInt(document.getElementById('arrowStroke').value)
    };
    
    if (!slides[currentSlideIndex].arrows) {
        slides[currentSlideIndex].arrows = [];
    }
    slides[currentSlideIndex].arrows.push(arrow);
    
    updateArrowsList();
    closeArrowModal();
    saveSlides();
}

function removeArrow(arrowId) {
    slides[currentSlideIndex].arrows = slides[currentSlideIndex].arrows.filter(arr => arr.id !== arrowId);
    updateArrowsList();
    saveSlides();
}

function updateArrowsList() {
    const container = document.getElementById('arrowsList');
    const arrows = slides[currentSlideIndex].arrows || [];
    
    if (arrows.length === 0) {
        container.innerHTML = '<div class="text-xs text-gray-500 p-2">–ù–µ—Ç —Å—Ç—Ä–µ–ª–æ–∫</div>';
        return;
    }
    
    container.innerHTML = arrows.map(arr => `
        <div class="flex items-center justify-between p-2 bg-gray-50 rounded text-xs">
            <span>–°—Ç—Ä–µ–ª–∫–∞ (${arr.type})</span>
            <button onclick="removeArrow('${arr.id}')" class="text-red-500 hover:text-red-700 ml-2">‚úï</button>
        </div>
    `).join('');
    
    // Re-render arrows on preview
    renderPreviewArrows();
}

// Arrow rendering functions
function renderPreviewArrows() {
    const arrows = slides[currentSlideIndex].arrows || [];
    const arrowsContainer = document.getElementById('previewArrows');
    
    // Clear existing arrows
    arrowsContainer.innerHTML = '';
    
    // Render all arrows
    arrows.forEach(arrow => {
        const arrowElement = createArrowSVG(arrow);
        arrowsContainer.appendChild(arrowElement);
    });
    
    // Initialize drag interactions for arrows
    setTimeout(() => {
        if (typeof interact !== 'undefined') {
            initializeArrowInteractions();
        }
    }, 50);
}

// Initialize arrow dragging with Interact.js
function initializeArrowInteractions() {
    interact('.arrow-wrapper').unset();
    interact('.arrow-handle').unset();
    
    // Drag the entire arrow
    interact('.arrow-wrapper').draggable({
        inertia: false,
        modifiers: [
            interact.modifiers.restrictRect({
                restriction: 'parent',
                endOnly: true
            })
        ],
        autoScroll: true,
        ignoreFrom: '.arrow-handle',
        listeners: {
            start(event) {
                const arrowId = event.target.dataset.arrowId;
                selectArrow(arrowId);
            },
            move(event) {
                const target = event.target;
                const arrowId = target.dataset.arrowId;
                const arrow = slides[currentSlideIndex].arrows.find(a => a.id === arrowId);
                if (!arrow) return;
                
                // Move both start and end points
                arrow.startPoint.x += event.dx;
                arrow.startPoint.y += event.dy;
                arrow.endPoint.x += event.dx;
                arrow.endPoint.y += event.dy;
                
                // Update visual position
                const x = (parseFloat(target.style.left) || 0) + event.dx;
                const y = (parseFloat(target.style.top) || 0) + event.dy;
                target.style.left = x + 'px';
                target.style.top = y + 'px';
            },
            end(event) {
                saveSlides();
            }
        }
    });
    
    // Drag endpoint handles to resize/rotate arrow
    interact('.arrow-handle').draggable({
        inertia: false,
        listeners: {
            start(event) {
                event.stopPropagation();
                // Prevent text selection during drag
                document.body.style.userSelect = 'none';
                event.target.style.cursor = 'grabbing';
                event.target.style.transform = 'scale(1.2)';
            },
            move(event) {
                const handle = event.target;
                const wrapper = handle.closest('.arrow-wrapper');
                if (!wrapper) return;
                
                const arrowId = wrapper.dataset.arrowId;
                const arrow = slides[currentSlideIndex].arrows.find(a => a.id === arrowId);
                if (!arrow) return;
                
                const handleType = handle.dataset.handleType;
                const previewRect = document.getElementById('slidePreview').getBoundingClientRect();
                
                // Calculate new position in preview coordinates
                const newX = Math.max(0, Math.min(previewRect.width, event.clientX - previewRect.left));
                const newY = Math.max(0, Math.min(previewRect.height, event.clientY - previewRect.top));
                
                if (handleType === 'start') {
                    arrow.startPoint.x = newX;
                    arrow.startPoint.y = newY;
                } else if (handleType === 'end') {
                    arrow.endPoint.x = newX;
                    arrow.endPoint.y = newY;
                }
                
                // Update arrow visually without full re-render (faster)
                updateArrowVisual(arrowId, arrow);
            },
            end(event) {
                document.body.style.userSelect = '';
                event.target.style.cursor = 'grab';
                event.target.style.transform = '';
                // Full re-render on end to ensure consistency
                renderPreviewArrows();
                saveSlides();
            }
        }
    });
}

// Update arrow visual without full re-render (for smooth dragging)
function updateArrowVisual(arrowId, arrow) {
    const wrapper = document.querySelector(`.arrow-wrapper[data-arrow-id="${arrowId}"]`);
    if (!wrapper) return;
    
    // Calculate bounding box
    const padding = 20;
    const minX = Math.min(arrow.startPoint.x, arrow.endPoint.x);
    const minY = Math.min(arrow.startPoint.y, arrow.endPoint.y);
    const maxX = Math.max(arrow.startPoint.x, arrow.endPoint.x);
    const maxY = Math.max(arrow.startPoint.y, arrow.endPoint.y);
    const width = maxX - minX;
    const height = maxY - minY;
    
    // Update wrapper position
    wrapper.style.left = (minX - padding) + 'px';
    wrapper.style.top = (minY - padding) + 'px';
    wrapper.style.width = (width + 2 * padding) + 'px';
    wrapper.style.height = (height + 2 * padding) + 'px';
    
    // Calculate relative coordinates
    const relStartX = arrow.startPoint.x - minX + padding;
    const relStartY = arrow.startPoint.y - minY + padding;
    const relEndX = arrow.endPoint.x - minX + padding;
    const relEndY = arrow.endPoint.y - minY + padding;
    
    // Update SVG line/path
    const svg = wrapper.querySelector('svg');
    if (svg) {
        const line = svg.querySelector('line');
        const path = svg.querySelector('path');
        
        if (line) {
            line.setAttribute('x1', relStartX);
            line.setAttribute('y1', relStartY);
            line.setAttribute('x2', relEndX);
            line.setAttribute('y2', relEndY);
        } else if (path) {
            // Re-create path for bent/curved arrows
            if (arrow.type === 'bent') {
                const midX = (relStartX + relEndX) / 2;
                path.setAttribute('d', `M ${relStartX},${relStartY} L ${midX},${relStartY} L ${midX},${relEndY} L ${relEndX},${relEndY}`);
            } else if (arrow.type === 'curved') {
                const controlX = (relStartX + relEndX) / 2;
                const controlY = relStartY - 50;
                path.setAttribute('d', `M ${relStartX},${relStartY} Q ${controlX},${controlY} ${relEndX},${relEndY}`);
            }
        }
    }
    
    // Update handle positions
    const startHandle = wrapper.querySelector('.arrow-start-handle');
    const endHandle = wrapper.querySelector('.arrow-end-handle');
    
    if (startHandle) {
        startHandle.style.left = (relStartX - 10) + 'px';
        startHandle.style.top = (relStartY - 10) + 'px';
    }
    if (endHandle) {
        endHandle.style.left = (relEndX - 10) + 'px';
        endHandle.style.top = (relEndY - 10) + 'px';
    }
}

function createArrowSVG(arrowData) {
    const wrapper = document.createElement('div');
    wrapper.className = 'arrow-wrapper';
    wrapper.dataset.arrowId = arrowData.id;
    wrapper.style.position = 'absolute';
    wrapper.style.pointerEvents = 'auto';
    wrapper.style.cursor = 'move';
    
    // Add click handler for selection
    wrapper.onclick = function(e) {
        e.stopPropagation();
        selectArrow(arrowData.id);
    };
    
    // Calculate bounding box
    const minX = Math.min(arrowData.startPoint.x, arrowData.endPoint.x);
    const minY = Math.min(arrowData.startPoint.y, arrowData.endPoint.y);
    const maxX = Math.max(arrowData.startPoint.x, arrowData.endPoint.x);
    const maxY = Math.max(arrowData.startPoint.y, arrowData.endPoint.y);
    const width = maxX - minX;
    const height = maxY - minY;
    
    // Add padding for arrowhead
    const padding = 20;
    wrapper.style.left = (minX - padding) + 'px';
    wrapper.style.top = (minY - padding) + 'px';
    wrapper.style.width = (width + 2 * padding) + 'px';
    wrapper.style.height = (height + 2 * padding) + 'px';
    
    // Create SVG
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.style.overflow = 'visible';
    
    // Create arrowhead marker definition
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
    marker.setAttribute('id', 'arrowhead-' + arrowData.id);
    marker.setAttribute('markerWidth', '10');
    marker.setAttribute('markerHeight', '10');
    marker.setAttribute('refX', '9');
    marker.setAttribute('refY', '3');
    marker.setAttribute('orient', 'auto');
    
    const arrowheadPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    arrowheadPath.setAttribute('points', '0 0, 10 3, 0 6');
    arrowheadPath.setAttribute('fill', arrowData.color);
    marker.appendChild(arrowheadPath);
    defs.appendChild(marker);
    svg.appendChild(defs);
    
    // Adjust coordinates relative to wrapper
    const relStartX = arrowData.startPoint.x - minX + padding;
    const relStartY = arrowData.startPoint.y - minY + padding;
    const relEndX = arrowData.endPoint.x - minX + padding;
    const relEndY = arrowData.endPoint.y - minY + padding;
    
    // Create arrow path based on type
    let path;
    if (arrowData.type === 'straight') {
        path = createStraightArrowPath(relStartX, relStartY, relEndX, relEndY, arrowData.color, arrowData.strokeWidth, arrowData.id);
    } else if (arrowData.type === 'bent') {
        path = createBentArrowPath(relStartX, relStartY, relEndX, relEndY, arrowData.color, arrowData.strokeWidth, arrowData.id);
    } else if (arrowData.type === 'curved') {
        path = createCurvedArrowPath(relStartX, relStartY, relEndX, relEndY, arrowData.color, arrowData.strokeWidth, arrowData.id);
    } else {
        path = createStraightArrowPath(relStartX, relStartY, relEndX, relEndY, arrowData.color, arrowData.strokeWidth, arrowData.id);
    }
    
    svg.appendChild(path);
    wrapper.appendChild(svg);
    
    // Add endpoint handles for resizing (BIGGER and more visible)
    const startHandle = document.createElement('div');
    startHandle.className = 'arrow-handle arrow-start-handle';
    startHandle.dataset.handleType = 'start';
    startHandle.style.cssText = `position: absolute; width: 20px; height: 20px; background: #3B82F6; border: 3px solid white; border-radius: 50%; cursor: grab; left: ${relStartX - 10}px; top: ${relStartY - 10}px; z-index: 100; box-shadow: 0 2px 6px rgba(0,0,0,0.3);`;
    startHandle.title = '–ù–∞—á–∞–ª–æ —Å—Ç—Ä–µ–ª–∫–∏';
    wrapper.appendChild(startHandle);
    
    const endHandle = document.createElement('div');
    endHandle.className = 'arrow-handle arrow-end-handle';
    endHandle.dataset.handleType = 'end';
    endHandle.style.cssText = `position: absolute; width: 20px; height: 20px; background: #EF4444; border: 3px solid white; border-radius: 50%; cursor: grab; left: ${relEndX - 10}px; top: ${relEndY - 10}px; z-index: 100; box-shadow: 0 2px 6px rgba(0,0,0,0.3);`;
    endHandle.title = '–ö–æ–Ω–µ—Ü —Å—Ç—Ä–µ–ª–∫–∏';
    wrapper.appendChild(endHandle);
    
    return wrapper;
}

function createStraightArrowPath(startX, startY, endX, endY, color, strokeWidth, arrowId) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', startX);
    line.setAttribute('y1', startY);
    line.setAttribute('x2', endX);
    line.setAttribute('y2', endY);
    line.setAttribute('stroke', color);
    line.setAttribute('stroke-width', strokeWidth);
    line.setAttribute('marker-end', 'url(#arrowhead-' + arrowId + ')');
    return line;
}

function createBentArrowPath(startX, startY, endX, endY, color, strokeWidth, arrowId) {
    const midX = (startX + endX) / 2;
    const pathData = `M ${startX},${startY} L ${midX},${startY} L ${midX},${endY} L ${endX},${endY}`;
    
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathData);
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width', strokeWidth);
    path.setAttribute('fill', 'none');
    path.setAttribute('marker-end', 'url(#arrowhead-' + arrowId + ')');
    return path;
}

function createCurvedArrowPath(startX, startY, endX, endY, color, strokeWidth, arrowId) {
    const controlX = (startX + endX) / 2;
    const controlY = startY - 50; // Curve upward
    const pathData = `M ${startX},${startY} Q ${controlX},${controlY} ${endX},${endY}`;
    
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathData);
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width', strokeWidth);
    path.setAttribute('fill', 'none');
    path.setAttribute('marker-end', 'url(#arrowhead-' + arrowId + ')');
    return path;
}

// Arrow selection and interaction
let selectedArrowId = null;

function selectArrow(arrowId) {
    // Deselect previous
    if (selectedArrowId) {
        const prevWrapper = document.querySelector(`.arrow-wrapper[data-arrow-id="${selectedArrowId}"]`);
        if (prevWrapper) {
            prevWrapper.classList.remove('selected');
            prevWrapper.style.outline = '';
        }
    }
    
    selectedArrowId = arrowId;
    const wrapper = document.querySelector(`.arrow-wrapper[data-arrow-id="${arrowId}"]`);
    if (wrapper) {
        wrapper.classList.add('selected');
        wrapper.style.outline = '2px solid #F97316';
        wrapper.style.outlineOffset = '2px';
    }
    
    // Show delete option
    showArrowControls(arrowId);
}

function deselectArrow() {
    if (selectedArrowId) {
        const wrapper = document.querySelector(`.arrow-wrapper[data-arrow-id="${selectedArrowId}"]`);
        if (wrapper) {
            wrapper.classList.remove('selected');
            wrapper.style.outline = '';
        }
    }
    selectedArrowId = null;
    hideArrowControls();
}

function showArrowControls(arrowId) {
    // Create or show delete button near the arrow
    let controls = document.getElementById('arrowControls');
    if (!controls) {
        controls = document.createElement('div');
        controls.id = 'arrowControls';
        controls.style.cssText = 'position: fixed; background: white; border-radius: 8px; padding: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; display: flex; gap: 8px;';
        controls.innerHTML = `
            <button onclick="deleteSelectedArrow()" class="px-3 py-1.5 bg-red-500 text-white rounded text-sm hover:bg-red-600">üóë –£–¥–∞–ª–∏—Ç—å</button>
            <button onclick="deselectArrow()" class="px-3 py-1.5 bg-gray-300 text-gray-700 rounded text-sm hover:bg-gray-400">‚úï –ó–∞–∫—Ä—ã—Ç—å</button>
        `;
        document.body.appendChild(controls);
    }
    
    // Position near the arrow
    const wrapper = document.querySelector(`.arrow-wrapper[data-arrow-id="${arrowId}"]`);
    if (wrapper) {
        const rect = wrapper.getBoundingClientRect();
        controls.style.left = rect.right + 10 + 'px';
        controls.style.top = rect.top + 'px';
        controls.style.display = 'flex';
    }
}

function hideArrowControls() {
    const controls = document.getElementById('arrowControls');
    if (controls) {
        controls.style.display = 'none';
    }
}

function deleteSelectedArrow() {
    if (selectedArrowId) {
        removeArrow(selectedArrowId);
        hideArrowControls();
        selectedArrowId = null;
        renderPreviewArrows();
    }
}

// Accent Box management functions
let editingAccentBoxId = null;
let accentFormatState = { bold: false, italic: false, underline: false };

function updateAccentTextPreview() {
    const textDiv = document.getElementById('accentText');
    if (!textDiv) return;
    
    const fontFamily = document.getElementById('accentFontFamily').value;
    const fontSize = document.getElementById('accentFontSize').value;
    const textColor = document.getElementById('accentTextColor').value;
    const bgColor = document.getElementById('accentBgColor').value;
    const borderColor = document.getElementById('accentBorderColor').value;
    
    textDiv.style.fontFamily = fontFamily + ', sans-serif';
    textDiv.style.fontSize = fontSize + 'px';
    textDiv.style.color = textColor;
    textDiv.style.backgroundColor = bgColor;
    textDiv.style.borderColor = borderColor;
}

function toggleAccentFormat(format) {
    // Apply formatting to selected text using execCommand
    const textDiv = document.getElementById('accentText');
    textDiv.focus();
    
    const commandMap = {
        'bold': 'bold',
        'italic': 'italic',
        'underline': 'underline'
    };
    
    document.execCommand(commandMap[format], false, null);
    
    // Update button state based on current selection
    updateAccentFormatButtonStates();
}

function updateAccentFormatButtonStates() {
    const formats = ['bold', 'italic', 'underline'];
    formats.forEach(format => {
        const isActive = document.queryCommandState(format);
        const btn = document.getElementById('accent' + format.charAt(0).toUpperCase() + format.slice(1));
        if (btn) {
            if (isActive) {
                btn.classList.add('bg-blue-100', 'border-blue-500');
            } else {
                btn.classList.remove('bg-blue-100', 'border-blue-500');
            }
        }
    });
}

function resetAccentFormatButtons() {
    accentFormatState = { bold: false, italic: false, underline: false };
    ['Bold', 'Italic', 'Underline'].forEach(format => {
        const btn = document.getElementById('accent' + format);
        if (btn) {
            btn.classList.remove('bg-blue-100', 'border-blue-500');
        }
    });
}

function setAccentFormatButtons(formatting) {
    accentFormatState = { 
        bold: formatting?.bold || false, 
        italic: formatting?.italic || false, 
        underline: formatting?.underline || false 
    };
    ['Bold', 'Italic', 'Underline'].forEach(format => {
        const btn = document.getElementById('accent' + format);
        const key = format.toLowerCase();
        if (btn) {
            if (accentFormatState[key]) {
                btn.classList.add('bg-blue-100', 'border-blue-500');
            } else {
                btn.classList.remove('bg-blue-100', 'border-blue-500');
            }
        }
    });
}

function showAccentBoxModal() {
    // Reset form for new box
    editingAccentBoxId = null;
    document.getElementById('accentText').innerHTML = '';
    document.getElementById('accentX').value = '50';
    document.getElementById('accentY').value = '200';
    document.getElementById('accentWidth').value = '300';
    document.getElementById('accentHeight').value = '100';
    document.getElementById('accentBgColor').value = '#E0E7FF';
    document.getElementById('accentBorderColor').value = '#4F46E5';
    document.getElementById('accentTextColor').value = '#1E1B4B';
    document.getElementById('accentFontFamily').value = 'Arial';
    document.getElementById('accentFontSize').value = '14';
    resetAccentFormatButtons();
    
    // Update modal title and button
    document.getElementById('accentBoxModalTitle').textContent = '–ê–∫—Ü–µ–Ω—Ç–Ω—ã–π –±–ª–æ–∫';
    document.getElementById('accentBoxSubmitBtn').textContent = '–î–æ–±–∞–≤–∏—Ç—å';
    
    document.getElementById('accentBoxModal').classList.remove('hidden');
    updateAccentTextPreview();
}

function editAccentBox(boxId) {
    const boxData = getAccentBoxData(boxId);
    if (!boxData) return;
    
    editingAccentBoxId = boxId;
    
    // Populate form with existing data
    document.getElementById('accentText').innerHTML = boxData.textHtml || boxData.text || '';
    document.getElementById('accentX').value = boxData.position.x;
    document.getElementById('accentY').value = boxData.position.y;
    document.getElementById('accentWidth').value = boxData.size.width;
    document.getElementById('accentHeight').value = boxData.size.height;
    document.getElementById('accentBgColor').value = boxData.backgroundColor;
    document.getElementById('accentBorderColor').value = boxData.borderColor;
    document.getElementById('accentTextColor').value = boxData.textColor || '#1E1B4B';
    document.getElementById('accentFontFamily').value = boxData.fontFamily || 'Arial';
    document.getElementById('accentFontSize').value = boxData.fontSize || 14;
    resetAccentFormatButtons();
    
    // Update modal title and button for edit mode
    document.getElementById('accentBoxModalTitle').textContent = '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –±–ª–æ–∫';
    document.getElementById('accentBoxSubmitBtn').textContent = '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å';
    
    document.getElementById('accentBoxModal').classList.remove('hidden');
    updateAccentTextPreview();
}

function closeAccentBoxModal() {
    document.getElementById('accentBoxModal').classList.add('hidden');
    editingAccentBoxId = null;
    resetAccentFormatButtons();
}

function saveAccentBox() {
    const textDiv = document.getElementById('accentText');
    const textHtml = textDiv.innerHTML;
    const textPlain = textDiv.innerText || textDiv.textContent;
    
    if (editingAccentBoxId) {
        // Update existing box
        const boxData = getAccentBoxData(editingAccentBoxId);
        if (boxData) {
            boxData.text = textPlain;
            boxData.textHtml = textHtml;
            boxData.position.x = parseInt(document.getElementById('accentX').value);
            boxData.position.y = parseInt(document.getElementById('accentY').value);
            boxData.size.width = parseInt(document.getElementById('accentWidth').value);
            boxData.size.height = parseInt(document.getElementById('accentHeight').value);
            boxData.backgroundColor = document.getElementById('accentBgColor').value;
            boxData.borderColor = document.getElementById('accentBorderColor').value;
            boxData.textColor = document.getElementById('accentTextColor').value;
            boxData.fontFamily = document.getElementById('accentFontFamily').value;
            boxData.fontSize = parseInt(document.getElementById('accentFontSize').value);
        }
    } else {
        // Add new box
        const box = {
            id: 'accent_' + Date.now(),
            text: textPlain,
            textHtml: textHtml,
            position: {
                x: parseInt(document.getElementById('accentX').value),
                y: parseInt(document.getElementById('accentY').value)
            },
            size: {
                width: parseInt(document.getElementById('accentWidth').value),
                height: parseInt(document.getElementById('accentHeight').value)
            },
            backgroundColor: document.getElementById('accentBgColor').value,
            borderColor: document.getElementById('accentBorderColor').value,
            borderWidth: 2,
            textColor: document.getElementById('accentTextColor').value,
            fontFamily: document.getElementById('accentFontFamily').value,
            fontSize: parseInt(document.getElementById('accentFontSize').value)
        };
        
        if (!slides[currentSlideIndex].accentBoxes) {
            slides[currentSlideIndex].accentBoxes = [];
        }
        slides[currentSlideIndex].accentBoxes.push(box);
    }
    
    updateAccentBoxesList();
    renderPreviewAccentBoxes();
    closeAccentBoxModal();
    debouncedSave();
}

function removeAccentBox(boxId) {
    slides[currentSlideIndex].accentBoxes = slides[currentSlideIndex].accentBoxes.filter(box => box.id !== boxId);
    updateAccentBoxesList();
    renderPreviewAccentBoxes();
    debouncedSave();
}

function updateAccentBoxesList() {
    const container = document.getElementById('accentBoxesList');
    const boxes = slides[currentSlideIndex].accentBoxes || [];
    
    if (boxes.length === 0) {
        container.innerHTML = '<div class="text-xs text-gray-500 p-2">–ù–µ—Ç –∞–∫—Ü–µ–Ω—Ç–Ω—ã—Ö –±–ª–æ–∫–æ–≤</div>';
        return;
    }
    
    container.innerHTML = boxes.map(box => {
        const plainText = box.text || '';
        const preview = plainText.substring(0, 20);
        return `
            <div class="flex items-center justify-between p-2 bg-gray-50 rounded text-xs">
                <span>–ë–ª–æ–∫: ${preview}${plainText.length > 20 ? '...' : ''}</span>
                <button onclick="removeAccentBox('${box.id}')" class="text-red-500 hover:text-red-700 ml-2">‚úï</button>
            </div>
        `;
    }).join('');
}

// Render accent boxes on preview
function renderPreviewAccentBoxes() {
    const boxes = slides[currentSlideIndex].accentBoxes || [];
    const container = document.getElementById('previewAccentBoxes');
    
    // Clear existing boxes
    container.innerHTML = '';
    
    // Render all accent boxes
    boxes.forEach(box => {
        const wrapper = createAccentBoxWrapper(box);
        container.appendChild(wrapper);
    });
    
    // Initialize Interact.js on all new accent box wrappers
    setTimeout(() => {
        if (typeof interact !== 'undefined') {
            initializeAccentBoxInteractions();
        }
    }, 50);
}

function createAccentBoxWrapper(boxData) {
    const wrapper = document.createElement('div');
    wrapper.className = 'accent-box-wrapper';
    wrapper.dataset.boxId = boxData.id;
    wrapper.style.cssText = `
        position: absolute;
        left: ${boxData.position.x}px;
        top: ${boxData.position.y}px;
        width: ${boxData.size.width}px;
        height: ${boxData.size.height}px;
        background-color: ${boxData.backgroundColor};
        border: ${boxData.borderWidth || 2}px solid ${boxData.borderColor};
        border-radius: 8px;
        cursor: move;
        pointer-events: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 8px;
        box-sizing: border-box;
        overflow: hidden;
    `;
    
    // Text content
    const textEl = document.createElement('div');
    textEl.style.cssText = `
        color: ${boxData.textColor || '#1E1B4B'};
        font-size: ${boxData.fontSize || 14}px;
        font-family: ${boxData.fontFamily || 'Arial'}, sans-serif;
        line-height: 1.3;
        word-wrap: break-word;
        overflow-wrap: break-word;
    `;
    // Use HTML content if available, otherwise plain text
    if (boxData.textHtml) {
        textEl.innerHTML = boxData.textHtml;
    } else {
        textEl.textContent = boxData.text;
    }
    wrapper.appendChild(textEl);
    
    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'accent-box-delete';
    deleteBtn.innerHTML = '‚úï';
    deleteBtn.style.cssText = `
        position: absolute;
        top: -8px;
        right: -8px;
        width: 20px;
        height: 20px;
        background: #ef4444;
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.2s;
    `;
    deleteBtn.onclick = (e) => {
        e.stopPropagation();
        removeAccentBox(boxData.id);
        renderPreviewAccentBoxes();
        debouncedSave();
    };
    wrapper.appendChild(deleteBtn);
    
    // Show delete on hover
    wrapper.addEventListener('mouseenter', () => {
        deleteBtn.style.opacity = '1';
    });
    wrapper.addEventListener('mouseleave', () => {
        deleteBtn.style.opacity = '0';
    });
    
    // Click to select
    wrapper.onclick = function(e) {
        e.stopPropagation();
        selectAccentBox(boxData.id);
    };
    
    // Double-click to edit
    wrapper.ondblclick = function(e) {
        e.stopPropagation();
        editAccentBox(boxData.id);
    };
    
    return wrapper;
}

let selectedAccentBoxId = null;

function selectAccentBox(boxId) {
    deselectAllAccentBoxes();
    deselectAllImages();
    deselectAllTables();
    
    const wrapper = document.querySelector(`.accent-box-wrapper[data-box-id="${boxId}"]`);
    if (wrapper) {
        wrapper.classList.add('selected');
        wrapper.style.outline = '2px solid #8B5CF6';
        wrapper.style.outlineOffset = '2px';
        selectedAccentBoxId = boxId;
    }
}

function deselectAllAccentBoxes() {
    document.querySelectorAll('.accent-box-wrapper.selected').forEach(el => {
        el.classList.remove('selected');
        el.style.outline = '';
        el.style.outlineOffset = '';
    });
    selectedAccentBoxId = null;
}

function getAccentBoxData(boxId) {
    const boxes = slides[currentSlideIndex].accentBoxes || [];
    return boxes.find(b => b.id === boxId);
}

function initializeAccentBoxInteractions() {
    interact('.accent-box-wrapper').draggable({
        inertia: false,
        modifiers: [
            interact.modifiers.restrictRect({
                restriction: 'parent',
                endOnly: false
            })
        ],
        listeners: {
            move(event) {
                const target = event.target;
                const boxId = target.dataset.boxId;
                const boxData = getAccentBoxData(boxId);
                if (!boxData) return;
                
                boxData.position.x += event.dx;
                boxData.position.y += event.dy;
                
                target.style.left = `${boxData.position.x}px`;
                target.style.top = `${boxData.position.y}px`;
            },
            end() {
                debouncedSave();
            }
        }
    }).resizable({
        edges: { left: true, right: true, bottom: true, top: true },
        listeners: {
            move(event) {
                const target = event.target;
                const boxId = target.dataset.boxId;
                const boxData = getAccentBoxData(boxId);
                if (!boxData) return;
                
                let { x, y } = boxData.position;
                
                x += event.deltaRect.left;
                y += event.deltaRect.top;
                
                boxData.position.x = x;
                boxData.position.y = y;
                boxData.size.width = Math.max(50, event.rect.width);
                boxData.size.height = Math.max(30, event.rect.height);
                
                target.style.left = `${x}px`;
                target.style.top = `${y}px`;
                target.style.width = `${boxData.size.width}px`;
                target.style.height = `${boxData.size.height}px`;
            },
            end() {
                debouncedSave();
            }
        },
        modifiers: [
            interact.modifiers.restrictSize({
                min: { width: 50, height: 30 }
            })
        ]
    });
}

// =============================================
// TEXT BLOCKS MANAGEMENT
// =============================================

const textBlockDefaults = {
    header: {
        text: '–ó–∞–≥–æ–ª–æ–≤–æ–∫',
        fontSize: 32,
        fontFamily: 'Arial',
        fontWeight: 'bold',
        color: '#111827',
        bgColor: 'transparent',
        width: 400,
        height: 50
    },
    text: {
        text: '–û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç',
        fontSize: 18,
        fontFamily: 'Arial',
        fontWeight: 'normal',
        color: '#374151',
        bgColor: 'transparent',
        width: 300,
        height: 80
    },
    comment: {
        text: '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π',
        fontSize: 14,
        fontFamily: 'Arial',
        fontWeight: 'normal',
        color: '#6B7280',
        bgColor: '#F3F4F6',
        width: 250,
        height: 60
    }
};

function addTextBlock(type) {
    const defaults = textBlockDefaults[type] || textBlockDefaults.text;
    
    const block = {
        id: 'txtblk_' + Date.now(),
        type: type,
        text: defaults.text,
        position: { x: 50, y: type === 'header' ? 30 : type === 'comment' ? 300 : 100 },
        size: { width: defaults.width, height: defaults.height },
        fontSize: defaults.fontSize,
        fontFamily: defaults.fontFamily,
        fontWeight: defaults.fontWeight,
        color: defaults.color,
        bgColor: defaults.bgColor
    };
    
    if (!slides[currentSlideIndex].textBlocks) {
        slides[currentSlideIndex].textBlocks = [];
    }
    slides[currentSlideIndex].textBlocks.push(block);
    
    updateTextBlocksList();
    renderPreviewTextBlocks();
    saveSlides();
}

function removeTextBlock(blockId) {
    slides[currentSlideIndex].textBlocks = (slides[currentSlideIndex].textBlocks || []).filter(b => b.id !== blockId);
    updateTextBlocksList();
    renderPreviewTextBlocks();
    saveSlides();
}

function updateTextBlocksList() {
    const container = document.getElementById('textBlocksList');
    if (!container) return;
    
    const blocks = slides[currentSlideIndex].textBlocks || [];
    
    if (blocks.length === 0) {
        container.innerHTML = '<div class="text-xs text-gray-500 p-2">–ù–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –±–ª–æ–∫–æ–≤</div>';
        return;
    }
    
    const typeLabels = { header: '–ó–∞–≥–æ–ª–æ–≤–æ–∫', text: '–¢–µ–∫—Å—Ç', comment: '–ö–æ–º–º–µ–Ω—Ç.' };
    
    container.innerHTML = blocks.map(block => `
        <div class="flex items-center justify-between p-2 bg-gray-50 rounded text-xs">
            <span>${typeLabels[block.type] || '–ë–ª–æ–∫'}: ${(block.text || '').substring(0, 15)}${(block.text || '').length > 15 ? '...' : ''}</span>
            <button onclick="removeTextBlock('${block.id}')" class="text-red-500 hover:text-red-700 ml-2">‚úï</button>
        </div>
    `).join('');
}

function renderPreviewTextBlocks() {
    const blocks = slides[currentSlideIndex].textBlocks || [];
    
    // Get or create text blocks container
    let container = document.getElementById('previewTextBlocks');
    if (!container) {
        const preview = document.getElementById('slidePreview');
        container = document.createElement('div');
        container.id = 'previewTextBlocks';
        container.style.cssText = 'position: absolute; inset: 0; z-index: 14; pointer-events: none;';
        preview.appendChild(container);
    }
    
    container.innerHTML = '';
    
    blocks.forEach(block => {
        const wrapper = createTextBlockWrapper(block);
        container.appendChild(wrapper);
    });
    
    // Initialize drag/resize
    setTimeout(() => {
        if (typeof interact !== 'undefined') {
            initializeTextBlockInteractions();
        }
    }, 50);
}

function createTextBlockWrapper(blockData) {
    const wrapper = document.createElement('div');
    wrapper.className = 'text-block-wrapper';
    wrapper.dataset.blockId = blockData.id;
    wrapper.style.cssText = `
        position: absolute;
        left: ${blockData.position.x}px;
        top: ${blockData.position.y}px;
        width: ${blockData.size.width}px;
        min-height: ${blockData.size.height}px;
        background-color: ${blockData.bgColor === 'transparent' ? 'transparent' : blockData.bgColor};
        cursor: move;
        pointer-events: auto;
        padding: 8px;
        box-sizing: border-box;
        border: 1px dashed transparent;
        border-radius: 4px;
    `;
    
    // Editable text
    const textEl = document.createElement('div');
    textEl.contentEditable = 'true';
    textEl.style.cssText = `
        color: ${blockData.color};
        font-size: ${blockData.fontSize}px;
        font-family: ${blockData.fontFamily}, sans-serif;
        font-weight: ${blockData.fontWeight};
        line-height: 1.3;
        outline: none;
        min-height: 20px;
        width: 100%;
    `;
    textEl.innerHTML = blockData.text || '';
    textEl.oninput = function() {
        blockData.text = this.innerHTML;
        updateTextBlocksList();
        debouncedSave();
    };
    wrapper.appendChild(textEl);
    
    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.innerHTML = '‚úï';
    deleteBtn.style.cssText = `
        position: absolute;
        top: -8px;
        right: -8px;
        width: 20px;
        height: 20px;
        background: #ef4444;
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.2s;
    `;
    deleteBtn.onclick = (e) => {
        e.stopPropagation();
        removeTextBlock(blockData.id);
    };
    wrapper.appendChild(deleteBtn);
    
    // Show delete on hover and border
    wrapper.addEventListener('mouseenter', () => {
        deleteBtn.style.opacity = '1';
        wrapper.style.borderColor = '#3B82F6';
    });
    wrapper.addEventListener('mouseleave', () => {
        deleteBtn.style.opacity = '0';
        wrapper.style.borderColor = 'transparent';
    });
    
    return wrapper;
}

function initializeTextBlockInteractions() {
    interact('.text-block-wrapper').draggable({
        inertia: false,
        modifiers: [
            interact.modifiers.restrictRect({
                restriction: 'parent',
                endOnly: false
            })
        ],
        listeners: {
            move(event) {
                const target = event.target;
                const blockId = target.dataset.blockId;
                const blockData = getTextBlockData(blockId);
                if (!blockData) return;
                
                blockData.position.x += event.dx;
                blockData.position.y += event.dy;
                
                target.style.left = `${blockData.position.x}px`;
                target.style.top = `${blockData.position.y}px`;
            },
            end() {
                debouncedSave();
            }
        }
    }).resizable({
        edges: { left: true, right: true, bottom: true, top: true },
        listeners: {
            move(event) {
                const target = event.target;
                const blockId = target.dataset.blockId;
                const blockData = getTextBlockData(blockId);
                if (!blockData) return;
                
                blockData.size.width = event.rect.width;
                blockData.size.height = event.rect.height;
                blockData.position.x += event.deltaRect.left;
                blockData.position.y += event.deltaRect.top;
                
                target.style.width = `${blockData.size.width}px`;
                target.style.minHeight = `${blockData.size.height}px`;
                target.style.left = `${blockData.position.x}px`;
                target.style.top = `${blockData.position.y}px`;
            },
            end() {
                debouncedSave();
            }
        },
        modifiers: [
            interact.modifiers.restrictSize({
                min: { width: 50, height: 20 }
            })
        ]
    });
}

function getTextBlockData(blockId) {
    const blocks = slides[currentSlideIndex].textBlocks || [];
    return blocks.find(b => b.id === blockId);
}

// Drag and drop setup for slide preview
function setupPreviewDragDrop() {
    const preview = document.getElementById('slidePreview');
    
    preview.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        preview.classList.add('border-blue-500', 'bg-blue-50');
    });
    
    preview.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        preview.classList.remove('border-blue-500', 'bg-blue-50');
    });
    
    preview.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        preview.classList.remove('border-blue-500', 'bg-blue-50');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            // Get drop position relative to preview
            const rect = preview.getBoundingClientRect();
            const x = Math.round(e.clientX - rect.left);
            const y = Math.round(e.clientY - rect.top);
            
            // Process first file
            const file = files[0];
            if (validateImageFile(file)) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const dataUrl = event.target.result;
                    
                    // Load image to get dimensions
                    const img = new Image();
                    img.onload = function() {
                        const aspectRatio = this.naturalWidth / this.naturalHeight;
                        const defaultWidth = 200;
                        const defaultHeight = Math.round(defaultWidth / aspectRatio);
                        
                        // Add image directly to slide
                        const imageData = {
                            id: 'img_' + Date.now(),
                            url: dataUrl,
                            position: { x: x, y: y },
                            size: { width: defaultWidth, height: defaultHeight },
                            rotation: 0,
                            aspectRatio: aspectRatio,
                            aspectLocked: true
                        };
                        
                        if (!slides[currentSlideIndex].images) {
                            slides[currentSlideIndex].images = [];
                        }
                        slides[currentSlideIndex].images.push(imageData);
                        
                        updateImagesList();
                        updateSlidePreview();
                    };
                    img.src = dataUrl;
                };
                reader.readAsDataURL(file);
            }
        }
    });
}

// File input handlers setup
function setupFileInputHandlers() {
    // Drop zone click handler
    const dropZone = document.getElementById('dropZone');
    const dropZoneInput = document.getElementById('dropZoneFileInput');
    
    if (dropZone && dropZoneInput) {
        dropZone.addEventListener('click', () => {
            dropZoneInput.click();
        });
        
        dropZoneInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                processImageFile(file);
                document.getElementById('dropZoneFileName').textContent = `Selected: ${file.name}`;
                document.getElementById('dropZoneFileName').classList.remove('hidden');
            }
        });
    }
    
    // Upload file input handler
    const fileUploadInput = document.getElementById('fileUploadInput');
    if (fileUploadInput) {
        fileUploadInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processImageFile(e.target.files[0]);
            }
        });
    }
    
    // Drop zone drag and drop
    if (dropZone) {
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('border-blue-500', 'bg-blue-100');
        });
        
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('border-blue-500', 'bg-blue-100');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('border-blue-500', 'bg-blue-100');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                processImageFile(file);
                document.getElementById('dropZoneFileName').textContent = `Selected: ${file.name}`;
                document.getElementById('dropZoneFileName').classList.remove('hidden');
                
                // Update the file input
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                dropZoneInput.files = dataTransfer.files;
            }
        });
    }
}

// UI Helper Functions for Save Status
function updateLastSavedIndicator() {
    const statusText = document.getElementById('saveStatusText');
    if (!statusText) return;
    
    if (lastSavedTime) {
        const now = new Date();
        const diffMs = now - lastSavedTime;
        const diffMins = Math.floor(diffMs / 60000);
        
        if (diffMins < 1) {
            statusText.textContent = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ —Ç–æ–ª—å–∫–æ —á—Ç–æ';
            statusText.className = 'text-green-600';
        } else if (diffMins < 5) {
            statusText.textContent = `–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ ${diffMins} –º–∏–Ω –Ω–∞–∑–∞–¥`;
            statusText.className = 'text-green-600';
        } else {
            statusText.textContent = `–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ ${diffMins} –º–∏–Ω –Ω–∞–∑–∞–¥`;
            statusText.className = 'text-gray-600';
        }
    }
}

function updateSavingIndicator(saving) {
    const statusText = document.getElementById('saveStatusText');
    const saveBtn = document.getElementById('manualSaveBtn');
    
    if (saving) {
        statusText.textContent = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...';
        statusText.className = 'text-blue-600';
        if (saveBtn) saveBtn.disabled = true;
    } else {
        if (saveBtn) saveBtn.disabled = false;
        updateLastSavedIndicator();
    }
}

function showSaveError() {
    const statusText = document.getElementById('saveStatusText');
    if (statusText) {
        statusText.textContent = '‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è';
        statusText.className = 'text-red-600';
    }
}

function showLocalStorageFallbackWarning() {
    // Create warning banner if it doesn't exist
    if (!document.getElementById('localStorageWarning')) {
        const banner = document.createElement('div');
        banner.id = 'localStorageWarning';
        banner.className = 'bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-4';
        banner.innerHTML = `
            <div class="flex">
                <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                    </svg>
                </div>
                <div class="ml-3">
                    <p class="text-sm text-yellow-700">
                        ‚ö†Ô∏è –ó–∞–≥—Ä—É–∂–µ–Ω–æ –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∫—ç—à–∞ - –¥–∞–Ω–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã. –ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω–æ.
                    </p>
                </div>
                <div class="ml-auto pl-3">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" class="text-yellow-700 hover:text-yellow-900">
                        <span class="sr-only">Dismiss</span>
                        <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                        </svg>
                    </button>
                </div>
            </div>
        `;
        document.querySelector('.mx-auto.px-4').insertBefore(banner, document.querySelector('.mb-6'));
    }
}

function showMergeWarning(backendSlides) {
    // Store backend slides for potential merge
    window.backendSlidesForMerge = backendSlides;
    
    // Show merge dialog (simplified version)
    console.log('Merge conflict detected. localStorage is newer than backend.');
    console.log('Using localStorage data. Backend data available in window.backendSlidesForMerge');
}

// Update save indicator periodically
setInterval(() => {
    if (lastSavedTime) {
        updateLastSavedIndicator();
    }
}, 60000); // Every minute

// Trigger auto-save on important actions
</script>
<script>
// ===== Interactive Image Manipulation Module =====
// Handles selection, drag, resize with Interact.js

let selectedImageId = null;
const dimensionTooltip = document.getElementById('dimensionTooltip');

// Debounce utility
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Save slide data after interactions (debounced)
const debouncedSave = debounce(() => {
    saveCurrentSlide();
    updateImagesList();
}, 500);

// Selection management
function selectImage(imageId) {
    console.log('selectImage called for:', imageId);
    // Deselect all first
    deselectAllImages();
    
    // Select the clicked image
    const wrapper = document.querySelector(`.image-wrapper[data-image-id="${imageId}"]`);
    console.log('Found wrapper:', wrapper);
    if (wrapper) {
        wrapper.classList.add('selected');
        selectedImageId = imageId;
        console.log('Image selected, selectedImageId:', selectedImageId);
    } else {
        console.error('Wrapper not found for imageId:', imageId);
    }
}

function deselectAllImages() {
    document.querySelectorAll('.image-wrapper.selected').forEach(wrapper => {
        wrapper.classList.remove('selected');
    });
    selectedImageId = null;
}

// Click handler for slide preview - handles deselection
function handleSlidePreviewClick(e) {
    // If clicked on an image wrapper or click target, let it handle itself
    if (e.target.closest('.image-wrapper') || e.target.closest('.bg-image-click-target')) {
        return;
    }
    
    // If clicked on a table wrapper, let it handle itself
    if (e.target.closest('.table-wrapper')) {
        return;
    }
    
    // Click on text or empty area - deselect images and tables
    deselectAllImages();
    deselectAllTables();
}

// Initialize Interact.js on all image wrappers
let isRotating = false; // Flag to prevent resize during rotation

function initializeImageInteractions() {
    // Check if Interact.js is loaded
    if (typeof interact === 'undefined') {
        console.error('Interact.js not loaded yet');
        return;
    }
    
    const wrappers = document.querySelectorAll('.image-wrapper');
    console.log('Initializing Interact.js on', wrappers.length, 'image wrappers');
    
    wrappers.forEach(wrapper => {
        const imageId = wrapper.dataset.imageId;
        const imageData = getImageData(imageId);
        
        if (!imageData) return;
        
        // Store original dimensions for rotation
        wrapper.dataset.origWidth = imageData.size.width;
        wrapper.dataset.origHeight = imageData.size.height;
        
        // Configure draggable
        interact(wrapper)
            .draggable({
                inertia: false,
                // Ignore drags starting on rotation/resize handles
                ignoreFrom: '.rotate-handle, .resize-handle',
                modifiers: [
                    interact.modifiers.restrictRect({
                        restriction: 'parent',
                        endOnly: true
                    })
                ],
                listeners: {
                    start: (event) => {
                        // Don't start drag if rotating
                        if (isRotating) return;
                        event.target.classList.add('dragging');
                    },
                    move: (event) => {
                        if (isRotating) return;
                        const target = event.target;
                        const imageData = getImageData(imageId);
                        
                        // Update position
                        const x = (parseFloat(target.style.left) || 0) + event.dx;
                        const y = (parseFloat(target.style.top) || 0) + event.dy;
                        
                        target.style.left = `${x}px`;
                        target.style.top = `${y}px`;
                        
                        // CRITICAL: Preserve rotation during drag
                        const rotation = parseFloat(target.dataset.rotation) || 0;
                        if (rotation !== 0) {
                            target.style.transform = `rotate(${rotation}deg)`;
                        }
                        
                        // Update data model
                        if (imageData) {
                            imageData.position.x = Math.round(x);
                            imageData.position.y = Math.round(y);
                        }
                        
                        // Show position tooltip
                        showDimensionTooltip(
                            event.clientX + 10,
                            event.clientY + 10,
                            `X: ${Math.round(x)}px, Y: ${Math.round(y)}px`
                        );
                    },
                    end: (event) => {
                        event.target.classList.remove('dragging');
                        hideDimensionTooltip();
                        if (!isRotating) debouncedSave();
                    }
                }
            })
            .resizable({
                edges: { left: '.resize-handle.left, .resize-handle.bottom-left, .resize-handle.top-left', 
                         right: '.resize-handle.right, .resize-handle.bottom-right, .resize-handle.top-right', 
                         bottom: '.resize-handle.bottom, .resize-handle.bottom-left, .resize-handle.bottom-right', 
                         top: '.resize-handle.top, .resize-handle.top-left, .resize-handle.top-right' },
                modifiers: [
                    interact.modifiers.restrictSize({
                        min: { width: 20, height: 20 }
                    }),
                    // Apply aspect ratio modifier if locked
                    ...(imageData.aspectLocked !== false ? [
                        interact.modifiers.aspectRatio({
                            ratio: imageData.aspectRatio || (imageData.size.width / imageData.size.height),
                            modifiers: [interact.modifiers.restrictSize({ min: { width: 20, height: 20 } })]
                        })
                    ] : [])
                ],
                listeners: {
                    start: (event) => {
                        // Block resize if rotating
                        if (isRotating) {
                            event.preventDefault();
                            return;
                        }
                        event.target.classList.add('resizing');
                        // Initialize position data from current styles
                        const target = event.target;
                        target.dataset.x = parseFloat(target.style.left) || 0;
                        target.dataset.y = parseFloat(target.style.top) || 0;
                    },
                    move: (event) => {
                        // Skip resize if rotating
                        if (isRotating) return;
                        
                        const target = event.target;
                        const imageData = getImageData(imageId);
                        
                        let { x, y } = target.dataset;
                        x = (parseFloat(x) || 0) + event.deltaRect.left;
                        y = (parseFloat(y) || 0) + event.deltaRect.top;
                        
                        // Update element style
                        target.style.width = `${event.rect.width}px`;
                        target.style.height = `${event.rect.height}px`;
                        target.style.left = `${x}px`;
                        target.style.top = `${y}px`;
                        
                        // CRITICAL: Preserve rotation during resize
                        const rotation = parseFloat(target.dataset.rotation) || 0;
                        if (rotation !== 0) {
                            target.style.transform = `rotate(${rotation}deg)`;
                        }
                        
                        // Store position for next move
                        target.dataset.x = x;
                        target.dataset.y = y;
                        
                        // Update data model
                        if (imageData) {
                            imageData.size.width = Math.round(event.rect.width);
                            imageData.size.height = Math.round(event.rect.height);
                            imageData.position.x = Math.round(x);
                            imageData.position.y = Math.round(y);
                        }
                        
                        // Show dimension tooltip
                        showDimensionTooltip(
                            event.clientX + 10,
                            event.clientY + 10,
                            `${Math.round(event.rect.width)} √ó ${Math.round(event.rect.height)}px`
                        );
                    },
                    end: (event) => {
                        event.target.classList.remove('resizing');
                        if (isRotating) return;
                        
                        const imageData = getImageData(imageId);
                        
                        // Recalculate aspect ratio after resize
                        if (imageData) {
                            imageData.aspectRatio = imageData.size.width / imageData.size.height;
                        }
                        
                        hideDimensionTooltip();
                        debouncedSave();
                    }
                }
            });
        
        // Add rotation functionality to rotation handle
        const rotateHandle = wrapper.querySelector('.rotate-handle');
        if (rotateHandle) {
            let startAngle = 0;
            let currentRotation = parseFloat(wrapper.dataset.rotation) || 0;
            let initialSize = null; // Store initial size to prevent resize during rotation
            
            rotateHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
                e.preventDefault();
                
                // Set rotation flag to prevent resize
                isRotating = true;
                
                // Store initial size to restore if needed
                initialSize = {
                    width: parseFloat(wrapper.style.width) || imageData.size.width,
                    height: parseFloat(wrapper.style.height) || imageData.size.height
                };
                
                const rect = wrapper.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                startAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                currentRotation = parseFloat(wrapper.dataset.rotation) || 0;
                
                const onMouseMove = (e) => {
                    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                    const rotation = currentRotation + (angle - startAngle);
                    
                    // ONLY update rotation, preserve size
                    wrapper.style.transform = `rotate(${rotation}deg)`;
                    wrapper.dataset.rotation = rotation;
                    
                    // Ensure size is preserved (prevent any resize interference)
                    if (initialSize) {
                        wrapper.style.width = `${initialSize.width}px`;
                        wrapper.style.height = `${initialSize.height}px`;
                    }
                    
                    // Show rotation tooltip
                    showDimensionTooltip(
                        e.clientX + 10,
                        e.clientY + 10,
                        `${Math.round(rotation)}¬∞`
                    );
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    // Save rotation to data model
                    const imageData = getImageData(imageId);
                    if (imageData) {
                        imageData.rotation = parseFloat(wrapper.dataset.rotation) || 0;
                    }
                    
                    hideDimensionTooltip();
                    
                    // Clear rotation flag after a small delay to prevent resize from triggering
                    setTimeout(() => {
                        isRotating = false;
                    }, 50);
                    
                    debouncedSave();
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }
    });
}

// Helper to get image data from slides array
function getImageData(imageId) {
    const images = slides[currentSlideIndex]?.images || [];
    return images.find(img => img.id === imageId);
}

// Dimension tooltip functions
function showDimensionTooltip(x, y, text) {
    if (dimensionTooltip) {
        dimensionTooltip.textContent = text;
        dimensionTooltip.style.left = `${x}px`;
        dimensionTooltip.style.top = `${y}px`;
        dimensionTooltip.classList.add('active');
    }
}

function hideDimensionTooltip() {
    if (dimensionTooltip) {
        dimensionTooltip.classList.remove('active');
    }
}

// Keyboard shortcuts (optional)
document.addEventListener('keydown', (e) => {
    // Handle image shortcuts
    if (selectedImageId) {
        // Delete key - remove selected image
        if (e.key === 'Delete') {
            e.preventDefault();
            removeImage(selectedImageId);
            return;
        }
        
        // Escape key - deselect
        if (e.key === 'Escape') {
            e.preventDefault();
            deselectAllImages();
            return;
        }
        
        // Arrow keys - nudge position
        const imageData = getImageData(selectedImageId);
        if (imageData && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
            const step = e.shiftKey ? 10 : 1;
            
            switch(e.key) {
                case 'ArrowUp':
                    imageData.position.y = Math.max(0, imageData.position.y - step);
                    break;
                case 'ArrowDown':
                    imageData.position.y += step;
                    break;
                case 'ArrowLeft':
                    imageData.position.x = Math.max(0, imageData.position.x - step);
                    break;
                case 'ArrowRight':
                    imageData.position.x += step;
                    break;
            }
            
            // Update visual
            const wrapper = document.querySelector(`.image-wrapper[data-image-id="${selectedImageId}"]`);
            if (wrapper) {
                wrapper.style.left = `${imageData.position.x}px`;
                wrapper.style.top = `${imageData.position.y}px`;
            }
            
            debouncedSave();
        }
        return;
    }
    
    // Handle table shortcuts
    if (selectedTableId) {
        // Delete key - remove selected table
        if (e.key === 'Delete') {
            e.preventDefault();
            removeTable(selectedTableId);
            return;
        }
        
        // Escape key - deselect
        if (e.key === 'Escape') {
            e.preventDefault();
            deselectAllTables();
            return;
        }
        
        // Arrow keys - nudge position
        const tableData = getTableData(selectedTableId);
        if (tableData && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
            const step = e.shiftKey ? 10 : 1;
            
            switch(e.key) {
                case 'ArrowUp':
                    tableData.position.y = Math.max(0, tableData.position.y - step);
                    break;
                case 'ArrowDown':
                    tableData.position.y += step;
                    break;
                case 'ArrowLeft':
                    tableData.position.x = Math.max(0, tableData.position.x - step);
                    break;
                case 'ArrowRight':
                    tableData.position.x += step;
                    break;
            }
            
            // Update visual
            const wrapper = document.querySelector(`.table-wrapper[data-table-id="${selectedTableId}"]`);
            if (wrapper) {
                wrapper.style.left = `${tableData.position.x}px`;
                wrapper.style.top = `${tableData.position.y}px`;
            }
            
            debouncedSave();
        }
    }
});
</script>

<!-- PDF Generation Functions -->
<script>
// PDF generation state
let pdfGenerationCancelled = false;

// Modal controls
function openDownloadModal() {
    saveCurrentSlide();
    pdfGenerationCancelled = false;
    document.getElementById('downloadModal').classList.remove('hidden');
    document.getElementById('downloadProgress').classList.add('hidden');
    document.getElementById('downloadOptions').classList.remove('hidden');
}

function closeDownloadModal() {
    document.getElementById('downloadModal').classList.add('hidden');
    document.getElementById('pdfLoadingOverlay').classList.add('hidden');
}

function cancelDownload() {
    pdfGenerationCancelled = true;
    closeDownloadModal();
}

function showLoadingOverlay(text, percent) {
    const overlay = document.getElementById('pdfLoadingOverlay');
    overlay.classList.remove('hidden');
    document.getElementById('pdfLoadingText').textContent = text;
    document.getElementById('pdfLoadingProgress').style.width = percent + '%';
}

function hideLoadingOverlay() {
    document.getElementById('pdfLoadingOverlay').classList.add('hidden');
}

// Create offscreen preview element for a specific slide
function createOffscreenSlidePreview(slideData, previewWidth, previewHeight) {
    const container = document.createElement('div');
    container.style.cssText = `
        position: fixed;
        left: -9999px;
        top: 0;
        width: ${previewWidth}px;
        height: ${previewHeight}px;
        overflow: hidden;
        z-index: -1;
    `;
    
    // Create preview structure
    const preview = document.createElement('div');
    preview.style.cssText = `
        width: ${previewWidth}px;
        height: ${previewHeight}px;
        position: relative;
        background: #FFFFFF;
        overflow: hidden;
    `;
    
    // Apply background
    const bg = slideData.background || { type: 'none' };
    if (bg.type === 'solid') {
        preview.style.background = bg.color || '#FFFFFF';
    } else if (bg.type === 'gradient' && bg.gradient) {
        const g = bg.gradient;
        preview.style.background = `linear-gradient(${g.direction || 'to right'}, ${g.color1 || '#667eea'}, ${g.color2 || '#764ba2'})`;
    } else if (bg.type === 'image' && bg.imageUrl) {
        preview.style.backgroundImage = `url(${bg.imageUrl})`;
        preview.style.backgroundSize = 'cover';
        preview.style.backgroundPosition = 'center';
    }
    
    // Text layer
    const textLayer = document.createElement('div');
    textLayer.style.cssText = `
        position: absolute;
        inset: 0;
        padding: 32px;
        display: flex;
        flex-direction: column;
        font-family: ${slideData.fontFamily || 'Arial'}, sans-serif;
    `;
    
    // Title
    const title = document.createElement('div');
    title.innerHTML = slideData.titleText || '';
    title.style.cssText = `
        font-weight: bold;
        font-size: ${slideData.titleFontSize || 32}px;
        color: #111827;
        margin-bottom: 8px;
    `;
    textLayer.appendChild(title);
    
    // Main text
    const mainText = document.createElement('div');
    mainText.innerHTML = slideData.mainTextContent || '';
    mainText.style.cssText = `
        font-size: ${slideData.mainTextFontSize || 18}px;
        color: #374151;
        flex: 1;
    `;
    textLayer.appendChild(mainText);
    
    // Comment
    const comment = document.createElement('div');
    comment.innerHTML = slideData.commentText || '';
    comment.style.cssText = `
        font-size: ${slideData.commentFontSize || 14}px;
        color: #6B7280;
        margin-top: auto;
    `;
    textLayer.appendChild(comment);
    
    preview.appendChild(textLayer);
    
    // Images layer
    if (slideData.images && slideData.images.length > 0) {
        const imagesLayer = document.createElement('div');
        imagesLayer.style.cssText = 'position: absolute; inset: 0;';
        slideData.images.forEach(img => {
            const imgEl = document.createElement('img');
            imgEl.src = img.url; // FIXED: use 'url' not 'src'
            imgEl.crossOrigin = 'anonymous';
            imgEl.style.cssText = `
                position: absolute;
                left: ${img.position?.x || 0}px;
                top: ${img.position?.y || 0}px;
                width: ${img.size?.width || 100}px;
                height: ${img.size?.height || 100}px;
                object-fit: contain;
            `;
            if (img.rotation) {
                imgEl.style.transform = `rotate(${img.rotation}deg)`;
            }
            imagesLayer.appendChild(imgEl);
        });
        preview.appendChild(imagesLayer);
    }
    
    // Tables layer
    if (slideData.tables && slideData.tables.length > 0) {
        const tablesLayer = document.createElement('div');
        tablesLayer.style.cssText = 'position: absolute; inset: 0;';
        slideData.tables.forEach(tbl => {
            const wrapper = document.createElement('div');
            wrapper.style.cssText = `
                position: absolute;
                left: ${tbl.position?.x || 0}px;
                top: ${tbl.position?.y || 0}px;
                width: ${tbl.size?.width || 200}px;
                height: ${tbl.size?.height || 100}px;
                overflow: hidden;
            `;
            
            const table = document.createElement('table');
            table.style.cssText = `
                width: 100%;
                height: 100%;
                border-collapse: collapse;
                font-size: 14px;
                table-layout: fixed;
            `;
            
            // Render table rows and columns
            for (let row = 0; row < (tbl.rows || 1); row++) {
                const tr = document.createElement('tr');
                for (let col = 0; col < (tbl.columns || 1); col++) {
                    const td = document.createElement('td');
                    const cellKey = `${row}_${col}`;
                    td.innerHTML = tbl.cellData?.[cellKey] || '';
                    const cellBg = tbl.cellBgColors?.[cellKey] || (tbl.fillColor || '#FFFFFF');
                    td.style.cssText = `
                        border: 1px solid #ccc;
                        padding: 4px 8px;
                        background: ${cellBg};
                        vertical-align: middle;
                    `;
                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }
            wrapper.appendChild(table);
            tablesLayer.appendChild(wrapper);
        });
        preview.appendChild(tablesLayer);
    }
    
    // Arrows layer - FIXED: use startPoint/endPoint
    if (slideData.arrows && slideData.arrows.length > 0) {
        const arrowsLayer = document.createElement('div');
        arrowsLayer.style.cssText = 'position: absolute; inset: 0; pointer-events: none;';
        slideData.arrows.forEach(arrow => {
            // Calculate bounding box
            const padding = 20;
            const minX = Math.min(arrow.startPoint.x, arrow.endPoint.x);
            const minY = Math.min(arrow.startPoint.y, arrow.endPoint.y);
            const maxX = Math.max(arrow.startPoint.x, arrow.endPoint.x);
            const maxY = Math.max(arrow.startPoint.y, arrow.endPoint.y);
            const width = maxX - minX;
            const height = maxY - minY;
            
            const wrapper = document.createElement('div');
            wrapper.style.cssText = `
                position: absolute;
                left: ${minX - padding}px;
                top: ${minY - padding}px;
                width: ${width + 2 * padding}px;
                height: ${height + 2 * padding}px;
            `;
            
            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.style.overflow = 'visible';
            
            // Arrowhead marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'pdf-arrowhead-' + arrow.id);
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            
            const arrowheadPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            arrowheadPath.setAttribute('points', '0 0, 10 3, 0 6');
            arrowheadPath.setAttribute('fill', arrow.color || '#000000');
            marker.appendChild(arrowheadPath);
            defs.appendChild(marker);
            svg.appendChild(defs);
            
            // Arrow line
            const relStartX = arrow.startPoint.x - minX + padding;
            const relStartY = arrow.startPoint.y - minY + padding;
            const relEndX = arrow.endPoint.x - minX + padding;
            const relEndY = arrow.endPoint.y - minY + padding;
            
            let pathEl;
            if (arrow.type === 'bent') {
                const midX = (relStartX + relEndX) / 2;
                pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathEl.setAttribute('d', `M ${relStartX},${relStartY} L ${midX},${relStartY} L ${midX},${relEndY} L ${relEndX},${relEndY}`);
                pathEl.setAttribute('fill', 'none');
            } else if (arrow.type === 'curved') {
                const controlX = (relStartX + relEndX) / 2;
                const controlY = relStartY - 50;
                pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathEl.setAttribute('d', `M ${relStartX},${relStartY} Q ${controlX},${controlY} ${relEndX},${relEndY}`);
                pathEl.setAttribute('fill', 'none');
            } else {
                pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                pathEl.setAttribute('x1', relStartX);
                pathEl.setAttribute('y1', relStartY);
                pathEl.setAttribute('x2', relEndX);
                pathEl.setAttribute('y2', relEndY);
            }
            
            pathEl.setAttribute('stroke', arrow.color || '#000000');
            pathEl.setAttribute('stroke-width', arrow.strokeWidth || 2);
            pathEl.setAttribute('marker-end', 'url(#pdf-arrowhead-' + arrow.id + ')');
            svg.appendChild(pathEl);
            wrapper.appendChild(svg);
            arrowsLayer.appendChild(wrapper);
        });
        preview.appendChild(arrowsLayer);
    }
    
    // Accent boxes layer
    if (slideData.accentBoxes && slideData.accentBoxes.length > 0) {
        const boxesLayer = document.createElement('div');
        boxesLayer.style.cssText = 'position: absolute; inset: 0;';
        slideData.accentBoxes.forEach(box => {
            const wrapper = document.createElement('div');
            wrapper.innerHTML = box.text || '';
            wrapper.style.cssText = `
                position: absolute;
                left: ${box.position?.x || 0}px;
                top: ${box.position?.y || 0}px;
                width: ${box.size?.width || 200}px;
                height: ${box.size?.height || 100}px;
                padding: 8px;
                background: ${box.bgColor || '#E0E7FF'};
                border: 2px solid ${box.borderColor || '#4F46E5'};
                border-radius: 8px;
                color: ${box.textColor || '#1E1B4B'};
                font-size: ${box.fontSize || 14}px;
                font-family: ${box.fontFamily || 'Arial'}, sans-serif;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                box-sizing: border-box;
            `;
            boxesLayer.appendChild(wrapper);
        });
        preview.appendChild(boxesLayer);
    }
    
    container.appendChild(preview);
    document.body.appendChild(container);
    
    return { container, preview };
}

// Capture slide as canvas using offscreen rendering (no visible slide switching)
async function captureSlideAsCanvasOffscreen(slideIndex) {
    const slideData = slides[slideIndex];
    
    // Use same dimensions as current preview
    const currentPreview = document.getElementById('slidePreview');
    const previewWidth = currentPreview.offsetWidth;
    const previewHeight = currentPreview.offsetHeight;
    
    // Create offscreen preview
    const { container, preview } = createOffscreenSlidePreview(slideData, previewWidth, previewHeight);
    
    // Wait for images to load
    await new Promise(resolve => setTimeout(resolve, 50));
    
    try {
        const canvas = await html2canvas(preview, {
            scale: 2,
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#FFFFFF',
            logging: false,
            width: previewWidth,
            height: previewHeight
        });
        return canvas;
    } finally {
        container.remove();
    }
}

// Download single PDF with all slides (background, no visible switching)
async function downloadSinglePDF() {
    pdfGenerationCancelled = false;
    
    document.getElementById('downloadOptions').classList.add('hidden');
    showLoadingOverlay('–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...', 0);
    document.getElementById('downloadModal').classList.add('hidden');
    
    try {
        const { jsPDF } = window.jspdf;
        const totalSlides = slides.length;
        
        const previewEl = document.getElementById('slidePreview');
        const previewWidth = previewEl.offsetWidth;
        const previewHeight = previewEl.offsetHeight;
        const aspectRatio = previewWidth / previewHeight;
        
        const pdfWidth = 297;
        const pdfHeight = pdfWidth / aspectRatio;
        const orientation = aspectRatio > 1 ? 'landscape' : 'portrait';
        
        const pdf = new jsPDF({
            orientation: orientation,
            unit: 'mm',
            format: [pdfWidth, pdfHeight]
        });
        
        for (let i = 0; i < totalSlides; i++) {
            if (pdfGenerationCancelled) {
                hideLoadingOverlay();
                return;
            }
            
            const percent = Math.round(((i + 1) / totalSlides) * 100);
            showLoadingOverlay(`–°–ª–∞–π–¥ ${i + 1} –∏–∑ ${totalSlides}`, percent);
            
            const canvas = await captureSlideAsCanvasOffscreen(i);
            const imgData = canvas.toDataURL('image/jpeg', 0.92);
            
            if (i > 0) {
                pdf.addPage([pdfWidth, pdfHeight], orientation);
            }
            
            pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
        }
        
        showLoadingOverlay('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...', 100);
        
        const date = new Date().toISOString().slice(0, 10);
        pdf.save(`presentation_${date}.pdf`);
        
        hideLoadingOverlay();
        
    } catch (error) {
        console.error('Error generating PDF:', error);
        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ PDF: ' + error.message);
        hideLoadingOverlay();
    }
}

// Download ZIP with individual PDFs (background, no visible switching)
async function downloadZipPDFs() {
    pdfGenerationCancelled = false;
    
    document.getElementById('downloadOptions').classList.add('hidden');
    showLoadingOverlay('–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...', 0);
    document.getElementById('downloadModal').classList.add('hidden');
    
    try {
        const zip = new JSZip();
        const { jsPDF } = window.jspdf;
        const totalSlides = slides.length;
        
        const previewEl = document.getElementById('slidePreview');
        const previewWidth = previewEl.offsetWidth;
        const previewHeight = previewEl.offsetHeight;
        const aspectRatio = previewWidth / previewHeight;
        
        const pdfWidth = 297;
        const pdfHeight = pdfWidth / aspectRatio;
        const orientation = aspectRatio > 1 ? 'landscape' : 'portrait';
        
        for (let i = 0; i < totalSlides; i++) {
            if (pdfGenerationCancelled) {
                hideLoadingOverlay();
                return;
            }
            
            const percent = Math.round(((i + 1) / totalSlides) * 100);
            showLoadingOverlay(`–°–ª–∞–π–¥ ${i + 1} –∏–∑ ${totalSlides}`, percent);
            
            const canvas = await captureSlideAsCanvasOffscreen(i);
            const imgData = canvas.toDataURL('image/jpeg', 0.92);
            
            const pdf = new jsPDF({
                orientation: orientation,
                unit: 'mm',
                format: [pdfWidth, pdfHeight]
            });
            
            pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            
            const pdfBlob = pdf.output('blob');
            const slideNum = String(i + 1).padStart(2, '0');
            zip.file(`slide_${slideNum}.pdf`, pdfBlob);
        }
        
        showLoadingOverlay('–°–æ–∑–¥–∞–Ω–∏–µ –∞—Ä—Ö–∏–≤–∞...', 100);
        
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const date = new Date().toISOString().slice(0, 10);
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(zipBlob);
        link.download = `presentation_${date}.zip`;
        link.click();
        URL.revokeObjectURL(link.href);
        
        hideLoadingOverlay();
        
    } catch (error) {
        console.error('Error generating ZIP:', error);
        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∞—Ä—Ö–∏–≤–∞: ' + error.message);
        hideLoadingOverlay();
    }
}
</script>

<!-- Interact.js Library - Load at end after DOM elements exist -->
<script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.19/dist/interact.min.js"></script>

<!-- PDF Generation Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
// Wait for Interact.js to load, then initialize interactions
(function waitForInteract() {
    if (typeof interact !== 'undefined') {
        console.log('Interact.js loaded successfully');
        // Re-initialize interactions after library loads with multiple attempts
        setTimeout(() => {
            console.log('Calling initializeImageInteractions...');
            initializeImageInteractions();
            // Tables don't use Interact.js - they use native drag/resize
        }, 100);
        
        // Try again after 500ms to catch any late-rendered elements
        setTimeout(() => {
            console.log('Re-initializing after 500ms...');
            initializeImageInteractions();
        }, 500);
        
        // And again after 1 second
        setTimeout(() => {
            console.log('Re-initializing after 1s...');
            initializeImageInteractions();
        }, 1000);
    } else {
        console.log('Waiting for Interact.js...');
        setTimeout(waitForInteract, 50);
    }
})();
</script>

{% endblock %}
