{% extends "base.html" %}

{% block title %}–†–µ–¥–∞–∫—Ç–æ—Ä —Å–ª–∞–π–¥–æ–≤{% endblock %}

{% block content %}
<style>
/* Editable content styles */
#editableContent {
    min-height: 100%;
    color: #111827;
}

#editableContent:empty:before {
    content: attr(placeholder);
    color: #9CA3AF;
    pointer-events: none;
}

#editableContent h1 {
    font-size: 2.5rem;
    font-weight: 700;
    line-height: 1.2;
    margin-bottom: 1rem;
    color: #111827;
}

#editableContent h2 {
    font-size: 2rem;
    font-weight: 600;
    line-height: 1.3;
    margin-bottom: 0.75rem;
    color: #111827;
}

#editableContent h3 {
    font-size: 1.5rem;
    font-weight: 600;
    line-height: 1.4;
    margin-bottom: 0.5rem;
    color: #111827;
}

#editableContent h4 {
    font-size: 1.25rem;
    font-weight: 600;
    line-height: 1.4;
    margin-bottom: 0.5rem;
    color: #111827;
}

#editableContent p {
    font-size: 1.125rem;
    line-height: 1.6;
    margin-bottom: 0.75rem;
    color: #374151;
}

#editableContent ul, #editableContent ol {
    margin-left: 1.5rem;
    margin-bottom: 0.75rem;
}

#editableContent li {
    margin-bottom: 0.25rem;
}

/* Image Selection and Manipulation Styles */
.image-wrapper {
    position: absolute;
    cursor: pointer;
    pointer-events: auto; /* Allow clicks on wrapper */
    /* z-index is controlled by parent container */
}

/* Background images need higher stacking within their layer */
#previewImagesBackground .image-wrapper {
    z-index: 5;
}

/* Foreground images are already above text */
#previewImagesForeground .image-wrapper {
    z-index: 25;
}

.image-wrapper.selected {
    outline: 2px solid #3B82F6;
    outline-offset: 2px;
}

.image-wrapper img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    pointer-events: none; /* Clicks go through img to wrapper */
}

/* Resize Handles */
.resize-handle {
    position: absolute;
    width: 8px;
    height: 8px;
    background: white;
    border: 2px solid #3B82F6;
    z-index: 10;
    pointer-events: auto;
}

.resize-handle.top-left {
    top: -4px;
    left: -4px;
    cursor: nwse-resize;
}

.resize-handle.top-right {
    top: -4px;
    right: -4px;
    cursor: nesw-resize;
}

.resize-handle.bottom-left {
    bottom: -4px;
    left: -4px;
    cursor: nesw-resize;
}

.resize-handle.bottom-right {
    bottom: -4px;
    right: -4px;
    cursor: nwse-resize;
}

.resize-handle.top {
    top: -4px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize;
}

.resize-handle.bottom {
    bottom: -4px;
    left: 50%;
    transform: translateX(-50%);
    cursor: ns-resize;
}

.resize-handle.left {
    top: 50%;
    left: -4px;
    transform: translateY(-50%);
    cursor: ew-resize;
}

.resize-handle.right {
    top: 50%;
    right: -4px;
    transform: translateY(-50%);
    cursor: ew-resize;
}

/* Rotation Handle */
.rotate-handle {
    position: absolute;
    top: -30px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 20px;
    background: white;
    border: 2px solid #10B981;
    border-radius: 50%;
    cursor: grab;
    z-index: 11;
    pointer-events: auto;
    display: none;
}

.rotate-handle:active {
    cursor: grabbing;
}

.rotate-handle::after {
    content: '‚Üª';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    color: #10B981;
}

.resize-handle {
    display: none;
}

.image-wrapper.selected .resize-handle,
.image-wrapper.selected .rotate-handle {
    display: block;
}

/* Dragging state */
.image-wrapper.dragging {
    cursor: move !important;
    opacity: 0.8;
}

.image-wrapper.resizing {
    opacity: 0.8;
}

/* Dimension tooltip */
.dimension-tooltip {
    position: fixed;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 1000;
    display: none;
}

.dimension-tooltip.active {
    display: block;
}

/* Aspect ratio lock indicator */
.aspect-lock-indicator {
    position: absolute;
    top: -24px;
    right: -24px;
    background: #3B82F6;
    color: white;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    pointer-events: none;
    display: none;
}

.image-wrapper.selected .aspect-lock-indicator {
    display: flex;
}

/* Table Wrapper Styles */
.table-wrapper {
    position: absolute;
    cursor: move;
    pointer-events: auto;
    background: #f9fafb;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    overflow: visible;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    padding: 6px;
}

.table-wrapper.selected {
    outline: 2px solid #8B5CF6;
    outline-offset: 2px;
}

.table-wrapper table {
    width: 100%;
    height: auto;
    border-collapse: collapse;
    table-layout: fixed;
    font-size: 12px;
    line-height: 1.2;
    background: white;
}

.table-wrapper th,
.table-wrapper td {
    border: 1px solid #d1d5db;
    padding: 1px 3px;
    text-align: left;
    overflow: hidden;
    white-space: pre-wrap;
    word-wrap: break-word;
    word-break: break-word;
    vertical-align: top;
    cursor: text;
    height: auto;
    line-height: 1.2;
    outline: none;
}

.table-wrapper th:focus,
.table-wrapper td:focus {
    cursor: text;
    outline: 2px solid #8B5CF6;
    outline-offset: -2px;
    background: #faf5ff;
}

/* Editable cell placeholder */
.table-wrapper td:empty::before,
.table-wrapper th:empty::before {
    content: '';
    display: inline-block;
    min-height: 0.5em;
}

.table-wrapper th {
    background: #f3f4f6;
    font-weight: 600;
}

.table-wrapper .resize-handle {
    border-color: #8B5CF6;
}

.table-wrapper.selected .resize-handle {
    display: block;
}

.table-wrapper.dragging {
    cursor: move !important;
    opacity: 0.8;
}

.table-wrapper.resizing {
    opacity: 0.8;
}

/* Column resize handles for table wrapper */
.table-wrapper .col-resize-handle {
    position: absolute;
    top: 6px;
    width: 6px;
    height: calc(100% - 12px);
    cursor: col-resize;
    background: transparent;
    z-index: 10;
}

.table-wrapper .col-resize-handle:hover {
    background: rgba(139, 92, 246, 0.3);
}

.table-wrapper .col-resize-handle.resizing {
    background: rgba(139, 92, 246, 0.5);
}

/* Edge resize handles for table */
.table-wrapper .edge-resize-handle {
    position: absolute;
    top: 6px;
    width: 6px;
    height: calc(100% - 12px);
    cursor: ew-resize;
    background: transparent;
    z-index: 11;
}

.table-wrapper .edge-resize-handle.left {
    left: 0;
}

.table-wrapper .edge-resize-handle.right {
    right: 0;
}

.table-wrapper .edge-resize-handle:hover {
    background: rgba(59, 130, 246, 0.3);
}

.table-wrapper .edge-resize-handle.resizing {
    background: rgba(59, 130, 246, 0.5);
}

/* Corner resize handles for table */
.table-wrapper .corner-resize-handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #8B5CF6;
    border: 1px solid white;
    border-radius: 2px;
    z-index: 12;
    cursor: nwse-resize;
}

.table-wrapper .corner-resize-handle.top-left {
    top: -3px;
    left: -3px;
    cursor: nwse-resize;
}

.table-wrapper .corner-resize-handle.top-right {
    top: -3px;
    right: -3px;
    cursor: nesw-resize;
}

.table-wrapper .corner-resize-handle.bottom-left {
    bottom: -3px;
    left: -3px;
    cursor: nesw-resize;
}

.table-wrapper .corner-resize-handle.bottom-right {
    bottom: -3px;
    right: -3px;
    cursor: nwse-resize;
}

.table-wrapper .corner-resize-handle:hover {
    background: #7C3AED;
    transform: scale(1.2);
}

/* Full-screen layout styles */
.fullscreen-container {
    width: 100%;
    max-width: 100vw;
    padding: 0 1rem;
}

.editor-grid {
    display: grid;
    grid-template-columns: 280px 1fr 280px;
    gap: 1.5rem;
    max-height: calc(100vh - 10rem);
}

@media (max-width: 1440px) {
    .editor-grid {
        grid-template-columns: 240px 1fr 240px;
    }
}

@media (max-width: 1024px) {
    .editor-grid {
        grid-template-columns: 200px 1fr 200px;
        gap: 1rem;
    }
}

.sidebar-panel {
    display: flex;
    flex-direction: column;
}

.sidebar-panel > div {
    flex: 1;
}

.slides-list-panel {
    max-height: calc(100vh - 12rem);
    overflow-y: auto;
}

.center-panel {
    display: flex;
    flex-direction: column;
    max-height: calc(100vh - 12rem);
    overflow-y: auto;
}

.preview-container {
    width: 100%;
    max-height: 60vh;
}

/* List styles in contenteditable */
#editableContent ul {
    list-style-type: disc;
    padding-left: 2em;
    margin: 0.5em 0;
    color: inherit;
}

#editableContent ol {
    list-style-type: decimal;
    padding-left: 2em;
    margin: 0.5em 0;
    color: inherit;
}

#editableContent li {
    margin: 0.25em 0;
    color: inherit;
}
</style>
<div class="fullscreen-container">
    <div class="mb-6 flex justify-between items-center">
        <h1 class="text-3xl font-bold text-gray-900">–†–µ–¥–∞–∫—Ç–æ—Ä —Å–ª–∞–π–¥–æ–≤</h1>
        <div class="flex gap-3 items-center">
            <!-- Save status indicator -->
            <div id="saveStatus" class="text-sm">
                <span id="saveStatusText" class="text-gray-600"></span>
            </div>
            <button id="manualSaveBtn" onclick="manualSave()" class="px-3 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 text-sm">
                üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
            </button>
            <button onclick="window.location.href='/'" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                ‚Üê –ù–∞–∑–∞–¥
            </button>
            <button id="createBtn" onclick="generatePresentation(false)" class="px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700">
                ‚ú® –°–æ–∑–¥–∞—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
            </button>
        </div>
    </div>

    <!-- Progress bar -->
    <div id="progressBar" class="hidden mb-6">
        <div class="w-full bg-gray-200 rounded-full h-2.5">
            <div id="progressBarFill" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <p id="progressText" class="text-sm text-gray-600 mt-2 text-center">–û–±—Ä–∞–±–æ—Ç–∫–∞...</p>
    </div>

    <div class="editor-grid">
        <!-- Slides List (Left Panel) -->
        <div class="sidebar-panel slides-list-panel">
            <div class="bg-white rounded-lg shadow p-4 h-full">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold">–°–ª–∞–π–¥—ã</h2>
                    <button onclick="addNewSlide()" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                        + –ù–æ–≤—ã–π
                    </button>
                </div>
                <div id="slidesList" class="space-y-2 max-h-[70vh] overflow-y-auto">
                    <!-- Slides will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Slide Editor (Center Panel) -->
        <div class="center-panel">
            <div class="bg-white rounded-lg shadow p-8 lg:p-10 flex-1">
                <div class="mb-4 flex justify-between items-center">
                    <h2 class="text-lg font-bold">–°–ª–∞–π–¥ <span id="currentSlideNumber">1</span></h2>
                    <button onclick="deleteCurrentSlide()" class="px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600">
                        üóë –£–¥–∞–ª–∏—Ç—å
                    </button>
                </div>

                <!-- Formatting Toolbar (above preview) -->
                <div class="mb-4">
                    <div class="flex gap-1 flex-wrap border-b pb-2 bg-gray-50 p-2 rounded-t items-center">
                        <!-- Format selector (like in Word) -->
                        <select id="formatSelector" onchange="applyFormat()" class="px-2 py-1 bg-white border border-gray-300 rounded text-sm min-w-[180px]" title="–§–æ—Ä–º–∞—Ç">
                            <option value="p">–û–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç</option>
                            <option value="h1">–ó–∞–≥–æ–ª–æ–≤–æ–∫ 1</option>
                            <option value="h2">–ó–∞–≥–æ–ª–æ–≤–æ–∫ 2</option>
                            <option value="h3">–ó–∞–≥–æ–ª–æ–≤–æ–∫ 3</option>
                            <option value="h4">–ó–∞–≥–æ–ª–æ–≤–æ–∫ 4</option>
                        </select>
                        <span class="border-l mx-2"></span>
                        <button type="button" onclick="formatText('bold')" class="px-3 py-1 bg-white border border-gray-300 rounded hover:bg-gray-100 font-bold text-sm" title="–ñ–∏—Ä–Ω—ã–π (Ctrl+B)">B</button>
                        <button type="button" onclick="formatText('italic')" class="px-3 py-1 bg-white border border-gray-300 rounded hover:bg-gray-100 italic text-sm" title="–ö—É—Ä—Å–∏–≤ (Ctrl+I)">I</button>
                        <button type="button" onclick="formatText('underline')" class="px-3 py-1 bg-white border border-gray-300 rounded hover:bg-gray-100 underline text-sm" title="–ü–æ–¥—á—ë—Ä–∫–Ω—É—Ç—ã–π (Ctrl+U)">U</button>
                        <span class="border-l mx-2"></span>
                        <div class="flex items-center gap-1">
                            <label class="text-xs text-gray-600">–¶–≤–µ—Ç:</label>
                            <input type="color" id="selectionTextColor" value="#000000" class="h-8 w-10 rounded border cursor-pointer" onchange="applyTextColor()" title="–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞">
                        </div>
                        <span class="border-l mx-2"></span>
                        <!-- List format dropdown -->
                        <select id="bulletListStyle" onchange="applyListStyle('ul')" class="px-2 py-1 bg-white border border-gray-300 rounded text-sm" title="–ú–∞—Ä–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫">
                            <option value="" disabled selected>‚Ä¢ –°–ø–∏—Å–æ–∫</option>
                            <option value="disc">‚Ä¢ –ö—Ä—É–≥–ª—ã–π</option>
                            <option value="circle">‚óã –ü—É—Å—Ç–æ–π –∫—Ä—É–≥</option>
                            <option value="square">‚ñ† –ö–≤–∞–¥—Ä–∞—Ç</option>
                            <option value="none">‚Äî –ë–µ–∑ –º–∞—Ä–∫–µ—Ä–∞</option>
                            <option value="remove">‚úï –£–±—Ä–∞—Ç—å —Å–ø–∏—Å–æ–∫</option>
                        </select>
                        <!-- Numbering format dropdown -->
                        <select id="numberListStyle" onchange="applyListStyle('ol')" class="px-2 py-1 bg-white border border-gray-300 rounded text-sm" title="–ù—É–º–µ—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫">
                            <option value="" disabled selected>1. –ù—É–º–µ—Ä–∞—Ü–∏—è</option>
                            <option value="decimal">1, 2, 3...</option>
                            <option value="decimal-leading-zero">01, 02, 03...</option>
                            <option value="lower-alpha">a, b, c...</option>
                            <option value="upper-alpha">A, B, C...</option>
                            <option value="lower-roman">i, ii, iii...</option>
                            <option value="upper-roman">I, II, III...</option>
                            <option value="remove">‚úï –£–±—Ä–∞—Ç—å —Å–ø–∏—Å–æ–∫</option>
                        </select>
                        <span class="border-l mx-2"></span>
                        <button type="button" onclick="clearAllFormatting()" class="px-2 py-1 bg-white border border-gray-300 rounded hover:bg-gray-100 text-xs" title="–û—á–∏—Å—Ç–∏—Ç—å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ">‚úï –û—á–∏—Å—Ç–∏—Ç—å</button>
                    </div>
                </div>

                <!-- Editable Slide Preview -->
                <div id="slidePreview" class="mb-6 border-2 border-blue-400 rounded-lg bg-white relative preview-container" style="aspect-ratio: 16/9; overflow: hidden; width: 100%;" onclick="handleSlidePreviewClick(event)">
                    <!-- Editable text container -->
                    <div id="textLayerContainer" class="absolute inset-0 p-8 flex flex-col" style="z-index: 10;">
                        <div id="editableContent" 
                             contenteditable="true"
                             class="flex-1 overflow-y-auto focus:outline-none"
                             style="cursor: text;"
                             oninput="syncContentToData()"
                             placeholder="–ö–ª–∏–∫–Ω–∏—Ç–µ —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ...">
                            <h1>–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ª–∞–π–¥–∞</h1>
                            <p>–ù–∞—á–Ω–∏—Ç–µ –ø–µ—á–∞—Ç–∞—Ç—å...</p>
                        </div>
                    </div>
                    <!-- Images layer (on top but only images are clickable) -->
                    <div id="previewImages" class="absolute inset-0" style="z-index: 20; pointer-events: none;"></div>
                    <!-- Tables layer -->
                    <div id="previewTables" class="absolute inset-0" style="z-index: 15; pointer-events: none;"></div>
                </div>
                
                <!-- Dimension Tooltip -->
                <div id="dimensionTooltip" class="dimension-tooltip"></div>
            </div>
        </div>

        <!-- Settings Panel (Right) -->
        <div class="sidebar-panel">
            <div class="bg-white rounded-lg shadow p-4">
                <h2 class="text-lg font-bold mb-4">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
                
                <div class="space-y-4">
                    <!-- Page Orientation -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è</label>
                        <select id="pageOrientation" class="w-full p-2 border border-gray-300 rounded-lg" onchange="applyPageOrientation()">
                            <option value="horizontal">–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π (16:9)</option>
                            <option value="vertical">–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π (9:16)</option>
                        </select>
                    </div>

                    <div class="pt-2 border-t">
                        <h3 class="text-sm font-semibold text-gray-700 mb-2">–†–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞</h3>
                    </div>

                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">–†–∞–∑–º–µ—Ä –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞</label>
                        <input type="range" id="fontSize" min="8" max="72" value="18" class="w-full"
                               oninput="applyFontSizeToSelection(); document.getElementById('fontSizeValue').textContent = this.value">
                        <div class="flex justify-between items-center">
                            <span id="fontSizeValue" class="text-sm text-gray-600">18</span>
                            <span class="text-xs text-gray-500">PT</span>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">–í—ã–¥–µ–ª–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏ –∏–∑–º–µ–Ω–∏—Ç–µ —Ä–∞–∑–º–µ—Ä</p>
                    </div>

                    <!-- Font Selection -->
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">–®—Ä–∏—Ñ—Ç</label>
                        <select id="fontFamily" class="w-full p-2 border border-gray-300 rounded-lg" onchange="changeFontFamily()">
                            <optgroup label="–°–∏—Å—Ç–µ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã">
                                <option value="Arial" selected>Arial</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Calibri">Calibri</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Tahoma">Tahoma</option>
                                <option value="Trebuchet MS">Trebuchet MS</option>
                                <option value="Helvetica">Helvetica</option>
                            </optgroup>
                            <optgroup label="Google Fonts">
                                <option data-google="true" value="Roboto">Roboto</option>
                                <option data-google="true" value="Open Sans">Open Sans</option>
                                <option data-google="true" value="Lato">Lato</option>
                                <option data-google="true" value="Montserrat">Montserrat</option>
                                <option data-google="true" value="Oswald">Oswald</option>
                                <option data-google="true" value="Raleway">Raleway</option>
                                <option data-google="true" value="Poppins">Poppins</option>
                                <option data-google="true" value="Inter">Inter</option>
                                <option data-google="true" value="Noto Sans">Noto Sans</option>
                                <option data-google="true" value="Noto Serif">Noto Serif</option>
                                <option data-google="true" value="Merriweather">Merriweather</option>
                                <option data-google="true" value="Source Sans 3">Source Sans 3</option>
                                <option data-google="true" value="Playfair Display">Playfair Display</option>
                                <option data-google="true" value="PT Sans">PT Sans</option>
                                <option data-google="true" value="PT Serif">PT Serif</option>
                                <option data-google="true" value="Ubuntu">Ubuntu</option>
                                <option data-google="true" value="Work Sans">Work Sans</option>
                                <option data-google="true" value="Nunito">Nunito</option>
                                <option data-google="true" value="Quicksand">Quicksand</option>
                                <option data-google="true" value="Rubik">Rubik</option>
                                <option data-google="true" value="Heebo">Heebo</option>
                                <option data-google="true" value="Mulish">Mulish</option>
                                <option data-google="true" value="Karla">Karla</option>
                                <option data-google="true" value="IBM Plex Sans">IBM Plex Sans</option>
                                <option data-google="true" value="DM Sans">DM Sans</option>
                                <option data-google="true" value="Inconsolata">Inconsolata</option>
                                <option data-google="true" value="Fira Sans">Fira Sans</option>
                                <option data-google="true" value="Cabin">Cabin</option>
                                <option data-google="true" value="Anton">Anton</option>
                                <option data-google="true" value="Abril Fatface">Abril Fatface</option>
                                <option data-google="true" value="Arvo">Arvo</option>
                                <option data-google="true" value="Barlow">Barlow</option>
                                <option data-google="true" value="Cormorant Garamond">Cormorant Garamond</option>
                                <option data-google="true" value="Exo 2">Exo 2</option>
                                <option data-google="true" value="Josefin Sans">Josefin Sans</option>
                                <option data-google="true" value="Libre Baskerville">Libre Baskerville</option>
                                <option data-google="true" value="Manrope">Manrope</option>
                                <option data-google="true" value="Merriweather Sans">Merriweather Sans</option>
                                <option data-google="true" value="Righteous">Righteous</option>
                                <option data-google="true" value="Roboto Condensed">Roboto Condensed</option>
                                <option data-google="true" value="Roboto Slab">Roboto Slab</option>
                                <option data-google="true" value="Source Serif 4">Source Serif 4</option>
                                <option data-google="true" value="Tangerine">Tangerine</option>
                                <option data-google="true" value="Teko">Teko</option>
                            </optgroup>
                        </select>
                    </div>

                    <!-- Slide Background -->
                    <div class="pt-2 border-t">
                        <h3 class="text-sm font-semibold text-gray-700 mb-2">–§–æ–Ω —Å–ª–∞–π–¥–∞</h3>
                        <div class="space-y-2">
                            <label class="flex items-center">
                                <input type="radio" name="bgType" value="none" checked onchange="changeBackgroundType('none')" class="mr-2">
                                <span class="text-sm">–ë–µ–∑ —Ñ–æ–Ω–∞ (–±–µ–ª—ã–π)</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="bgType" value="solid" onchange="changeBackgroundType('solid')" class="mr-2">
                                <span class="text-sm">–û–¥–Ω–æ—Ç–æ–Ω–Ω—ã–π —Ü–≤–µ—Ç</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="bgType" value="gradient" onchange="changeBackgroundType('gradient')" class="mr-2">
                                <span class="text-sm">–ì—Ä–∞–¥–∏–µ–Ω—Ç</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="bgType" value="image" onchange="changeBackgroundType('image')" class="mr-2">
                                <span class="text-sm">–ö–∞—Ä—Ç–∏–Ω–∫–∞</span>
                            </label>
                        </div>
                        
                        <!-- Solid color picker -->
                        <div id="solidColorPicker" class="hidden mt-2">
                            <label class="block text-xs text-gray-600 mb-1">–¶–≤–µ—Ç —Ñ–æ–Ω–∞</label>
                            <input type="color" id="bgColor" value="#FFFFFF" class="w-full h-10 rounded border" onchange="updateBackground()">
                        </div>
                        
                        <!-- Gradient picker -->
                        <div id="gradientPicker" class="hidden mt-2 space-y-2">
                            <div class="flex gap-2">
                                <div class="flex-1">
                                    <label class="block text-xs text-gray-600 mb-1">–¶–≤–µ—Ç 1</label>
                                    <input type="color" id="gradientColor1" value="#667eea" class="w-full h-8 rounded border" onchange="updateBackground()">
                                </div>
                                <div class="flex-1">
                                    <label class="block text-xs text-gray-600 mb-1">–¶–≤–µ—Ç 2</label>
                                    <input type="color" id="gradientColor2" value="#764ba2" class="w-full h-8 rounded border" onchange="updateBackground()">
                                </div>
                            </div>
                            <select id="gradientDirection" class="w-full p-2 border rounded text-sm" onchange="updateBackground()">
                                <option value="to right">–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π ‚Üí</option>
                                <option value="to bottom">–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π ‚Üì</option>
                                <option value="to bottom right">–î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π ‚Üò</option>
                            </select>
                        </div>
                        
                        <!-- Image background picker -->
                        <div id="imageBgPicker" class="hidden mt-2 space-y-2">
                            <label class="block text-xs text-gray-600 mb-1">–§–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</label>
                            <input type="file" id="bgImageInput" accept="image/*" class="hidden" onchange="handleBackgroundImageUpload(event)">
                            <button type="button" onclick="document.getElementById('bgImageInput').click()" class="w-full px-2 py-1 bg-green-500 text-white rounded text-xs hover:bg-green-600 mb-1">
                                + –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                            </button>
                            <div id="bgImagePreview" class="text-xs text-gray-500"></div>
                        </div>
                    </div>

                    <!-- Element Management -->
                    <div class="pt-2 border-t">
                        <h3 class="text-sm font-semibold text-gray-700 mb-2">–≠–ª–µ–º–µ–Ω—Ç—ã</h3>
                    </div>

                    <!-- Images -->
                    <div>
                        <h4 class="text-xs font-medium text-gray-600 mb-1">–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</h4>
                        <input type="file" id="imageUploadInput" accept="image/*" multiple class="hidden" onchange="handleImageUpload(event)">
                        <button onclick="document.getElementById('imageUploadInput').click()" class="w-full px-2 py-1 bg-green-500 text-white rounded text-xs hover:bg-green-600 mb-2">
                            + –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                        </button>
                        <div id="imagesList" class="space-y-1 max-h-32 overflow-y-auto mb-2">
                            <!-- Images will be listed here -->
                        </div>
                        <p class="text-xs text-gray-500">–ò–ª–∏ Drag & Drop –Ω–∞ –ø—Ä–µ–≤—å—é</p>
                    </div>

                    <!-- Tables -->
                    <div class="mt-3">
                        <h4 class="text-xs font-medium text-gray-600 mb-1">–¢–∞–±–ª–∏—Ü—ã</h4>
                        <button onclick="showTableModal()" class="w-full px-2 py-1 bg-purple-500 text-white rounded text-xs hover:bg-purple-600 mb-1">
                            + –î–æ–±–∞–≤–∏—Ç—å
                        </button>
                        <div id="tablesList" class="space-y-1 max-h-20 overflow-y-auto">
                            <!-- Tables will be listed here -->
                        </div>
                    </div>

                    <!-- Arrows -->
                    <div class="mt-3">
                        <h4 class="text-xs font-medium text-gray-600 mb-1">–°—Ç—Ä–µ–ª–∫–∏</h4>
                        <button onclick="showArrowModal()" class="w-full px-2 py-1 bg-orange-500 text-white rounded text-xs hover:bg-orange-600 mb-1">
                            + –î–æ–±–∞–≤–∏—Ç—å
                        </button>
                        <div id="arrowsList" class="space-y-1 max-h-20 overflow-y-auto">
                            <!-- Arrows will be listed here -->
                        </div>
                    </div>

                    <!-- Accent Boxes -->
                    <div class="mt-3">
                        <h4 class="text-xs font-medium text-gray-600 mb-1">–ê–∫—Ü–µ–Ω—Ç–Ω—ã–µ –±–ª–æ–∫–∏</h4>
                        <button onclick="showAccentBoxModal()" class="w-full px-2 py-1 bg-indigo-500 text-white rounded text-xs hover:bg-indigo-600 mb-1">
                            + –î–æ–±–∞–≤–∏—Ç—å
                        </button>
                        <div id="accentBoxesList" class="space-y-1 max-h-20 overflow-y-auto">
                            <!-- Accent boxes will be listed here -->
                        </div>
                    </div>

                    <div class="pt-4 border-t">
                        <button onclick="applyToAll()" class="w-full px-3 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 text-sm">
                            –ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–æ –≤—Å–µ–º
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Table Modal -->
<div id="tableModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-md w-full">
        <h3 class="text-lg font-bold mb-4">–î–æ–±–∞–≤–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É</h3>
        <div class="space-y-4">
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">–°—Ç—Ä–æ–∫–∏</label>
                    <input type="number" id="tableRows" min="1" max="10" value="3" class="w-full p-2 border border-gray-300 rounded-lg">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">–°—Ç–æ–ª–±—Ü—ã</label>
                    <input type="number" id="tableColumns" min="1" max="8" value="3" class="w-full p-2 border border-gray-300 rounded-lg">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-700">X (–ø–∏–∫—Å–µ–ª–∏)</label>
                    <input type="number" id="tableX" value="50" class="w-full p-2 border border-gray-300 rounded">
                </div>
                <div>
                    <label class="block text-sm text-gray-700">Y (–ø–∏–∫—Å–µ–ª–∏)</label>
                    <input type="number" id="tableY" value="200" class="w-full p-2 border border-gray-300 rounded">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-700">–®–∏—Ä–∏–Ω–∞</label>
                    <input type="number" id="tableWidth" value="500" class="w-full p-2 border border-gray-300 rounded">
                </div>
                <div>
                    <label class="block text-sm text-gray-700">–í—ã—Å–æ—Ç–∞</label>
                    <input type="number" id="tableHeight" value="200" class="w-full p-2 border border-gray-300 rounded">
                </div>
            </div>
        </div>
        <div class="flex gap-2 mt-6">
            <button onclick="addTable()" class="flex-1 px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600">–î–æ–±–∞–≤–∏—Ç—å</button>
            <button onclick="closeTableModal()" class="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<!-- Table Cell Editor Modal -->
<div id="tableCellEditorModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-4xl w-full max-h-[80vh] overflow-y-auto">
        <h3 class="text-lg font-bold mb-4">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã</h3>
        
        <!-- Add Row/Column Buttons -->
        <div class="flex gap-2 mb-4 flex-wrap">
            <button onclick="addTableRow()" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                + –°—Ç—Ä–æ–∫–∞
            </button>
            <button onclick="addTableColumn()" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                + –°—Ç–æ–ª–±–µ—Ü
            </button>
            <span class="border-l mx-1"></span>
            <span id="tableDimensions" class="text-sm text-gray-600 self-center"></span>
            <span class="ml-auto text-xs text-gray-500 self-center">–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ ‚úï —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å —Å—Ç—Ä–æ–∫—É/—Å—Ç–æ–ª–±–µ—Ü</span>
        </div>
        
        <div id="tableCellGrid" class="space-y-2 mb-4">
            <!-- Cell grid will be dynamically generated -->
        </div>
        <div class="flex gap-2 mt-6">
            <button onclick="saveCellData()" class="flex-1 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button onclick="closeCellEditor()" class="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<!-- Arrow Modal -->
<div id="arrowModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-md w-full">
        <h3 class="text-lg font-bold mb-4">–î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–µ–ª–∫—É</h3>
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">–¢–∏–ø —Å—Ç—Ä–µ–ª–∫–∏</label>
                <select id="arrowType" class="w-full p-2 border border-gray-300 rounded-lg">
                    <option value="straight">–ü—Ä—è–º–∞—è</option>
                    <option value="bent">–° –∏–∑–ª–æ–º–æ–º</option>
                    <option value="curved">–ò–∑–æ–≥–Ω—É—Ç–∞—è</option>
                </select>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-700">–ù–∞—á–∞–ª–æ X</label>
                    <input type="number" id="arrowStartX" value="100" class="w-full p-2 border border-gray-300 rounded">
                </div>
                <div>
                    <label class="block text-sm text-gray-700">–ù–∞—á–∞–ª–æ Y</label>
                    <input type="number" id="arrowStartY" value="150" class="w-full p-2 border border-gray-300 rounded">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-700">–ö–æ–Ω–µ—Ü X</label>
                    <input type="number" id="arrowEndX" value="300" class="w-full p-2 border border-gray-300 rounded">
                </div>
                <div>
                    <label class="block text-sm text-gray-700">–ö–æ–Ω–µ—Ü Y</label>
                    <input type="number" id="arrowEndY" value="150" class="w-full p-2 border border-gray-300 rounded">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-700">–¶–≤–µ—Ç</label>
                    <input type="color" id="arrowColor" value="#000000" class="w-full p-1 border border-gray-300 rounded h-10">
                </div>
                <div>
                    <label class="block text-sm text-gray-700">–¢–æ–ª—â–∏–Ω–∞ (PT)</label>
                    <input type="number" id="arrowStroke" min="1" max="10" value="2" class="w-full p-2 border border-gray-300 rounded">
                </div>
            </div>
        </div>
        <div class="flex gap-2 mt-6">
            <button onclick="addArrow()" class="flex-1 px-4 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600">–î–æ–±–∞–≤–∏—Ç—å</button>
            <button onclick="closeArrowModal()" class="flex-1 px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<!-- Accent Box Modal -->
<div id="accentBoxModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-md w-full">
        <h3 class="text-lg font-bold mb-4">–ê–∫—Ü–µ–Ω—Ç–Ω—ã–π –±–ª–æ–∫</h3>
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium mb-2">–¢–µ–∫—Å—Ç</label>
                <textarea id="accentText" rows="3" class="w-full p-2 border rounded"></textarea>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-600">–¶–≤–µ—Ç —Ñ–æ–Ω–∞</label>
                    <input type="color" id="accentBgColor" value="#E0E7FF" class="w-full h-10 rounded">
                </div>
                <div>
                    <label class="block text-sm text-gray-600">–¶–≤–µ—Ç –≥—Ä–∞–Ω–∏—Ü—ã</label>
                    <input type="color" id="accentBorderColor" value="#4F46E5" class="w-full h-10 rounded">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-600">X</label>
                    <input type="number" id="accentX" value="50" class="w-full p-2 border rounded">
                </div>
                <div>
                    <label class="block text-sm text-gray-600">Y</label>
                    <input type="number" id="accentY" value="200" class="w-full p-2 border rounded">
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block text-sm text-gray-600">–®–∏—Ä–∏–Ω–∞</label>
                    <input type="number" id="accentWidth" value="300" class="w-full p-2 border rounded">
                </div>
                <div>
                    <label class="block text-sm text-gray-600">–í—ã—Å–æ—Ç–∞</label>
                    <input type="number" id="accentHeight" value="100" class="w-full p-2 border rounded">
                </div>
            </div>
        </div>
        <div class="flex gap-2 mt-6">
            <button onclick="addAccentBox()" class="flex-1 px-4 py-2 bg-indigo-500 text-white rounded-lg">–î–æ–±–∞–≤–∏—Ç—å</button>
            <button onclick="closeAccentBoxModal()" class="flex-1 px-4 py-2 bg-gray-300 rounded-lg">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<script>
let slides = {{ slides_data | tojson }};
let currentSlideIndex = 0;
const presentationUrl = '{{ presentation_url }}';
let generatedPresentationId = null;  // Track generated presentation

// Settings state
let presentationSettings = {
    pageOrientation: 'horizontal',
    defaultFont: 'Arial',
    defaultFontSize: 18,
    defaultTextPosition: {
        vertical: 'top',
        horizontal: 'left'
    }
};

// Get job ID for settings persistence
const urlParams = new URLSearchParams(window.location.search);
const jobId = urlParams.get('job_id') || 'default';

// Auto-save state
let saveTimer = null;
let pendingSave = false;
let lastSavedTime = null;
let isSaving = false;

// Responsive scaling state
const BASELINE_PREVIEW_WIDTH = 800; // Reference width for default font sizes
let currentScaleFactor = 1.0;
let resizeDebounceTimer = null;

// Initialize
let isFirstLoad = true;
document.addEventListener('DOMContentLoaded', async () => {
    console.log('DEBUG: Loaded slides data:', slides);
    console.log('DEBUG: First slide:', slides[0]);
    loadSettings();
    
    // Try loading from backend first, then merge with localStorage
    await loadFromBackend();
    
    initializeSlideData();
    renderSlidesList();
    loadSlide(0);
    isFirstLoad = false;  // –ü–æ—Å–ª–µ –ø–µ—Ä–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥
    
    // Check if we have a generated presentation from previous run
    if (jobId && jobId !== 'default') {
        checkForGeneratedPresentation(jobId);
    }
    
    // Add click handler to slide preview for smart click routing
    const slidePreview = document.getElementById('slidePreview');
    if (slidePreview) {
        // Use capture phase to intercept clicks before they reach targets
        slidePreview.addEventListener('click', handleSlidePreviewClick, true);
    }
    
    // Setup drag-and-drop for slide preview
    setupPreviewDragDrop();
    
    // Setup file input handlers
    setupFileInputHandlers();
    
    // Start auto-save timer
    startAutoSave();
    
    // Setup responsive scaling
    setupResponsiveScaling();
});

function checkForGeneratedPresentation(jobId) {
    // Check if this job already generated a presentation
    fetch(`/api/job/${jobId}`)
        .then(response => response.json())
        .then(job => {
            if (job.generated_presentation_id) {
                generatedPresentationId = job.generated_presentation_id;
                // Show update button, hide create button
                document.getElementById('createBtn').classList.add('hidden');
                document.getElementById('updateBtn').classList.remove('hidden');
            }
        })
        .catch(err => console.error('Error checking job:', err));
}

function renderSlidesList() {
    const container = document.getElementById('slidesList');
    if (slides.length === 0) {
        container.innerHTML = '<div class="p-4 text-gray-500 text-sm">–ù–µ—Ç —Å–ª–∞–π–¥–æ–≤</div>';
        return;
    }
    console.log('DEBUG renderSlidesList: slides count =', slides.length);
    container.innerHTML = slides.map((slide, index) => {
        // Extract title and preview from content HTML
        let title = '–ë–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞';
        let preview = '';
        
        if (slide.content) {
            // Try to extract first heading as title
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = slide.content;
            const heading = tempDiv.querySelector('h1, h2, h3, h4');
            if (heading) {
                title = heading.textContent.substring(0, 30);
            }
            // Extract text preview (remove HTML tags)
            preview = tempDiv.textContent.replace(/\s+/g, ' ').trim().substring(0, 30);
        } else if (slide.title) {
            // Backward compatibility
            title = slide.title;
            preview = (slide.mainText || '').replace(/<[^>]*>/g, '').substring(0, 30);
        }
        
        return `
        <div onclick="loadSlide(${index})" 
             class="p-3 rounded cursor-pointer transition ${index === currentSlideIndex ? 'bg-blue-100 border-2 border-blue-500' : 'bg-gray-50 hover:bg-gray-100 border border-gray-200'}">
            <div class="font-semibold text-sm">${index + 1}. ${title}</div>
            <div class="text-xs text-gray-500 mt-1 truncate">${preview}${preview ? '...' : ''}</div>
        </div>
    `;
    }).join('');
}

function loadSlide(index) {
    // Save current slide first (BUT NOT on first load when inputs are empty!)
    if (currentSlideIndex >= 0 && currentSlideIndex < slides.length && !isFirstLoad) {
        saveCurrentSlide();
    }

    currentSlideIndex = index;
    const slide = slides[index];
    
    console.log(`DEBUG loadSlide(${index}):`, slide);

    document.getElementById('currentSlideNumber').textContent = index + 1;
    
    // Load editable content
    const editor = document.getElementById('editableContent');
    
    // Handle both old format (title/mainText) and new format (content)
    if (slide.content) {
        // New format - direct HTML content
        editor.innerHTML = slide.content;
        console.log(`  Loaded from content field`);
    } else if (slide.title || slide.mainText) {
        // Migration from old format
        let html = '';
        if (slide.title) {
            html += `<h1>${slide.title}</h1>`;
        }
        if (slide.mainText) {
            // mainText might already be HTML from old contenteditable
            html += slide.mainText;
        }
        editor.innerHTML = html || '<h1>–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ª–∞–π–¥–∞</h1><p>–ù–∞—á–Ω–∏—Ç–µ –ø–µ—á–∞—Ç–∞—Ç—å...</p>';
        // Save migrated content
        slide.content = editor.innerHTML;
        console.log(`  Migrated from title/mainText fields`);
    } else {
        // New slide with no content
        editor.innerHTML = '<h1>–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ª–∞–π–¥–∞</h1><p>–ù–∞—á–Ω–∏—Ç–µ –ø–µ—á–∞—Ç–∞—Ç—å...</p>';
        console.log(`  Using default content`);
    }
    
    // Load slide-specific settings
    if (slide.fontFamily) {
        document.getElementById('fontFamily').value = slide.fontFamily;
    }
    
    // Load background settings
    const background = slide.background || { type: 'none', color: '#FFFFFF' };
    const bgType = background.type || 'none';
    document.querySelector(`input[name="bgType"][value="${bgType}"]`).checked = true;
    
    if (bgType === 'solid') {
        document.getElementById('bgColor').value = background.color || '#FFFFFF';
        document.getElementById('solidColorPicker').classList.remove('hidden');
        document.getElementById('gradientPicker').classList.add('hidden');
        document.getElementById('imageBgPicker').classList.add('hidden');
    } else if (bgType === 'gradient' && background.gradient) {
        document.getElementById('gradientColor1').value = background.gradient.color1 || '#667eea';
        document.getElementById('gradientColor2').value = background.gradient.color2 || '#764ba2';
        document.getElementById('gradientDirection').value = background.gradient.direction || 'to right';
        document.getElementById('solidColorPicker').classList.add('hidden');
        document.getElementById('gradientPicker').classList.remove('hidden');
        document.getElementById('imageBgPicker').classList.add('hidden');
    } else if (bgType === 'image') {
        document.getElementById('solidColorPicker').classList.add('hidden');
        document.getElementById('gradientPicker').classList.add('hidden');
        document.getElementById('imageBgPicker').classList.remove('hidden');
        if (background.imageUrl) {
            const info = document.getElementById('bgImagePreview');
            if (info) info.textContent = '–§–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ';
        }
    } else {
        document.getElementById('solidColorPicker').classList.add('hidden');
        document.getElementById('gradientPicker').classList.add('hidden');
        document.getElementById('imageBgPicker').classList.add('hidden');
    }

    // Ensure Google Fonts are loaded when switching slides
    changeFontFamily();

    updateSlidePreview();
    updateImagesList();
    updateTablesList();
    updateArrowsList();
    updateAccentBoxesList();
    renderSlidesList();
}

function saveCurrentSlide() {
    // Ensure defaultTextPosition exists
    if (!presentationSettings.defaultTextPosition) {
        presentationSettings.defaultTextPosition = {
            vertical: 'top',
            horizontal: 'left'
        };
    }
    
    const editor = document.getElementById('editableContent');
    
    slides[currentSlideIndex] = {
        ...slides[currentSlideIndex],
        content: editor.innerHTML,
        fontFamily: document.getElementById('fontFamily').value,
        background: slides[currentSlideIndex].background || { type: 'none', color: '#FFFFFF' },
        textPosition: {
            vertical: presentationSettings.defaultTextPosition.vertical,
            horizontal: presentationSettings.defaultTextPosition.horizontal
        },
        images: slides[currentSlideIndex].images || [],
        tables: slides[currentSlideIndex].tables || [],
        arrows: slides[currentSlideIndex].arrows || [],
        accentBoxes: slides[currentSlideIndex].accentBoxes || []
    };
    
    // All saves go to backend now
    saveToBackend();
}

function updateSlidePreview() {
    // Preview IS the editor now, so we only need to:
    // 1. Apply styles
    // 2. Apply background
    // 3. Render images
    // 4. Render tables
    
    updatePreviewStyles();
    
    // Apply background to preview
    const currentBackground = slides[currentSlideIndex]?.background || { type: 'none', color: '#FFFFFF' };
    const preview = document.getElementById('slidePreview');
    if (currentBackground.type === 'solid') {
        preview.style.backgroundImage = '';
        preview.style.background = currentBackground.color;
    } else if (currentBackground.type === 'gradient' && currentBackground.gradient) {
        const g = currentBackground.gradient;
        preview.style.backgroundImage = '';
        preview.style.background = `linear-gradient(${g.direction}, ${g.color1}, ${g.color2})`;
    } else if (currentBackground.type === 'image' && currentBackground.imageUrl) {
        preview.style.backgroundImage = `url(${currentBackground.imageUrl})`;
        preview.style.backgroundSize = 'cover';
        preview.style.backgroundPosition = 'center center';
        preview.style.backgroundColor = '';
    } else {
        preview.style.backgroundImage = '';
        preview.style.background = '#FFFFFF';
    }
    
    // Render images in layers
    renderPreviewImages();
    
    // Render tables
    renderPreviewTables();
}

function renderPreviewImages() {
    const images = slides[currentSlideIndex].images || [];
    const imagesContainer = document.getElementById('previewImages');
    
    // Clear existing images
    imagesContainer.innerHTML = '';
    
    // Deselect all images when re-rendering
    deselectAllImages();
    
    // Render all images (always on top of text)
    images.forEach(img => {
        const wrapper = createImageWrapper(img);
        imagesContainer.appendChild(wrapper);
    });
    
    // Initialize Interact.js on all new image wrappers
    setTimeout(() => {
        if (typeof interact !== 'undefined') {
            initializeImageInteractions();
        }
    }, 50);
}

// Handle file upload
function handleImageUpload(event) {
    const files = event.target.files;
    if (!files || files.length === 0) return;
    
    Array.from(files).forEach(file => {
        if (!file.type.startsWith('image/')) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            addImageToSlide(e.target.result);
        };
        reader.readAsDataURL(file);
    });
    
    // Clear input so same file can be selected again
    event.target.value = '';
}

// Add image to current slide
function addImageToSlide(imageUrl) {
    const image = {
        id: 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        url: imageUrl,
        position: { x: 50, y: 50 },
        size: { width: 200, height: 150 },
        rotation: 0,
        aspectLocked: true,
        aspectRatio: 200 / 150
    };
    
    if (!slides[currentSlideIndex].images) {
        slides[currentSlideIndex].images = [];
    }
    slides[currentSlideIndex].images.push(image);
    
    updateImagesList();
    renderPreviewImages();
    saveSlides();
}

function createImageWrapper(imageData) {
    // Create wrapper div
    const wrapper = document.createElement('div');
    wrapper.className = 'image-wrapper';
    wrapper.dataset.imageId = imageData.id;
    wrapper.style.left = `${imageData.position.x}px`;
    wrapper.style.top = `${imageData.position.y}px`;
    wrapper.style.width = `${imageData.size.width}px`;
    wrapper.style.height = `${imageData.size.height}px`;
    wrapper.style.pointerEvents = 'auto';
    
    // Apply rotation if exists
    if (imageData.rotation) {
        wrapper.style.transform = `rotate(${imageData.rotation}deg)`;
        wrapper.dataset.rotation = imageData.rotation;
    } else {
        wrapper.dataset.rotation = '0';
    }
    
    // Create image element
    const imgEl = document.createElement('img');
    imgEl.src = imageData.url;
    imgEl.onerror = function() {
        this.style.border = '2px dashed #ccc';
        this.style.background = '#f0f0f0';
        this.alt = 'Image failed to load';
    };
    wrapper.appendChild(imgEl);
    
    // Create resize handles
    const handles = ['top-left', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left'];
    handles.forEach(handlePos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${handlePos}`;
        handle.dataset.handle = handlePos;
        wrapper.appendChild(handle);
    });
    
    // Create rotation handle
    const rotateHandle = document.createElement('div');
    rotateHandle.className = 'rotate-handle';
    rotateHandle.dataset.handle = 'rotate';
    wrapper.appendChild(rotateHandle);
    
    // Create aspect ratio lock indicator
    if (imageData.aspectLocked !== false) {
        const lockIndicator = document.createElement('div');
        lockIndicator.className = 'aspect-lock-indicator';
        lockIndicator.innerHTML = 'üîí';
        lockIndicator.title = 'Aspect ratio locked';
        wrapper.appendChild(lockIndicator);
    }
    
    // Click to select
    wrapper.onclick = function(e) {
        selectImage(imageData.id);
        e.stopPropagation();
    };
    
    return wrapper;
}

function formatMainText(text) {
    // This function is now deprecated - contenteditable handles formatting directly
    // Kept for backward compatibility with old data
    if (!text) return '';
    
    // If text contains HTML tags, return as-is
    if (/<[a-z][\s\S]*>/i.test(text)) {
        return text;
    }
    
    // Otherwise, treat as plain text and preserve line breaks
    return text.replace(/\n/g, '<br>');
}

function updatePreviewStyles() {
    const fontFamily = document.getElementById('fontFamily').value;
    
    const editor = document.getElementById('editableContent');
    if (editor) {
        // Apply font family to all content in the editor
        editor.style.fontFamily = fontFamily;
        
        // Also apply font family to all existing elements to ensure consistency
        const allElements = editor.querySelectorAll('*');
        allElements.forEach(el => {
            // Only set font-family if it's not already explicitly set
            if (!el.style.fontFamily) {
                el.style.fontFamily = fontFamily;
            }
        });
    }
}

function addNewSlide() {
    const newSlide = {
        content: '<h1>–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ª–∞–π–¥–∞</h1><p>–ù–∞—á–Ω–∏—Ç–µ –ø–µ—á–∞—Ç–∞—Ç—å...</p>',
        role: 'CONTENT',
        images: [],
        tables: [],
        arrows: [],
        accentBoxes: [],
        background: { type: 'none', color: '#FFFFFF' }
    };
    
    slides.push(newSlide);
    renderSlidesList();
    loadSlide(slides.length - 1);
}

function deleteCurrentSlide() {
    if (slides.length <= 1) {
        alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–ª–∞–π–¥!');
        return;
    }
    
    if (!confirm(`–£–¥–∞–ª–∏—Ç—å —Å–ª–∞–π–¥ ${currentSlideIndex + 1}?`)) {
        return;
    }
    
    slides.splice(currentSlideIndex, 1);
    currentSlideIndex = Math.max(0, currentSlideIndex - 1);
    renderSlidesList();
    loadSlide(currentSlideIndex);
}

function applyToAll() {
    const fontFamily = document.getElementById('fontFamily').value;
    
    // Ensure defaultTextPosition exists
    if (!presentationSettings.defaultTextPosition) {
        presentationSettings.defaultTextPosition = {
            vertical: 'top',
            horizontal: 'left'
        };
    }
    const textPosition = presentationSettings.defaultTextPosition;
    
    slides = slides.map(slide => ({
        ...slide,
        fontFamily: fontFamily,
        textPosition: {...textPosition}
    }));
    
    alert('–°—Ç–∏–ª–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫–æ –≤—Å–µ–º —Å–ª–∞–π–¥–∞–º!');
}

function applyTemplateToAll() {
    const template = document.getElementById('templateSelect').value;
    slides = slides.map(slide => ({
        ...slide,
        template: template
    }));
}

async function generatePresentation(isUpdate = false) {
    // Save current slide
    saveCurrentSlide();
    
    // Show progress
    document.getElementById('progressBar').classList.remove('hidden');
    document.getElementById('progressBarFill').style.width = '20%';
    
    if (isUpdate && generatedPresentationId) {
        document.getElementById('progressText').textContent = '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏...';
    } else {
        document.getElementById('progressText').textContent = '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–ª–∞–π–¥–æ–≤...';
    }
    
    try {
        const response = await fetch('/process_slides', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                slides: slides,
                presentation_url: presentationUrl,
                existing_presentation_id: isUpdate ? generatedPresentationId : null,
                settings: presentationSettings
            })
        });
        
        document.getElementById('progressBarFill').style.width = '50%';
        document.getElementById('progressText').textContent = isUpdate ? '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏...' : '–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏...';
        
        const result = await response.json();
        
        document.getElementById('progressBarFill').style.width = '100%';
        document.getElementById('progressText').textContent = '–ì–æ—Ç–æ–≤–æ!';
        
        if (result.job_id) {
            window.location.href = `/job/${result.job_id}`;
        } else if (result.error) {
            alert('–û—à–∏–±–∫–∞: ' + result.error);
            document.getElementById('progressBar').classList.add('hidden');
        }
        
    } catch (error) {
        console.error('Error:', error);
        alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ ' + (isUpdate ? '–æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏' : '—Å–æ–∑–¥–∞–Ω–∏–∏') + ' –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏: ' + error);
        document.getElementById('progressBar').classList.add('hidden');
    }
}

// Initialize slide data with default values
function initializeSlideData() {
    // Ensure defaultTextPosition exists
    if (!presentationSettings.defaultTextPosition) {
        presentationSettings.defaultTextPosition = {
            vertical: 'top',
            horizontal: 'left'
        };
    }
    
    slides = slides.map(slide => ({
        ...slide,
        fontFamily: slide.fontFamily || presentationSettings.defaultFont,
        textColor: slide.textColor || '#000000',
        textPosition: slide.textPosition || {...presentationSettings.defaultTextPosition},
        images: slide.images || [],
        tables: slide.tables || [],
        arrows: slide.arrows || [],
        accentBoxes: slide.accentBoxes || []
    }));
}

// Settings persistence functions
function saveSettings() {
    presentationSettings.defaultFont = document.getElementById('fontFamily').value;
    
    try {
        localStorage.setItem(
            'presentation_settings_' + jobId,
            JSON.stringify(presentationSettings)
        );
    } catch (e) {
        console.warn('Failed to save settings to localStorage:', e);
    }
}

// Settings persistence functions
function saveSettings() {
    presentationSettings.defaultFont = document.getElementById('fontFamily').value;
    // Settings are now saved with slides to backend
}

function loadSettings() {
    // Settings are loaded from backend with slides
}

// Slides data persistence functions - ALL HANDLED BY BACKEND NOW
function saveSlides() {
    // Trigger backend save immediately
    saveToBackend();
}

function loadSlidesFromStorage() {
    // No longer used - all data comes from backend
    console.log('localStorage loading disabled - using backend only');
}

// Backend persistence functions
async function loadFromBackend() {
    if (!jobId || jobId === 'default') {
        console.warn('No job ID provided');
        return;
    }
    
    try {
        const response = await fetch(`/api/load_slides?job_id=${jobId}`);
        if (response.ok) {
            const data = await response.json();
            
            if (data.slides && data.slides.length > 0) {
                console.log(`Loaded ${data.slides.length} slides from backend`);
                
                // Use backend data
                slides = data.slides;
                if (data.settings) {
                    presentationSettings = {
                        pageOrientation: data.settings.pageOrientation || 'horizontal',
                        defaultFont: data.settings.defaultFont || 'Arial',
                        defaultFontSize: data.settings.defaultFontSize || 18,
                        defaultTextPosition: {
                            vertical: data.settings.defaultTextPosition?.vertical || 'top',
                            horizontal: data.settings.defaultTextPosition?.horizontal || 'left'
                        }
                    };
                }
                lastSavedTime = new Date(data.last_updated);
                updateLastSavedIndicator();
            } else {
                console.log('No slides in backend, using defaults');
            }
        } else {
            console.warn('Failed to load from backend');
            showLocalStorageFallbackWarning();
        }
    } catch (error) {
        console.error('Error loading from backend:', error);
        showLocalStorageFallbackWarning();
    }
}

async function saveToBackend() {
    if (!jobId || jobId === 'default' || isSaving) {
        console.log('Skipping backend save (no job ID or already saving)');
        return;
    }
    
    isSaving = true;
    updateSavingIndicator(true);
    
    try {
        // Save current slide content first
        const editor = document.getElementById('editableContent');
        if (editor && currentSlideIndex >= 0 && currentSlideIndex < slides.length) {
            slides[currentSlideIndex].content = editor.innerHTML;
        }
        
        const response = await fetch('/api/save_slides', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                job_id: jobId,
                slides: slides,
                settings: presentationSettings,
                presentation_url: presentationUrl
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            lastSavedTime = new Date(data.timestamp);
            updateLastSavedIndicator();
            console.log(`Saved ${data.slides_count} slides to backend`);
        } else {
            const error = await response.json();
            console.error('Failed to save to backend:', error);
            showSaveError();
        }
    } catch (error) {
        console.error('Error saving to backend:', error);
        showSaveError();
    } finally {
        isSaving = false;
        updateSavingIndicator(false);
    }
}

function triggerAutoSave() {
    pendingSave = true;
    
    if (saveTimer) {
        clearTimeout(saveTimer);
    }
    
    // Debounce: save 10 seconds after last change
    saveTimer = setTimeout(async () => {
        if (pendingSave) {
            await saveToBackend();
            pendingSave = false;
        }
    }, 10000); // 10 seconds
}

function startAutoSave() {
    // Periodic save every 30 seconds
    setInterval(async () => {
        if (slides && slides.length > 0 && !isSaving) {
            await saveToBackend();
        }
    }, 30000); // 30 seconds
}

// Responsive scaling setup
function setupResponsiveScaling() {
    const preview = document.getElementById('slidePreview');
    
    // Try modern ResizeObserver first
    if (typeof ResizeObserver !== 'undefined') {
        const resizeObserver = new ResizeObserver((entries) => {
            // Debounce the callback
            if (resizeDebounceTimer) {
                clearTimeout(resizeDebounceTimer);
            }
            
            resizeDebounceTimer = setTimeout(() => {
                for (let entry of entries) {
                    console.log('Preview resized to:', entry.contentRect.width, 'x', entry.contentRect.height);
                    updatePreviewStyles();
                }
            }, 150); // 150ms debounce
        });
        
        resizeObserver.observe(preview);
        console.log('ResizeObserver initialized for responsive scaling');
    } else {
        // Fallback to window resize event for older browsers
        console.log('ResizeObserver not available, using window resize fallback');
        window.addEventListener('resize', () => {
            if (resizeDebounceTimer) {
                clearTimeout(resizeDebounceTimer);
            }
            
            resizeDebounceTimer = setTimeout(() => {
                updatePreviewStyles();
            }, 200); // 200ms debounce for window resize
        });
    }
    
    // Initial calculation
    setTimeout(() => {
        updatePreviewStyles();
    }, 100);
}

function manualSave() {
    if (saveTimer) {
        clearTimeout(saveTimer);
    }
    saveToBackend();
}

// Page orientation control
function applyPageOrientation() {
    const orientation = document.getElementById('pageOrientation').value;
    presentationSettings.pageOrientation = orientation;
    
    const preview = document.getElementById('slidePreview');
    if (orientation === 'vertical') {
        // Portrait: keep height constrained and derive width from aspect ratio
        preview.style.aspectRatio = '9/16';
        preview.style.height = '60vh';
        preview.style.maxHeight = '60vh';
        preview.style.width = 'auto';
        preview.style.maxWidth = '100%';
        preview.style.display = 'inline-block';
        preview.style.marginLeft = 'auto';
        preview.style.marginRight = 'auto';
    } else {
        // Landscape: fill width but cap height
        preview.style.aspectRatio = '16/9';
        preview.style.height = 'auto';
        preview.style.maxHeight = '60vh';
        preview.style.width = '100%';
        preview.style.display = 'block';
        preview.style.marginLeft = '';
        preview.style.marginRight = '';
    }
    
    saveSettings();
    
    // Trigger font scaling recalculation after orientation change
    setTimeout(() => {
        updatePreviewStyles();
    }, 100); // Small delay to allow layout to settle
}

// Font selection control
function changeFontFamily() {
    const select = document.getElementById('fontFamily');
    const fontFamily = select.value;
    presentationSettings.defaultFont = fontFamily;

    const selectedOption = select.selectedOptions && select.selectedOptions[0];
    const isGoogleFont = selectedOption && selectedOption.dataset && selectedOption.dataset.google === 'true';

    if (isGoogleFont) {
        // Load Google Font via WebFont Loader if available, else fallback to CSS link
        if (window.WebFont && window.WebFont.load) {
            WebFont.load({ google: { families: [fontFamily] } });
        } else {
            const familyParam = fontFamily.replace(/ /g, '+');
            const href = `https://fonts.googleapis.com/css2?family=${familyParam}:wght@400;700&display=swap`;
            if (!document.querySelector(`link[data-font="${familyParam}"]`)) {
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = href;
                link.setAttribute('data-font', familyParam);
                document.head.appendChild(link);
            }
        }
    }
    updatePreviewStyles();
    saveSettings();
}

// Text positioning control
function changeTextPosition(vertical, horizontal) {
    if (vertical !== null) {
        presentationSettings.defaultTextPosition.vertical = vertical;
        
        // Update button styles
        ['posVertTop', 'posVertCenter', 'posVertBottom'].forEach(id => {
            const btn = document.getElementById(id);
            btn.classList.remove('bg-blue-100', 'border-blue-500');
            btn.classList.add('hover:bg-gray-50');
        });
        document.getElementById('posVert' + vertical.charAt(0).toUpperCase() + vertical.slice(1)).classList.add('bg-blue-100', 'border-blue-500');
    }
    
    if (horizontal !== null) {
        presentationSettings.defaultTextPosition.horizontal = horizontal;
        
        // Update button styles
        ['posHorizLeft', 'posHorizCenter', 'posHorizRight'].forEach(id => {
            const btn = document.getElementById(id);
            btn.classList.remove('bg-blue-100', 'border-blue-500');
            btn.classList.add('hover:bg-gray-50');
        });
        const horizBtnId = horizontal === 'left' ? 'posHorizLeft' : 
                           horizontal === 'center' ? 'posHorizCenter' : 'posHorizRight';
        document.getElementById(horizBtnId).classList.add('bg-blue-100', 'border-blue-500');
    }
    
    updatePreviewStyles();
    saveSettings();
}

// Background control
function changeBackgroundType(type) {
    document.getElementById('solidColorPicker').classList.toggle('hidden', type !== 'solid');
    document.getElementById('gradientPicker').classList.toggle('hidden', type !== 'gradient');
    document.getElementById('imageBgPicker').classList.toggle('hidden', type !== 'image');
    updateBackground();
}

function updateBackground() {
    const bgType = document.querySelector('input[name="bgType"]:checked').value;
    const preview = document.getElementById('slidePreview');
    
    let background = { type: bgType };
    
    if (bgType === 'none') {
        preview.style.backgroundImage = '';
        preview.style.background = '#FFFFFF';
        background.color = '#FFFFFF';
    } else if (bgType === 'solid') {
        const color = document.getElementById('bgColor').value;
        preview.style.backgroundImage = '';
        preview.style.background = color;
        background.color = color;
    } else if (bgType === 'gradient') {
        const c1 = document.getElementById('gradientColor1').value;
        const c2 = document.getElementById('gradientColor2').value;
        const dir = document.getElementById('gradientDirection').value;
        preview.style.backgroundImage = '';
        preview.style.background = `linear-gradient(${dir}, ${c1}, ${c2})`;
        background.gradient = { color1: c1, color2: c2, direction: dir };
        background.color = c1;
    } else if (bgType === 'image') {
        const currentBg = slides[currentSlideIndex].background || {};
        const imageUrl = currentBg.imageUrl || background.imageUrl;
        if (imageUrl) {
            preview.style.backgroundImage = `url(${imageUrl})`;
            preview.style.backgroundSize = 'cover';
            preview.style.backgroundPosition = 'center center';
            preview.style.backgroundColor = '';
            background.imageUrl = imageUrl;
        } else {
            preview.style.backgroundImage = '';
            preview.style.background = '#FFFFFF';
            background.color = '#FFFFFF';
        }
    }
    
    // Do NOT save huge background images into localStorage to avoid QuotaExceededError
    try {
        if (bgType !== 'image') {
            slides[currentSlideIndex].background = background;
            saveSlides();
        } else {
            slides[currentSlideIndex].background = background;
        }
    } catch (e) {
        console.warn('Failed to persist background settings:', e);
        slides[currentSlideIndex].background = background;
    }
}

function handleBackgroundImageUpload(event) {
    const file = event.target.files && event.target.files[0];
    if (!file || !file.type.startsWith('image/')) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        const dataUrl = e.target.result;
        
        // Only store background image in slides, do not push to localStorage directly (too big)
        slides[currentSlideIndex].background = {
            type: 'image',
            imageUrl: dataUrl
        };
        
        const preview = document.getElementById('slidePreview');
        preview.style.backgroundImage = `url(${dataUrl})`;
        preview.style.backgroundSize = 'cover';
        preview.style.backgroundPosition = 'center center';
        preview.style.backgroundColor = '';
        
        const info = document.getElementById('bgImagePreview');
        if (info) {
            info.textContent = '–§–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ';
        }
        
        try {
            // Try lightweight save of metadata only (without image) to avoid quota issues
            const originalBg = slides[currentSlideIndex].background;
            slides[currentSlideIndex].background = { type: 'image' };
            saveSlides();
            slides[currentSlideIndex].background = originalBg;
        } catch (e2) {
            console.warn('Skipping localStorage save for background image (too large):', e2);
        }
    };
    reader.readAsDataURL(file);
    
    event.target.value = '';
}

// Text formatting functions for contenteditable editor
function formatText(command) {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    // Check if we're in a table cell
    const range = selection.getRangeAt(0);
    let node = range.commonAncestorContainer;
    let tableCell = null;
    
    while (node && node.nodeType !== Node.DOCUMENT_NODE) {
        if (node.tagName === 'TH' || node.tagName === 'TD') {
            tableCell = node;
            break;
        }
        node = node.parentNode;
    }
    
    if (tableCell) {
        // We're in a table cell - format works directly
        document.execCommand(command, false, null);
        syncCellToData(tableCell);
    } else {
        // Normal editor content
        const editor = document.getElementById('editableContent');
        editor.focus();
        document.execCommand(command, false, null);
        syncContentToData();
    }
}

// Apply text color to selected text
function applyTextColor() {
    const color = document.getElementById('selectionTextColor').value;
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    // Check if we're in a table cell
    const range = selection.getRangeAt(0);
    let node = range.commonAncestorContainer;
    let tableCell = null;
    
    while (node && node.nodeType !== Node.DOCUMENT_NODE) {
        if (node.tagName === 'TH' || node.tagName === 'TD') {
            tableCell = node;
            break;
        }
        node = node.parentNode;
    }
    
    // Apply color to selected text using foreColor command
    document.execCommand('foreColor', false, color);
    
    if (tableCell) {
        syncCellToData(tableCell);
    } else {
        syncContentToData();
    }
}

// Toggle list - only selected text becomes list item
function toggleList(listType) {
    const editor = document.getElementById('editableContent');
    editor.focus();
    
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    
    // Check if we're already in a list
    let node = range.commonAncestorContainer;
    while (node && node !== editor) {
        if (node.tagName === 'UL' || node.tagName === 'OL') {
            // Already in list - use execCommand to toggle off
            const command = listType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
            document.execCommand(command, false, null);
            syncContentToData();
            return;
        }
        node = node.parentNode;
    }
    
    // Not in a list - check if there's selected text
    if (!range.collapsed) {
        // Text is selected - wrap only selected text in list
        const selectedText = range.toString().trim();
        
        if (selectedText) {
            // Split by newlines to create multiple list items
            const lines = selectedText.split('\n').filter(line => line.trim());
            
            // Create list HTML
            const listTag = listType === 'ul' ? 'ul' : 'ol';
            let listHTML = `<${listTag}>`;
            
            if (lines.length > 1) {
                lines.forEach(line => {
                    listHTML += `<li>${line.trim()}</li>`;
                });
            } else {
                listHTML += `<li>${selectedText}</li>`;
            }
            listHTML += `</${listTag}>`;
            
            // Delete selected content and insert list
            document.execCommand('insertHTML', false, listHTML);
        }
    } else {
        // No selection - use standard execCommand for current line
        const command = listType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
        document.execCommand(command, false, null);
    }
    
    syncContentToData();
}

// Apply list with specific style from dropdown
function applyListStyle(listType) {
    const editor = document.getElementById('editableContent');
    editor.focus();
    
    // Get selected style
    const styleDropdown = listType === 'ul' 
        ? document.getElementById('bulletListStyle')
        : document.getElementById('numberListStyle');
    const listStyle = styleDropdown.value;
    
    if (!listStyle) return;
    
    const selection = window.getSelection();
    if (!selection.rangeCount) {
        styleDropdown.selectedIndex = 0;
        return;
    }
    
    const range = selection.getRangeAt(0);
    
    // Handle "remove" option - remove list formatting
    if (listStyle === 'remove') {
        removeListFormatting();
        styleDropdown.selectedIndex = 0;
        return;
    }
    
    // Check if we're already in a list
    let node = range.commonAncestorContainer;
    let existingList = null;
    
    while (node && node !== editor) {
        if (node.tagName === 'UL' || node.tagName === 'OL') {
            existingList = node;
            break;
        }
        node = node.parentNode;
    }
    
    if (existingList) {
        // Already in a list
        const currentType = existingList.tagName.toLowerCase();
        const newType = listType;
        
        if (currentType !== newType) {
            // Convert list type using execCommand (toggle off current, toggle on new)
            // First toggle off current
            const offCommand = currentType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
            document.execCommand(offCommand, false, null);
            // Then toggle on new
            const onCommand = newType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
            document.execCommand(onCommand, false, null);
            
            // Apply style after conversion
            setTimeout(() => {
                let node = selection.anchorNode;
                while (node && node !== editor) {
                    if (node.tagName === 'UL' || node.tagName === 'OL') {
                        node.style.listStyleType = listStyle;
                        break;
                    }
                    node = node.parentNode;
                }
                syncContentToData();
            }, 10);
        } else {
            // Same type - just update style
            existingList.style.listStyleType = listStyle;
            syncContentToData();
        }
    } else if (!range.collapsed) {
        // Text is selected - wrap only selected text in list
        const selectedText = range.toString().trim();
        
        if (selectedText) {
            const lines = selectedText.split('\n').filter(line => line.trim());
            const listTag = listType === 'ul' ? 'ul' : 'ol';
            let listHTML = `<${listTag} style="list-style-type: ${listStyle};">`;
            
            if (lines.length > 1) {
                lines.forEach(line => {
                    listHTML += `<li>${line.trim()}</li>`;
                });
            } else {
                listHTML += `<li>${selectedText}</li>`;
            }
            listHTML += `</${listTag}>`;
            
            document.execCommand('insertHTML', false, listHTML);
            syncContentToData();
        }
    } else {
        // No selection, not in list - create new list
        const command = listType === 'ul' ? 'insertUnorderedList' : 'insertOrderedList';
        document.execCommand(command, false, null);
        
        // Find the created list and apply style
        setTimeout(() => {
            let node = selection.anchorNode;
            while (node && node !== editor) {
                if (node.tagName === 'UL' || node.tagName === 'OL') {
                    node.style.listStyleType = listStyle;
                    break;
                }
                node = node.parentNode;
            }
            syncContentToData();
        }, 10);
    }
    
    // Reset dropdown to placeholder
    styleDropdown.selectedIndex = 0;
}

// Remove list formatting from current position
function removeListFormatting() {
    const editor = document.getElementById('editableContent');
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    let node = range.commonAncestorContainer;
    
    while (node && node !== editor) {
        if (node.tagName === 'UL') {
            document.execCommand('insertUnorderedList', false, null);
            syncContentToData();
            return;
        }
        if (node.tagName === 'OL') {
            document.execCommand('insertOrderedList', false, null);
            syncContentToData();
            return;
        }
        node = node.parentNode;
    }
}

// Clear all formatting including lists
function clearAllFormatting() {
    const editor = document.getElementById('editableContent');
    editor.focus();
    
    // First remove list if we're in one
    removeListFormatting();
    
    // Then remove other formatting
    document.execCommand('removeFormat', false, null);
    
    syncContentToData();
}

// Apply format from dropdown (like in Word) - uses execCommand for Ctrl+Z support
function applyFormat() {
    const formatValue = document.getElementById('formatSelector').value;
    const editor = document.getElementById('editableContent');
    editor.focus();
    
    // Use formatBlock command - this supports Ctrl+Z properly
    document.execCommand('formatBlock', false, formatValue);
    
    // Update styles and save
    setTimeout(() => {
        updatePreviewStyles();
        syncContentToData();
        updateFormatSelector();
    }, 10);
}

// Apply heading level to selected text/paragraph (LEGACY - kept for compatibility)
function applyHeading() {
    // This is now handled by applyFormat()
    applyFormat();
}



// Sync editable content to slide data
function syncContentToData() {
    const editor = document.getElementById('editableContent');
    if (slides[currentSlideIndex]) {
        slides[currentSlideIndex].content = editor.innerHTML;
        
        // Trigger auto-save
        if (typeof triggerAutoSave === 'function') {
            triggerAutoSave();
        }
    }
}

// Handle keyboard shortcuts
document.addEventListener('DOMContentLoaded', function() {
    const editor = document.getElementById('editableContent');
    if (editor) {
        // Keyboard shortcuts
        editor.addEventListener('keydown', function(e) {
            // Ctrl+B for bold
            if (e.ctrlKey && e.key === 'b') {
                e.preventDefault();
                formatText('bold');
            }
            // Ctrl+I for italic
            else if (e.ctrlKey && e.key === 'i') {
                e.preventDefault();
                formatText('italic');
            }
            // Ctrl+U for underline
            else if (e.ctrlKey && e.key === 'u') {
                e.preventDefault();
                formatText('underline');
            }
        });
        
        // Update format selector on cursor movement AND selection change
        editor.addEventListener('click', updateFormatSelector);
        editor.addEventListener('keyup', updateFormatSelector);
        editor.addEventListener('mouseup', updateFormatSelector); // Detect text selection with mouse
        
        // Also listen to selectionchange event for immediate detection
        document.addEventListener('selectionchange', function() {
            const selection = window.getSelection();
            // Only update if selection is within our editor
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                if (editor.contains(container)) {
                    updateFormatSelector();
                }
            }
        });
    }
});

// Update format dropdown to show current block type
function updateFormatSelector() {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const editor = document.getElementById('editableContent');
    let node = selection.anchorNode;
    
    // If we have a selection (not just cursor), check the start of selection
    const range = selection.getRangeAt(0);
    if (!range.collapsed) {
        // Text is selected - use the node at selection start
        node = range.startContainer;
    }
    
    // Walk up the tree to find the block element
    while (node && node !== editor) {
        if (node.nodeType === Node.ELEMENT_NODE) {
            const tagName = node.tagName;
            if (tagName === 'H1' || tagName === 'H2' || tagName === 'H3' || tagName === 'H4' || tagName === 'P') {
                const dropdown = document.getElementById('formatSelector');
                if (dropdown) {
                    dropdown.value = tagName.toLowerCase();
                }
                return;
            }
        }
        node = node.parentNode;
    }
    
    // Default to 'p' if no match
    const dropdown = document.getElementById('formatSelector');
    if (dropdown) {
        dropdown.value = 'p';
    }
}

// LEGACY: Keep old name for compatibility
function updateHeadingSelector() {
    updateFormatSelector();
}

// Update font size slider to show current text size
function updateFontSizeSlider(element) {
    if (!element) return;
    
    // Get computed font size
    const computedStyle = window.getComputedStyle(element);
    const fontSize = parseInt(computedStyle.fontSize);
    
    if (fontSize) {
        const slider = document.getElementById('fontSize');
        const display = document.getElementById('fontSizeValue');
        if (slider && display) {
            slider.value = fontSize;
            display.textContent = fontSize;
            // Brief highlight to show detection
            slider.style.accentColor = '#3B82F6';
            setTimeout(() => {
                slider.style.accentColor = '';
            }, 200);
        }
    }
}

// Apply font size to selected text
function applyFontSizeToSelection() {
    const fontSize = document.getElementById('fontSize').value;
    const selection = window.getSelection();
    
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    
    // Check if we're in a table cell
    let node = range.commonAncestorContainer;
    let tableCell = null;
    let container = null;
    
    while (node && node.nodeType !== Node.DOCUMENT_NODE) {
        if (node.tagName === 'TH' || node.tagName === 'TD') {
            tableCell = node;
            container = tableCell;
            break;
        }
        if (node.id === 'editableContent') {
            container = node;
            break;
        }
        node = node.parentNode;
    }
    
    if (!container) return;
    
    // If text is selected, apply size
    if (!range.collapsed) {
        // Use execCommand to apply font size
        document.execCommand('fontSize', false, '7'); // Use a value that we'll override
        
        // Find and update all font elements that were just created
        const fontElements = container.querySelectorAll('font[size="7"]');
        fontElements.forEach(font => {
            font.removeAttribute('size');
            font.style.fontSize = fontSize + 'px';
        });
        
        // Also handle if selection already has inline styles
        const selectedElement = range.commonAncestorContainer;
        if (selectedElement.nodeType === Node.ELEMENT_NODE) {
            selectedElement.style.fontSize = fontSize + 'px';
        } else if (selectedElement.parentElement && selectedElement.parentElement !== container) {
            selectedElement.parentElement.style.fontSize = fontSize + 'px';
        }
        
        if (tableCell) {
            syncCellToData(tableCell);
        } else {
            syncContentToData();
        }
    } else {
        // No selection - apply to current block or cell
        if (tableCell) {
            tableCell.style.fontSize = fontSize + 'px';
            syncCellToData(tableCell);
        } else {
            let node = range.startContainer;
            const editor = document.getElementById('editableContent');
            while (node && node !== editor) {
                if (node.nodeType === Node.ELEMENT_NODE && 
                    (node.tagName === 'H1' || node.tagName === 'H2' || node.tagName === 'H3' || 
                     node.tagName === 'H4' || node.tagName === 'P')) {
                    node.style.fontSize = fontSize + 'px';
                    syncContentToData();
                    break;
                }
                node = node.parentNode;
            }
        }
    }
}

// Image management functions
let currentImageMode = 'url'; // Track active tab
let currentEditingImageId = null; // Track image being edited
let currentImageAspectRatio = null; // Store aspect ratio

function showImageModal() {
    currentEditingImageId = null;
    resetImageModal();
    document.getElementById('imageModal').classList.remove('hidden');
}

function closeImageModal() {
    document.getElementById('imageModal').classList.add('hidden');
    resetImageModal();
}

function resetImageModal() {
    // Reset controls
    document.getElementById('imageX').value = '100';
    document.getElementById('imageY').value = '100';
    document.getElementById('imageWidth').value = '200';
    document.getElementById('imageHeight').value = '150';
    document.getElementById('imageAspectLock').checked = true;
    document.querySelector('input[name="imageLayer"][value="background"]').checked = true;
    currentImageAspectRatio = null;
}

function switchImageTab(mode) {
    currentImageMode = mode;
    
    // Update tab buttons and content visibility
    const tabs = {
        'url': { btn: 'tabUrl', content: 'tabContentUrl' },
        'dragdrop': { btn: 'tabDragDrop', content: 'tabContentDragDrop' },
        'upload': { btn: 'tabUpload', content: 'tabContentUpload' }
    };
    
    Object.keys(tabs).forEach(tab => {
        const btn = document.getElementById(tabs[tab].btn);
        const content = document.getElementById(tabs[tab].content);
        
        if (!btn || !content) return;
        
        if (tab === mode) {
            btn.classList.add('border-blue-500', 'text-blue-500', 'font-medium');
            btn.classList.remove('border-transparent', 'text-gray-500');
            content.classList.remove('hidden');
        } else {
            btn.classList.remove('border-blue-500', 'text-blue-500', 'font-medium');
            btn.classList.add('border-transparent', 'text-gray-500');
            content.classList.add('hidden');
        }
    });
}

function handleImageSizeChange(changedDimension) {
    const aspectLocked = document.getElementById('imageAspectLock').checked;
    
    if (!aspectLocked || !currentImageAspectRatio) {
        return;
    }
    
    const widthInput = document.getElementById('imageWidth');
    const heightInput = document.getElementById('imageHeight');
    
    if (changedDimension === 'width') {
        const newWidth = parseInt(widthInput.value);
        const newHeight = Math.round(newWidth / currentImageAspectRatio);
        heightInput.value = newHeight;
    } else {
        const newHeight = parseInt(heightInput.value);
        const newWidth = Math.round(newHeight * currentImageAspectRatio);
        widthInput.value = newWidth;
    }
}

function validateImageFile(file) {
    const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'];
    const maxSize = 5 * 1024 * 1024; // 5MB
    
    if (!validTypes.includes(file.type)) {
        alert('File type not supported. Use JPG, PNG, GIF, WebP, or SVG');
        return false;
    }
    
    if (file.size > maxSize) {
        alert('File exceeds 5MB limit. Please use a smaller image');
        return false;
    }
    
    return true;
}

function processImageFile(file) {
    if (!validateImageFile(file)) {
        return;
    }
    
    const reader = new FileReader();
    
    reader.onload = function(e) {
        const dataUrl = e.target.result;
        document.getElementById('imageUrl').value = dataUrl;
        
        // Load image to get dimensions
        const img = new Image();
        img.onload = function() {
            currentImageAspectRatio = this.naturalWidth / this.naturalHeight;
            
            // Calculate default size (50% of slide width, assuming ~700px slide width)
            const defaultWidth = 300;
            const defaultHeight = Math.round(defaultWidth / currentImageAspectRatio);
            
            document.getElementById('imageWidth').value = defaultWidth;
            document.getElementById('imageHeight').value = defaultHeight;
        };
        img.src = dataUrl;
        
        // Show preview for upload tab
        if (currentImageMode === 'upload') {
            document.getElementById('fileUploadThumb').src = dataUrl;
            document.getElementById('fileUploadPreview').classList.remove('hidden');
        }
    };
    
    reader.onerror = function() {
        alert('Failed to load image. Try another file');
    };
    
    reader.readAsDataURL(file);
}

function addImage() {
    // Only allow saving changes to existing images via modal
    if (!currentEditingImageId) {
        alert('–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ Drag & Drop –Ω–∞ –ø—Ä–µ–≤—å—é —Å–ª–∞–π–¥–∞');
        return;
    }
    
    const image = slides[currentSlideIndex].images.find(img => img.id === currentEditingImageId);
    if (!image) return;
    
    const layer = document.querySelector('input[name="imageLayer"]:checked')?.value || image.layer || 'background';
    const width = parseInt(document.getElementById('imageWidth').value) || image.size.width;
    const height = parseInt(document.getElementById('imageHeight').value) || image.size.height;
    const aspectLocked = document.getElementById('imageAspectLock').checked;
    
    const updatedImage = {
        ...image,
        position: {
            x: parseInt(document.getElementById('imageX').value) || image.position.x,
            y: parseInt(document.getElementById('imageY').value) || image.position.y
        },
        size: { width, height },
        layer: layer,
        aspectRatio: image.aspectRatio || (width / height),
        aspectLocked: aspectLocked
    };
    
    const index = slides[currentSlideIndex].images.findIndex(img => img.id === currentEditingImageId);
    if (index !== -1) {
        slides[currentSlideIndex].images[index] = updatedImage;
    }
    
    updateImagesList();
    updateSlidePreview();
    closeImageModal();
}

function editImage(imageId) {
    const image = slides[currentSlideIndex].images.find(img => img.id === imageId);
    if (!image) return;
    
    currentEditingImageId = imageId;
    currentImageAspectRatio = image.aspectRatio || (image.size.width / image.size.height);
    
    // Fill modal with image data
    document.getElementById('imageX').value = image.position.x;
    document.getElementById('imageY').value = image.position.y;
    document.getElementById('imageWidth').value = image.size.width;
    document.getElementById('imageHeight').value = image.size.height;
    document.getElementById('imageAspectLock').checked = image.aspectLocked !== false;
    
    const layerRadio = document.querySelector(`input[name="imageLayer"][value="${image.layer || 'background'}"]`);
    if (layerRadio) layerRadio.checked = true;
    
    // Show modal
    document.getElementById('imageModal').classList.remove('hidden');
}

function removeImage(imageId) {
    slides[currentSlideIndex].images = slides[currentSlideIndex].images.filter(img => img.id !== imageId);
    updateImagesList();
    updateSlidePreview();
}

function updateImagesList() {
    const container = document.getElementById('imagesList');
    const images = slides[currentSlideIndex].images || [];
    
    if (images.length === 0) {
        container.innerHTML = '<div class="text-xs text-gray-500 p-2">–ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</div>';
        return;
    }
    
    container.innerHTML = images.map(img => {
        const thumbnailUrl = img.url.startsWith('data:') ? img.url : img.url;
        
        return `
            <div class="flex items-center gap-2 p-2 bg-gray-50 rounded text-xs">
                <img src="${thumbnailUrl}" class="w-10 h-10 object-cover rounded border" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2240%22 height=%2240%22%3E%3Crect fill=%22%23ddd%22 width=%2240%22 height=%2240%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2212%22%3EIMG%3C/text%3E%3C/svg%3E'">
                <span class="truncate flex-1">–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</span>
                <button onclick="removeImage('${img.id}')" class="text-red-500 hover:text-red-700 text-lg" title="–£–¥–∞–ª–∏—Ç—å">‚úï</button>
            </div>
        `;
    }).join('');
}

// Table management functions
let currentEditingTableId = null;

function showTableModal() {
    document.getElementById('tableModal').classList.remove('hidden');
}

function closeTableModal() {
    document.getElementById('tableModal').classList.add('hidden');
}

function addTable() {
    const columns = parseInt(document.getElementById('tableColumns').value);
    const width = parseInt(document.getElementById('tableWidth').value);
    
    // Initialize column widths (equal distribution)
    const defaultColWidth = Math.floor(width / columns);
    const columnWidths = [];
    for (let i = 0; i < columns; i++) {
        columnWidths.push(defaultColWidth);
    }
    
    const table = {
        id: 'tbl_' + Date.now(),
        rows: parseInt(document.getElementById('tableRows').value),
        columns: columns,
        position: {
            x: parseInt(document.getElementById('tableX').value),
            y: parseInt(document.getElementById('tableY').value)
        },
        size: {
            width: width,
            height: parseInt(document.getElementById('tableHeight').value)
        },
        columnWidths: columnWidths,
        cellData: {}
    };
    
    if (!slides[currentSlideIndex].tables) {
        slides[currentSlideIndex].tables = [];
    }
    slides[currentSlideIndex].tables.push(table);
    
    // Close table creation modal and open cell editor
    closeTableModal();
    editTableCells(table.id);
}

function editTableCells(tableId) {
    currentEditingTableId = tableId;
    const table = slides[currentSlideIndex].tables.find(t => t.id === tableId);
    if (!table) return;
    
    // Update dimensions display
    document.getElementById('tableDimensions').textContent = `${table.rows} x ${table.columns}`;
    
    // Generate cell grid
    regenerateCellGrid();
    
    document.getElementById('tableCellEditorModal').classList.remove('hidden');
}

function regenerateCellGrid() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    const grid = document.getElementById('tableCellGrid');
    let html = '<div class="overflow-x-auto"><table class="w-full border-collapse border">';
    
    // Header row with column delete buttons
    html += '<tr>';
    html += '<th class="border p-1 bg-gray-100 w-10"></th>'; // Empty corner cell
    for (let col = 0; col < table.columns; col++) {
        html += `<th class="border p-1 bg-gray-100 text-center">
            <div class="flex items-center justify-center gap-1">
                <span class="text-xs text-gray-500">–°${col + 1}</span>
                ${table.columns > 1 ? `<button onclick="removeTableColumnAt(${col})" class="text-red-500 hover:text-red-700 text-xs" title="–£–¥–∞–ª–∏—Ç—å —Å—Ç–æ–ª–±–µ—Ü ${col + 1}">‚úï</button>` : ''}
            </div>
        </th>`;
    }
    html += '</tr>';
    
    // Data rows with row delete buttons
    for (let row = 0; row < table.rows; row++) {
        html += '<tr>';
        // Row header with delete button
        html += `<td class="border p-1 bg-gray-100 text-center">
            <div class="flex items-center justify-center gap-1">
                <span class="text-xs text-gray-500">–†${row + 1}</span>
                ${table.rows > 1 ? `<button onclick="removeTableRowAt(${row})" class="text-red-500 hover:text-red-700 text-xs" title="–£–¥–∞–ª–∏—Ç—å —Å—Ç—Ä–æ–∫—É ${row + 1}">‚úï</button>` : ''}
            </div>
        </td>`;
        for (let col = 0; col < table.columns; col++) {
            const cellKey = `${row}_${col}`;
            const cellValue = table.cellData[cellKey] || '';
            const escapedValue = cellValue.replace(/"/g, '&quot;');
            html += `<td class="border p-1">
                <input type="text" 
                       id="cell_${cellKey}" 
                       value="${escapedValue}" 
                       class="w-full p-2 border rounded text-sm" 
                       placeholder="R${row+1}C${col+1}">
            </td>`;
        }
        html += '</tr>';
    }
    html += '</table></div>';
    grid.innerHTML = html;
    
    // Update dimensions display
    document.getElementById('tableDimensions').textContent = `${table.rows} x ${table.columns}`;
}

function addTableRow() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    // Save current cell data first
    saveCellDataTemporary();
    
    // Add new row
    table.rows++;
    
    // Initialize new row cells
    for (let col = 0; col < table.columns; col++) {
        const cellKey = `${table.rows - 1}_${col}`;
        table.cellData[cellKey] = '';
    }
    
    // Regenerate the grid
    regenerateCellGrid();
}

function addTableColumn() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    // Save current cell data first
    saveCellDataTemporary();
    
    // Add new column
    table.columns++;
    
    // Add column width (take from last column or default)
    const newColWidth = table.columnWidths && table.columnWidths.length > 0 
        ? table.columnWidths[table.columnWidths.length - 1] 
        : 100;
    if (!table.columnWidths) table.columnWidths = [];
    table.columnWidths.push(newColWidth);
    
    // Update table total width
    table.size.width += newColWidth;
    
    // Initialize new column cells
    for (let row = 0; row < table.rows; row++) {
        const cellKey = `${row}_${table.columns - 1}`;
        table.cellData[cellKey] = '';
    }
    
    // Regenerate the grid
    regenerateCellGrid();
}

function removeTableRow() {
    // Legacy function - remove last row
    removeTableRowAt(-1);
}

function removeTableRowAt(rowIndex) {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table || table.rows <= 1) {
        alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ–∫—É!');
        return;
    }
    
    // If -1, remove last row
    if (rowIndex === -1) rowIndex = table.rows - 1;
    
    // Save current cell data first
    saveCellDataTemporary();
    
    // Shift all rows after the deleted one up
    const newCellData = {};
    for (let row = 0; row < table.rows; row++) {
        for (let col = 0; col < table.columns; col++) {
            const oldKey = `${row}_${col}`;
            if (row < rowIndex) {
                // Keep rows before the deleted one
                newCellData[oldKey] = table.cellData[oldKey] || '';
            } else if (row > rowIndex) {
                // Shift rows after the deleted one
                const newKey = `${row - 1}_${col}`;
                newCellData[newKey] = table.cellData[oldKey] || '';
            }
            // Skip the deleted row
        }
    }
    
    table.cellData = newCellData;
    table.rows--;
    
    // Regenerate the grid
    regenerateCellGrid();
}

function removeTableColumn() {
    // Legacy function - remove last column
    removeTableColumnAt(-1);
}

function removeTableColumnAt(colIndex) {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table || table.columns <= 1) {
        alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å—Ç–æ–ª–±–µ—Ü!');
        return;
    }
    
    // If -1, remove last column
    if (colIndex === -1) colIndex = table.columns - 1;
    
    // Save current cell data first
    saveCellDataTemporary();
    
    // Remove column width and update table width
    if (table.columnWidths && table.columnWidths.length > colIndex) {
        const removedWidth = table.columnWidths[colIndex];
        table.columnWidths.splice(colIndex, 1);
        table.size.width -= removedWidth;
    }
    
    // Shift all columns after the deleted one left
    const newCellData = {};
    for (let row = 0; row < table.rows; row++) {
        for (let col = 0; col < table.columns; col++) {
            const oldKey = `${row}_${col}`;
            if (col < colIndex) {
                // Keep columns before the deleted one
                newCellData[oldKey] = table.cellData[oldKey] || '';
            } else if (col > colIndex) {
                // Shift columns after the deleted one
                const newKey = `${row}_${col - 1}`;
                newCellData[newKey] = table.cellData[oldKey] || '';
            }
            // Skip the deleted column
        }
    }
    
    table.cellData = newCellData;
    table.columns--;
    
    // Regenerate the grid
    regenerateCellGrid();
}

function saveCellDataTemporary() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    // Collect cell data from inputs
    for (let row = 0; row < table.rows; row++) {
        for (let col = 0; col < table.columns; col++) {
            const cellKey = `${row}_${col}`;
            const input = document.getElementById(`cell_${cellKey}`);
            if (input) {
                table.cellData[cellKey] = input.value;
            }
        }
    }
}

function saveCellData() {
    const table = slides[currentSlideIndex].tables.find(t => t.id === currentEditingTableId);
    if (!table) return;
    
    // Collect cell data from inputs
    for (let row = 0; row < table.rows; row++) {
        for (let col = 0; col < table.columns; col++) {
            const cellKey = `${row}_${col}`;
            const input = document.getElementById(`cell_${cellKey}`);
            if (input) {
                table.cellData[cellKey] = input.value;
            }
        }
    }
    
    closeCellEditor();
    updateTablesList();
    renderPreviewTables();
    saveSlides();
}

function closeCellEditor() {
    document.getElementById('tableCellEditorModal').classList.add('hidden');
    currentEditingTableId = null;
}

function removeTable(tableId) {
    slides[currentSlideIndex].tables = slides[currentSlideIndex].tables.filter(tbl => tbl.id !== tableId);
    updateTablesList();
    renderPreviewTables();
    saveSlides();
}

function updateTablesList() {
    const container = document.getElementById('tablesList');
    const tables = slides[currentSlideIndex].tables || [];
    
    if (tables.length === 0) {
        container.innerHTML = '<div class="text-xs text-gray-500 p-2">–ù–µ—Ç —Ç–∞–±–ª–∏—Ü</div>';
        return;
    }
    
    container.innerHTML = tables.map(tbl => `
        <div class="flex items-center justify-between p-2 bg-gray-50 rounded text-xs">
            <span>–¢–∞–±–ª–∏—Ü–∞ ${tbl.rows}x${tbl.columns}</span>
            <div class="flex gap-1">
                <button onclick="editTableCells('${tbl.id}')" class="text-blue-500 hover:text-blue-700" title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å">‚úé</button>
                <button onclick="removeTable('${tbl.id}')" class="text-red-500 hover:text-red-700" title="–£–¥–∞–ª–∏—Ç—å">‚úï</button>
            </div>
        </div>
    `).join('');
    
    // Re-render tables on preview
    renderPreviewTables();
}

// Table rendering functions
let selectedTableId = null;

function renderPreviewTables() {
    const tables = slides[currentSlideIndex].tables || [];
    const tablesContainer = document.getElementById('previewTables');
    
    // Clear existing tables
    tablesContainer.innerHTML = '';
    
    // Deselect all tables when re-rendering
    deselectAllTables();
    
    // Render all tables
    tables.forEach(tbl => {
        const wrapper = createTableWrapper(tbl);
        tablesContainer.appendChild(wrapper);
    });
    
    // Initialize Interact.js on all new table wrappers
    setTimeout(() => {
        if (typeof interact !== 'undefined') {
            initializeTableInteractions();
        }
    }, 50);
}

function createTableWrapper(tableData) {
    // Create wrapper div
    const wrapper = document.createElement('div');
    wrapper.className = 'table-wrapper';
    wrapper.dataset.tableId = tableData.id;
    wrapper.style.left = `${tableData.position.x}px`;
    wrapper.style.top = `${tableData.position.y}px`;
    
    // Initialize column widths if not present
    if (!tableData.columnWidths || tableData.columnWidths.length !== tableData.columns) {
        const defaultColWidth = Math.floor(tableData.size.width / tableData.columns);
        tableData.columnWidths = [];
        for (let i = 0; i < tableData.columns; i++) {
            tableData.columnWidths.push(defaultColWidth);
        }
    }
    
    // Calculate total width from column widths
    const totalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
    wrapper.style.width = `${totalWidth + 12}px`; // +12 for padding (6px on each side)
    wrapper.style.height = 'auto';
    wrapper.style.pointerEvents = 'auto';
    
    // Create table element
    const tableEl = document.createElement('table');
    
    // Create colgroup for column widths
    const colgroup = document.createElement('colgroup');
    for (let col = 0; col < tableData.columns; col++) {
        const colEl = document.createElement('col');
        colEl.style.width = `${tableData.columnWidths[col]}px`;
        colEl.dataset.colIndex = col;
        colgroup.appendChild(colEl);
    }
    tableEl.appendChild(colgroup);
    
    for (let row = 0; row < tableData.rows; row++) {
        const tr = document.createElement('tr');
        for (let col = 0; col < tableData.columns; col++) {
            const td = row === 0 ? document.createElement('th') : document.createElement('td');
            const cellKey = `${row}_${col}`;
            
            // Make cell editable
            td.contentEditable = 'true';
            td.dataset.row = row;
            td.dataset.col = col;
            td.dataset.tableId = tableData.id;
            
            // Set cell content (supports HTML formatting)
            const cellContent = tableData.cellData[cellKey] || '';
            // Check if it's HTML or plain text
            if (cellContent.includes('<') && cellContent.includes('>')) {
                td.innerHTML = cellContent;
            } else {
                td.innerHTML = cellContent.replace(/\n/g, '<br>');
            }
            
            // Handle input - sync to data
            td.addEventListener('input', (e) => {
                syncCellToData(e.target);
            });
            
            // Handle keydown for Enter
            td.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    // Allow default Enter behavior for line break
                    // Shift+Enter or just Enter both add line break
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    // Move to next/previous cell
                    navigateTableCell(e.target, e.shiftKey ? -1 : 1);
                } else if (e.key === 'Escape') {
                    e.target.blur();
                }
            });
            
            // Prevent table drag when editing
            td.addEventListener('mousedown', (e) => {
                e.stopPropagation();
            });
            
            tr.appendChild(td);
        }
        tableEl.appendChild(tr);
    }
    
    wrapper.appendChild(tableEl);
    
    // Apply saved font size if set
    if (tableData.fontSize && tableData.fontSize !== 12) {
        tableEl.style.fontSize = `${tableData.fontSize}px`;
    }
    
    // Create column resize handles (between columns)
    let xOffset = 6; // Start after left padding
    for (let col = 0; col < tableData.columns - 1; col++) {
        xOffset += tableData.columnWidths[col];
        const colHandle = document.createElement('div');
        colHandle.className = 'col-resize-handle';
        colHandle.dataset.colIndex = col;
        colHandle.style.left = `${xOffset + 3}px`; // center on column edge
        
        // Add mouse events for column resizing
        colHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            startColumnResize(e, tableData.id, col);
        });
        
        wrapper.appendChild(colHandle);
    }
    
    // Create edge resize handles (left and right edges)
    const leftEdge = document.createElement('div');
    leftEdge.className = 'edge-resize-handle left';
    leftEdge.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        startEdgeResize(e, tableData.id, 'left');
    });
    wrapper.appendChild(leftEdge);
    
    const rightEdge = document.createElement('div');
    rightEdge.className = 'edge-resize-handle right';
    rightEdge.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        startEdgeResize(e, tableData.id, 'right');
    });
    wrapper.appendChild(rightEdge);
    
    // Create corner resize handles
    const corners = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    corners.forEach(corner => {
        const cornerHandle = document.createElement('div');
        cornerHandle.className = `corner-resize-handle ${corner}`;
        cornerHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            startCornerResize(e, tableData.id, corner);
        });
        wrapper.appendChild(cornerHandle);
    });
    
    // Click to select
    wrapper.onclick = function(e) {
        // Don't select when clicking on cells or resize handles (they handle their own editing)
        if (e.target.tagName === 'TH' || e.target.tagName === 'TD') {
            return;
        }
        if (e.target.classList.contains('col-resize-handle') || e.target.classList.contains('edge-resize-handle') || e.target.classList.contains('corner-resize-handle')) {
            return;
        }
        selectTable(tableData.id);
        e.stopPropagation();
    };
    
    // Double click - no longer opens modal, cells are directly editable
    wrapper.ondblclick = function(e) {
        e.stopPropagation();
    };
    
    return wrapper;
}

// Column resize functionality
let isResizingColumn = false;
let resizingTableId = null;
let resizingColIndex = null;
let resizeStartX = 0;
let resizeStartWidths = []; // Store all column widths at start

function startColumnResize(e, tableId, colIndex) {
    e.preventDefault();
    isResizingColumn = true;
    resizingTableId = tableId;
    resizingColIndex = colIndex;
    resizeStartX = e.clientX;
    
    const tableData = getTableData(tableId);
    // Store a copy of all column widths at start
    resizeStartWidths = [...tableData.columnWidths];
    
    // Add highlight to resize handle
    const handle = e.target;
    handle.classList.add('resizing');
    
    document.addEventListener('mousemove', handleColumnResize);
    document.addEventListener('mouseup', stopColumnResize);
}

function handleColumnResize(e) {
    if (!isResizingColumn) return;
    
    const tableData = getTableData(resizingTableId);
    if (!tableData) return;
    
    const deltaX = e.clientX - resizeStartX;
    
    // Calculate new width for the current column
    const newWidth = Math.max(30, resizeStartWidths[resizingColIndex] + deltaX);
    
    // Update only the resized column, keep total table width
    tableData.columnWidths[resizingColIndex] = newWidth;
    
    // Recalculate total width
    const totalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
    tableData.size.width = totalWidth;
    
    // Update the table wrapper and column widths directly without full re-render
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${resizingTableId}"]`);
    if (wrapper) {
        wrapper.style.width = `${totalWidth + 12}px`; // +12 for padding
        
        // Update colgroup widths
        const cols = wrapper.querySelectorAll('col');
        tableData.columnWidths.forEach((w, i) => {
            if (cols[i]) cols[i].style.width = `${w}px`;
        });
        
        // Update column resize handle positions
        updateColumnHandlePositions(wrapper, tableData);
    }
    
    // Show tooltip
    showDimensionTooltip(
        e.clientX + 10,
        e.clientY + 10,
        `–°—Ç–æ–ª–±–µ—Ü ${resizingColIndex + 1}: ${newWidth}px`
    );
}

function stopColumnResize(e) {
    if (!isResizingColumn) return;
    
    isResizingColumn = false;
    hideDimensionTooltip();
    
    // Remove highlight from all resize handles
    document.querySelectorAll('.col-resize-handle.resizing').forEach(h => h.classList.remove('resizing'));
    
    document.removeEventListener('mousemove', handleColumnResize);
    document.removeEventListener('mouseup', stopColumnResize);
    
    resizingTableId = null;
    resizingColIndex = null;
    resizeStartWidths = [];
    
    debouncedSave();
}

// Edge resize functionality (left/right edges resize first/last column)
let isResizingEdge = false;
let resizingEdgeTableId = null;
let resizingEdgeSide = null; // 'left' or 'right'
let edgeResizeStartX = 0;
let edgeResizeStartWidth = 0;
let edgeResizeStartPosition = 0;

function startEdgeResize(e, tableId, side) {
    e.preventDefault();
    isResizingEdge = true;
    resizingEdgeTableId = tableId;
    resizingEdgeSide = side;
    edgeResizeStartX = e.clientX;
    
    const tableData = getTableData(tableId);
    if (!tableData) return;
    
    if (side === 'left') {
        edgeResizeStartWidth = tableData.columnWidths[0];
        edgeResizeStartPosition = tableData.position.x;
    } else {
        edgeResizeStartWidth = tableData.columnWidths[tableData.columns - 1];
    }
    
    // Add highlight
    e.target.classList.add('resizing');
    
    document.addEventListener('mousemove', handleEdgeResize);
    document.addEventListener('mouseup', stopEdgeResize);
}

function handleEdgeResize(e) {
    if (!isResizingEdge) return;
    
    const tableData = getTableData(resizingEdgeTableId);
    if (!tableData) return;
    
    const deltaX = e.clientX - edgeResizeStartX;
    
    if (resizingEdgeSide === 'left') {
        // Left edge: resize first column, move table position
        const newWidth = Math.max(30, edgeResizeStartWidth - deltaX);
        const widthDelta = edgeResizeStartWidth - newWidth;
        
        tableData.columnWidths[0] = newWidth;
        tableData.position.x = edgeResizeStartPosition + widthDelta;
    } else {
        // Right edge: resize last column
        const newWidth = Math.max(30, edgeResizeStartWidth + deltaX);
        tableData.columnWidths[tableData.columns - 1] = newWidth;
    }
    
    // Recalculate total width
    const totalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
    tableData.size.width = totalWidth;
    
    // Update visual
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${resizingEdgeTableId}"]`);
    if (wrapper) {
        wrapper.style.width = `${totalWidth + 12}px`; // +12 for padding
        wrapper.style.left = `${tableData.position.x}px`;
        
        // Update colgroup widths
        const cols = wrapper.querySelectorAll('col');
        tableData.columnWidths.forEach((w, i) => {
            if (cols[i]) cols[i].style.width = `${w}px`;
        });
        
        // Update column resize handle positions
        updateColumnHandlePositions(wrapper, tableData);
    }
    
    // Show tooltip
    const colIndex = resizingEdgeSide === 'left' ? 0 : tableData.columns - 1;
    const colWidth = tableData.columnWidths[colIndex];
    showDimensionTooltip(
        e.clientX + 10,
        e.clientY + 10,
        `–°—Ç–æ–ª–±–µ—Ü ${colIndex + 1}: ${colWidth}px`
    );
}

function stopEdgeResize(e) {
    if (!isResizingEdge) return;
    
    isResizingEdge = false;
    hideDimensionTooltip();
    
    // Remove highlight
    document.querySelectorAll('.edge-resize-handle.resizing').forEach(h => h.classList.remove('resizing'));
    
    document.removeEventListener('mousemove', handleEdgeResize);
    document.removeEventListener('mouseup', stopEdgeResize);
    
    resizingEdgeTableId = null;
    resizingEdgeSide = null;
    
    debouncedSave();
}

function updateColumnHandlePositions(wrapper, tableData) {
    const handles = wrapper.querySelectorAll('.col-resize-handle');
    let xOffset = 6; // Start after left padding
    for (let i = 0; i < tableData.columns - 1; i++) {
        xOffset += tableData.columnWidths[i];
        if (handles[i]) handles[i].style.left = `${xOffset + 3}px`;
    }
}

// Corner resize functionality (proportional scale of entire table)
let isResizingCorner = false;
let resizingCornerTableId = null;
let resizingCornerPosition = null; // 'top-left', 'top-right', 'bottom-left', 'bottom-right'
let cornerResizeStartX = 0;
let cornerResizeStartY = 0;
let cornerResizeStartWidths = [];
let cornerResizeStartFontSize = 12;
let cornerResizeStartTotalWidth = 0;
let cornerResizeStartPosition = { x: 0, y: 0 };

function startCornerResize(e, tableId, corner) {
    e.preventDefault();
    isResizingCorner = true;
    resizingCornerTableId = tableId;
    resizingCornerPosition = corner;
    cornerResizeStartX = e.clientX;
    cornerResizeStartY = e.clientY;
    
    const tableData = getTableData(tableId);
    if (!tableData) return;
    
    cornerResizeStartWidths = [...tableData.columnWidths];
    cornerResizeStartTotalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
    cornerResizeStartFontSize = tableData.fontSize || 12;
    cornerResizeStartPosition = { x: tableData.position.x, y: tableData.position.y };
    
    document.addEventListener('mousemove', handleCornerResize);
    document.addEventListener('mouseup', stopCornerResize);
}

function handleCornerResize(e) {
    if (!isResizingCorner) return;
    
    const tableData = getTableData(resizingCornerTableId);
    if (!tableData) return;
    
    const deltaX = e.clientX - cornerResizeStartX;
    const deltaY = e.clientY - cornerResizeStartY;
    
    // Calculate scale based on diagonal movement
    let scaleDeltaX = 0;
    let scaleDeltaY = 0;
    let moveX = false;
    let moveY = false;
    
    if (resizingCornerPosition.includes('left')) {
        scaleDeltaX = -deltaX;
        moveX = true;
    } else {
        scaleDeltaX = deltaX;
    }
    
    if (resizingCornerPosition.includes('top')) {
        scaleDeltaY = -deltaY;
        moveY = true;
    } else {
        scaleDeltaY = deltaY;
    }
    
    // Use average of X and Y deltas for proportional scaling
    const avgDelta = (scaleDeltaX + scaleDeltaY) / 2;
    const scaleFactor = Math.max(0.3, Math.min(3, 1 + (avgDelta / cornerResizeStartTotalWidth)));
    
    // Apply proportional scaling to all columns
    for (let i = 0; i < tableData.columns; i++) {
        tableData.columnWidths[i] = Math.max(20, Math.round(cornerResizeStartWidths[i] * scaleFactor));
    }
    
    // Scale font size proportionally
    const newFontSize = Math.max(8, Math.min(48, Math.round(cornerResizeStartFontSize * scaleFactor)));
    tableData.fontSize = newFontSize;
    
    // Recalculate total width
    const totalWidth = tableData.columnWidths.reduce((sum, w) => sum + w, 0);
    tableData.size.width = totalWidth;
    
    // Update position if resizing from left or top
    if (moveX) {
        tableData.position.x = cornerResizeStartPosition.x - (totalWidth - cornerResizeStartTotalWidth);
    }
    
    // Update visual
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${resizingCornerTableId}"]`);
    if (wrapper) {
        wrapper.style.width = `${totalWidth + 12}px`;
        wrapper.style.left = `${tableData.position.x}px`;
        
        // Update font size
        const tableEl = wrapper.querySelector('table');
        if (tableEl) {
            tableEl.style.fontSize = `${newFontSize}px`;
        }
        
        // Update colgroup widths
        const cols = wrapper.querySelectorAll('col');
        tableData.columnWidths.forEach((w, i) => {
            if (cols[i]) cols[i].style.width = `${w}px`;
        });
        
        // Update column resize handle positions
        updateColumnHandlePositions(wrapper, tableData);
        
        // Update Y position if resizing from top
        if (moveY) {
            const heightDiff = wrapper.offsetHeight - (wrapper.dataset.startHeight || wrapper.offsetHeight);
            // For top corners, we need to track height change differently
            // Since height is auto, we just update position based on scale
        }
    }
    
    // Show tooltip
    showDimensionTooltip(
        e.clientX + 10,
        e.clientY + 10,
        `${Math.round(scaleFactor * 100)}% (${newFontSize}px)`
    );
}

function stopCornerResize(e) {
    if (!isResizingCorner) return;
    
    isResizingCorner = false;
    hideDimensionTooltip();
    
    document.removeEventListener('mousemove', handleCornerResize);
    document.removeEventListener('mouseup', stopCornerResize);
    
    resizingCornerTableId = null;
    resizingCornerPosition = null;
    cornerResizeStartWidths = [];
    
    debouncedSave();
}

function selectTable(tableId) {
    deselectAllTables();
    deselectAllImages();
    
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${tableId}"]`);
    if (wrapper) {
        wrapper.classList.add('selected');
        selectedTableId = tableId;
    }
}

function deselectAllTables() {
    document.querySelectorAll('.table-wrapper.selected').forEach(el => {
        el.classList.remove('selected');
    });
    selectedTableId = null;
}

function getTableData(tableId) {
    const tables = slides[currentSlideIndex].tables || [];
    return tables.find(t => t.id === tableId);
}

// Sync cell content to data model (preserves HTML formatting)
function syncCellToData(cell) {
    const tableId = cell.dataset.tableId;
    const row = parseInt(cell.dataset.row);
    const col = parseInt(cell.dataset.col);
    
    const tableData = getTableData(tableId);
    if (!tableData) return;
    
    // Store the HTML content directly to preserve formatting
    const cellKey = `${row}_${col}`;
    tableData.cellData[cellKey] = cell.innerHTML;
    
    // Update table height based on content
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${tableId}"]`);
    if (wrapper) {
        // Get the actual rendered height of the table
        tableData.size.height = wrapper.offsetHeight;
    }
    
    // Debounce save
    debouncedSave();
}

// Navigate between cells with Tab key
function navigateTableCell(currentCell, direction) {
    const tableId = currentCell.dataset.tableId;
    const currentRow = parseInt(currentCell.dataset.row);
    const currentCol = parseInt(currentCell.dataset.col);
    
    const tableData = getTableData(tableId);
    if (!tableData) return;
    
    let newRow = currentRow;
    let newCol = currentCol + direction;
    
    // Handle column overflow
    if (newCol >= tableData.columns) {
        newCol = 0;
        newRow++;
    } else if (newCol < 0) {
        newCol = tableData.columns - 1;
        newRow--;
    }
    
    // Handle row overflow
    if (newRow >= tableData.rows) {
        newRow = 0;
    } else if (newRow < 0) {
        newRow = tableData.rows - 1;
    }
    
    // Find and focus the target cell
    const wrapper = document.querySelector(`.table-wrapper[data-table-id="${tableId}"]`);
    if (wrapper) {
        const targetCell = wrapper.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
        if (targetCell) {
            targetCell.focus();
            // Select all content in the cell
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(targetCell);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }
}

function initializeTableInteractions() {
    if (typeof interact === 'undefined') {
        console.error('Interact.js not loaded yet');
        return;
    }
    
    const wrappers = document.querySelectorAll('.table-wrapper');
    console.log('Initializing Interact.js on', wrappers.length, 'table wrappers');
    
    wrappers.forEach(wrapper => {
        const tableId = wrapper.dataset.tableId;
        const tableData = getTableData(tableId);
        
        if (!tableData) return;
        
        // Configure draggable - allow dragging from empty space only
        interact(wrapper)
            .draggable({
                inertia: false,
                ignoreFrom: 'th, td, .col-resize-handle, .edge-resize-handle, .corner-resize-handle',
                modifiers: [
                    interact.modifiers.restrictRect({
                        restriction: 'parent',
                        endOnly: true
                    })
                ],
                listeners: {
                    start: (event) => {
                        event.target.classList.add('dragging');
                    },
                    move: (event) => {
                        const target = event.target;
                        const tableData = getTableData(tableId);
                        
                        // Update position
                        const x = (parseFloat(target.style.left) || 0) + event.dx;
                        const y = (parseFloat(target.style.top) || 0) + event.dy;
                        
                        target.style.left = `${x}px`;
                        target.style.top = `${y}px`;
                        
                        // Update data model
                        if (tableData) {
                            tableData.position.x = Math.round(x);
                            tableData.position.y = Math.round(y);
                        }
                        
                        // Show position tooltip
                        showDimensionTooltip(
                            event.clientX + 10,
                            event.clientY + 10,
                            `X: ${Math.round(x)}, Y: ${Math.round(y)}`
                        );
                    },
                    end: (event) => {
                        event.target.classList.remove('dragging');
                        hideDimensionTooltip();
                        debouncedSave();
                    }
                }
            });
    });
}

// Arrow management functions
function showArrowModal() {
    document.getElementById('arrowModal').classList.remove('hidden');
}

function closeArrowModal() {
    document.getElementById('arrowModal').classList.add('hidden');
}

function addArrow() {
    const arrow = {
        id: 'arr_' + Date.now(),
        type: document.getElementById('arrowType').value,
        startPoint: {
            x: parseInt(document.getElementById('arrowStartX').value),
            y: parseInt(document.getElementById('arrowStartY').value)
        },
        endPoint: {
            x: parseInt(document.getElementById('arrowEndX').value),
            y: parseInt(document.getElementById('arrowEndY').value)
        },
        color: document.getElementById('arrowColor').value,
        strokeWidth: parseInt(document.getElementById('arrowStroke').value)
    };
    
    if (!slides[currentSlideIndex].arrows) {
        slides[currentSlideIndex].arrows = [];
    }
    slides[currentSlideIndex].arrows.push(arrow);
    
    updateArrowsList();
    closeArrowModal();
}

function removeArrow(arrowId) {
    slides[currentSlideIndex].arrows = slides[currentSlideIndex].arrows.filter(arr => arr.id !== arrowId);
    updateArrowsList();
}

function updateArrowsList() {
    const container = document.getElementById('arrowsList');
    const arrows = slides[currentSlideIndex].arrows || [];
    
    if (arrows.length === 0) {
        container.innerHTML = '<div class="text-xs text-gray-500 p-2">–ù–µ—Ç —Å—Ç—Ä–µ–ª–æ–∫</div>';
        return;
    }
    
    container.innerHTML = arrows.map(arr => `
        <div class="flex items-center justify-between p-2 bg-gray-50 rounded text-xs">
            <span>–°—Ç—Ä–µ–ª–∫–∞ (${arr.type})</span>
            <button onclick="removeArrow('${arr.id}')" class="text-red-500 hover:text-red-700 ml-2">‚úï</button>
        </div>
    `).join('');
}

// Accent Box management functions
function showAccentBoxModal() {
    document.getElementById('accentBoxModal').classList.remove('hidden');
}

function closeAccentBoxModal() {
    document.getElementById('accentBoxModal').classList.add('hidden');
}

function addAccentBox() {
    const box = {
        id: 'accent_' + Date.now(),
        text: document.getElementById('accentText').value,
        position: {
            x: parseInt(document.getElementById('accentX').value),
            y: parseInt(document.getElementById('accentY').value)
        },
        size: {
            width: parseInt(document.getElementById('accentWidth').value),
            height: parseInt(document.getElementById('accentHeight').value)
        },
        backgroundColor: document.getElementById('accentBgColor').value,
        borderColor: document.getElementById('accentBorderColor').value,
        borderWidth: 2,
        textColor: '#1E1B4B',
        fontSize: 14
    };
    
    if (!slides[currentSlideIndex].accentBoxes) {
        slides[currentSlideIndex].accentBoxes = [];
    }
    slides[currentSlideIndex].accentBoxes.push(box);
    
    updateAccentBoxesList();
    closeAccentBoxModal();
}

function removeAccentBox(boxId) {
    slides[currentSlideIndex].accentBoxes = slides[currentSlideIndex].accentBoxes.filter(box => box.id !== boxId);
    updateAccentBoxesList();
}

function updateAccentBoxesList() {
    const container = document.getElementById('accentBoxesList');
    const boxes = slides[currentSlideIndex].accentBoxes || [];
    
    if (boxes.length === 0) {
        container.innerHTML = '<div class="text-xs text-gray-500 p-2">–ù–µ—Ç –∞–∫—Ü–µ–Ω—Ç–Ω—ã—Ö –±–ª–æ–∫–æ–≤</div>';
        return;
    }
    
    container.innerHTML = boxes.map(box => `
        <div class="flex items-center justify-between p-2 bg-gray-50 rounded text-xs">
            <span>–ë–ª–æ–∫: ${box.text.substring(0, 20)}${box.text.length > 20 ? '...' : ''}</span>
            <button onclick="removeAccentBox('${box.id}')" class="text-red-500 hover:text-red-700 ml-2">‚úï</button>
        </div>
    `).join('');
}

// Drag and drop setup for slide preview
function setupPreviewDragDrop() {
    const preview = document.getElementById('slidePreview');
    
    preview.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        preview.classList.add('border-blue-500', 'bg-blue-50');
    });
    
    preview.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        preview.classList.remove('border-blue-500', 'bg-blue-50');
    });
    
    preview.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        preview.classList.remove('border-blue-500', 'bg-blue-50');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            // Get drop position relative to preview
            const rect = preview.getBoundingClientRect();
            const x = Math.round(e.clientX - rect.left);
            const y = Math.round(e.clientY - rect.top);
            
            // Process first file
            const file = files[0];
            if (validateImageFile(file)) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const dataUrl = event.target.result;
                    
                    // Load image to get dimensions
                    const img = new Image();
                    img.onload = function() {
                        const aspectRatio = this.naturalWidth / this.naturalHeight;
                        const defaultWidth = 200;
                        const defaultHeight = Math.round(defaultWidth / aspectRatio);
                        
                        // Add image directly to slide
                        const imageData = {
                            id: 'img_' + Date.now(),
                            url: dataUrl,
                            position: { x: x, y: y },
                            size: { width: defaultWidth, height: defaultHeight },
                            rotation: 0,
                            aspectRatio: aspectRatio,
                            aspectLocked: true
                        };
                        
                        if (!slides[currentSlideIndex].images) {
                            slides[currentSlideIndex].images = [];
                        }
                        slides[currentSlideIndex].images.push(imageData);
                        
                        updateImagesList();
                        updateSlidePreview();
                    };
                    img.src = dataUrl;
                };
                reader.readAsDataURL(file);
            }
        }
    });
}

// File input handlers setup
function setupFileInputHandlers() {
    // Drop zone click handler
    const dropZone = document.getElementById('dropZone');
    const dropZoneInput = document.getElementById('dropZoneFileInput');
    
    if (dropZone && dropZoneInput) {
        dropZone.addEventListener('click', () => {
            dropZoneInput.click();
        });
        
        dropZoneInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                processImageFile(file);
                document.getElementById('dropZoneFileName').textContent = `Selected: ${file.name}`;
                document.getElementById('dropZoneFileName').classList.remove('hidden');
            }
        });
    }
    
    // Upload file input handler
    const fileUploadInput = document.getElementById('fileUploadInput');
    if (fileUploadInput) {
        fileUploadInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processImageFile(e.target.files[0]);
            }
        });
    }
    
    // Drop zone drag and drop
    if (dropZone) {
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('border-blue-500', 'bg-blue-100');
        });
        
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('border-blue-500', 'bg-blue-100');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('border-blue-500', 'bg-blue-100');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                processImageFile(file);
                document.getElementById('dropZoneFileName').textContent = `Selected: ${file.name}`;
                document.getElementById('dropZoneFileName').classList.remove('hidden');
                
                // Update the file input
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                dropZoneInput.files = dataTransfer.files;
            }
        });
    }
}

// UI Helper Functions for Save Status
function updateLastSavedIndicator() {
    const statusText = document.getElementById('saveStatusText');
    if (!statusText) return;
    
    if (lastSavedTime) {
        const now = new Date();
        const diffMs = now - lastSavedTime;
        const diffMins = Math.floor(diffMs / 60000);
        
        if (diffMins < 1) {
            statusText.textContent = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ —Ç–æ–ª—å–∫–æ —á—Ç–æ';
            statusText.className = 'text-green-600';
        } else if (diffMins < 5) {
            statusText.textContent = `–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ ${diffMins} –º–∏–Ω –Ω–∞–∑–∞–¥`;
            statusText.className = 'text-green-600';
        } else {
            statusText.textContent = `–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ ${diffMins} –º–∏–Ω –Ω–∞–∑–∞–¥`;
            statusText.className = 'text-gray-600';
        }
    }
}

function updateSavingIndicator(saving) {
    const statusText = document.getElementById('saveStatusText');
    const saveBtn = document.getElementById('manualSaveBtn');
    
    if (saving) {
        statusText.textContent = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...';
        statusText.className = 'text-blue-600';
        if (saveBtn) saveBtn.disabled = true;
    } else {
        if (saveBtn) saveBtn.disabled = false;
        updateLastSavedIndicator();
    }
}

function showSaveError() {
    const statusText = document.getElementById('saveStatusText');
    if (statusText) {
        statusText.textContent = '‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è';
        statusText.className = 'text-red-600';
    }
}

function showLocalStorageFallbackWarning() {
    // Create warning banner if it doesn't exist
    if (!document.getElementById('localStorageWarning')) {
        const banner = document.createElement('div');
        banner.id = 'localStorageWarning';
        banner.className = 'bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-4';
        banner.innerHTML = `
            <div class="flex">
                <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                    </svg>
                </div>
                <div class="ml-3">
                    <p class="text-sm text-yellow-700">
                        ‚ö†Ô∏è –ó–∞–≥—Ä—É–∂–µ–Ω–æ –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∫—ç—à–∞ - –¥–∞–Ω–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã. –ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω–æ.
                    </p>
                </div>
                <div class="ml-auto pl-3">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" class="text-yellow-700 hover:text-yellow-900">
                        <span class="sr-only">Dismiss</span>
                        <svg class="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                        </svg>
                    </button>
                </div>
            </div>
        `;
        document.querySelector('.mx-auto.px-4').insertBefore(banner, document.querySelector('.mb-6'));
    }
}

function showMergeWarning(backendSlides) {
    // Store backend slides for potential merge
    window.backendSlidesForMerge = backendSlides;
    
    // Show merge dialog (simplified version)
    console.log('Merge conflict detected. localStorage is newer than backend.');
    console.log('Using localStorage data. Backend data available in window.backendSlidesForMerge');
}

// Update save indicator periodically
setInterval(() => {
    if (lastSavedTime) {
        updateLastSavedIndicator();
    }
}, 60000); // Every minute

// Trigger auto-save on important actions
</script>
<script>
// ===== Interactive Image Manipulation Module =====
// Handles selection, drag, resize with Interact.js

let selectedImageId = null;
const dimensionTooltip = document.getElementById('dimensionTooltip');

// Debounce utility
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Save slide data after interactions (debounced)
const debouncedSave = debounce(() => {
    saveCurrentSlide();
    updateImagesList();
}, 500);

// Selection management
function selectImage(imageId) {
    console.log('selectImage called for:', imageId);
    // Deselect all first
    deselectAllImages();
    
    // Select the clicked image
    const wrapper = document.querySelector(`.image-wrapper[data-image-id="${imageId}"]`);
    console.log('Found wrapper:', wrapper);
    if (wrapper) {
        wrapper.classList.add('selected');
        selectedImageId = imageId;
        console.log('Image selected, selectedImageId:', selectedImageId);
    } else {
        console.error('Wrapper not found for imageId:', imageId);
    }
}

function deselectAllImages() {
    document.querySelectorAll('.image-wrapper.selected').forEach(wrapper => {
        wrapper.classList.remove('selected');
    });
    selectedImageId = null;
}

// Click handler for slide preview - handles deselection
function handleSlidePreviewClick(e) {
    // If clicked on an image wrapper or click target, let it handle itself
    if (e.target.closest('.image-wrapper') || e.target.closest('.bg-image-click-target')) {
        return;
    }
    
    // If clicked on a table wrapper, let it handle itself
    if (e.target.closest('.table-wrapper')) {
        return;
    }
    
    // Click on text or empty area - deselect images and tables
    deselectAllImages();
    deselectAllTables();
}

// Initialize Interact.js on all image wrappers
let isRotating = false; // Flag to prevent resize during rotation

function initializeImageInteractions() {
    // Check if Interact.js is loaded
    if (typeof interact === 'undefined') {
        console.error('Interact.js not loaded yet');
        return;
    }
    
    const wrappers = document.querySelectorAll('.image-wrapper');
    console.log('Initializing Interact.js on', wrappers.length, 'image wrappers');
    
    wrappers.forEach(wrapper => {
        const imageId = wrapper.dataset.imageId;
        const imageData = getImageData(imageId);
        
        if (!imageData) return;
        
        // Store original dimensions for rotation
        wrapper.dataset.origWidth = imageData.size.width;
        wrapper.dataset.origHeight = imageData.size.height;
        
        // Configure draggable
        interact(wrapper)
            .draggable({
                inertia: false,
                // Ignore drags starting on rotation/resize handles
                ignoreFrom: '.rotate-handle, .resize-handle',
                modifiers: [
                    interact.modifiers.restrictRect({
                        restriction: 'parent',
                        endOnly: true
                    })
                ],
                listeners: {
                    start: (event) => {
                        // Don't start drag if rotating
                        if (isRotating) return;
                        event.target.classList.add('dragging');
                    },
                    move: (event) => {
                        if (isRotating) return;
                        const target = event.target;
                        const imageData = getImageData(imageId);
                        
                        // Update position
                        const x = (parseFloat(target.style.left) || 0) + event.dx;
                        const y = (parseFloat(target.style.top) || 0) + event.dy;
                        
                        target.style.left = `${x}px`;
                        target.style.top = `${y}px`;
                        
                        // CRITICAL: Preserve rotation during drag
                        const rotation = parseFloat(target.dataset.rotation) || 0;
                        if (rotation !== 0) {
                            target.style.transform = `rotate(${rotation}deg)`;
                        }
                        
                        // Update data model
                        if (imageData) {
                            imageData.position.x = Math.round(x);
                            imageData.position.y = Math.round(y);
                        }
                        
                        // Show position tooltip
                        showDimensionTooltip(
                            event.clientX + 10,
                            event.clientY + 10,
                            `X: ${Math.round(x)}px, Y: ${Math.round(y)}px`
                        );
                    },
                    end: (event) => {
                        event.target.classList.remove('dragging');
                        hideDimensionTooltip();
                        if (!isRotating) debouncedSave();
                    }
                }
            })
            .resizable({
                edges: { left: '.resize-handle.left, .resize-handle.bottom-left, .resize-handle.top-left', 
                         right: '.resize-handle.right, .resize-handle.bottom-right, .resize-handle.top-right', 
                         bottom: '.resize-handle.bottom, .resize-handle.bottom-left, .resize-handle.bottom-right', 
                         top: '.resize-handle.top, .resize-handle.top-left, .resize-handle.top-right' },
                modifiers: [
                    interact.modifiers.restrictSize({
                        min: { width: 20, height: 20 }
                    }),
                    // Apply aspect ratio modifier if locked
                    ...(imageData.aspectLocked !== false ? [
                        interact.modifiers.aspectRatio({
                            ratio: imageData.aspectRatio || (imageData.size.width / imageData.size.height),
                            modifiers: [interact.modifiers.restrictSize({ min: { width: 20, height: 20 } })]
                        })
                    ] : [])
                ],
                listeners: {
                    start: (event) => {
                        // Block resize if rotating
                        if (isRotating) {
                            event.preventDefault();
                            return;
                        }
                        event.target.classList.add('resizing');
                        // Initialize position data from current styles
                        const target = event.target;
                        target.dataset.x = parseFloat(target.style.left) || 0;
                        target.dataset.y = parseFloat(target.style.top) || 0;
                    },
                    move: (event) => {
                        // Skip resize if rotating
                        if (isRotating) return;
                        
                        const target = event.target;
                        const imageData = getImageData(imageId);
                        
                        let { x, y } = target.dataset;
                        x = (parseFloat(x) || 0) + event.deltaRect.left;
                        y = (parseFloat(y) || 0) + event.deltaRect.top;
                        
                        // Update element style
                        target.style.width = `${event.rect.width}px`;
                        target.style.height = `${event.rect.height}px`;
                        target.style.left = `${x}px`;
                        target.style.top = `${y}px`;
                        
                        // CRITICAL: Preserve rotation during resize
                        const rotation = parseFloat(target.dataset.rotation) || 0;
                        if (rotation !== 0) {
                            target.style.transform = `rotate(${rotation}deg)`;
                        }
                        
                        // Store position for next move
                        target.dataset.x = x;
                        target.dataset.y = y;
                        
                        // Update data model
                        if (imageData) {
                            imageData.size.width = Math.round(event.rect.width);
                            imageData.size.height = Math.round(event.rect.height);
                            imageData.position.x = Math.round(x);
                            imageData.position.y = Math.round(y);
                        }
                        
                        // Show dimension tooltip
                        showDimensionTooltip(
                            event.clientX + 10,
                            event.clientY + 10,
                            `${Math.round(event.rect.width)} √ó ${Math.round(event.rect.height)}px`
                        );
                    },
                    end: (event) => {
                        event.target.classList.remove('resizing');
                        if (isRotating) return;
                        
                        const imageData = getImageData(imageId);
                        
                        // Recalculate aspect ratio after resize
                        if (imageData) {
                            imageData.aspectRatio = imageData.size.width / imageData.size.height;
                        }
                        
                        hideDimensionTooltip();
                        debouncedSave();
                    }
                }
            });
        
        // Add rotation functionality to rotation handle
        const rotateHandle = wrapper.querySelector('.rotate-handle');
        if (rotateHandle) {
            let startAngle = 0;
            let currentRotation = parseFloat(wrapper.dataset.rotation) || 0;
            let initialSize = null; // Store initial size to prevent resize during rotation
            
            rotateHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.stopImmediatePropagation();
                e.preventDefault();
                
                // Set rotation flag to prevent resize
                isRotating = true;
                
                // Store initial size to restore if needed
                initialSize = {
                    width: parseFloat(wrapper.style.width) || imageData.size.width,
                    height: parseFloat(wrapper.style.height) || imageData.size.height
                };
                
                const rect = wrapper.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                startAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                currentRotation = parseFloat(wrapper.dataset.rotation) || 0;
                
                const onMouseMove = (e) => {
                    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                    const rotation = currentRotation + (angle - startAngle);
                    
                    // ONLY update rotation, preserve size
                    wrapper.style.transform = `rotate(${rotation}deg)`;
                    wrapper.dataset.rotation = rotation;
                    
                    // Ensure size is preserved (prevent any resize interference)
                    if (initialSize) {
                        wrapper.style.width = `${initialSize.width}px`;
                        wrapper.style.height = `${initialSize.height}px`;
                    }
                    
                    // Show rotation tooltip
                    showDimensionTooltip(
                        e.clientX + 10,
                        e.clientY + 10,
                        `${Math.round(rotation)}¬∞`
                    );
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    // Save rotation to data model
                    const imageData = getImageData(imageId);
                    if (imageData) {
                        imageData.rotation = parseFloat(wrapper.dataset.rotation) || 0;
                    }
                    
                    hideDimensionTooltip();
                    
                    // Clear rotation flag after a small delay to prevent resize from triggering
                    setTimeout(() => {
                        isRotating = false;
                    }, 50);
                    
                    debouncedSave();
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }
    });
}

// Helper to get image data from slides array
function getImageData(imageId) {
    const images = slides[currentSlideIndex]?.images || [];
    return images.find(img => img.id === imageId);
}

// Dimension tooltip functions
function showDimensionTooltip(x, y, text) {
    if (dimensionTooltip) {
        dimensionTooltip.textContent = text;
        dimensionTooltip.style.left = `${x}px`;
        dimensionTooltip.style.top = `${y}px`;
        dimensionTooltip.classList.add('active');
    }
}

function hideDimensionTooltip() {
    if (dimensionTooltip) {
        dimensionTooltip.classList.remove('active');
    }
}

// Keyboard shortcuts (optional)
document.addEventListener('keydown', (e) => {
    // Handle image shortcuts
    if (selectedImageId) {
        // Delete key - remove selected image
        if (e.key === 'Delete') {
            e.preventDefault();
            removeImage(selectedImageId);
            return;
        }
        
        // Escape key - deselect
        if (e.key === 'Escape') {
            e.preventDefault();
            deselectAllImages();
            return;
        }
        
        // Arrow keys - nudge position
        const imageData = getImageData(selectedImageId);
        if (imageData && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
            const step = e.shiftKey ? 10 : 1;
            
            switch(e.key) {
                case 'ArrowUp':
                    imageData.position.y = Math.max(0, imageData.position.y - step);
                    break;
                case 'ArrowDown':
                    imageData.position.y += step;
                    break;
                case 'ArrowLeft':
                    imageData.position.x = Math.max(0, imageData.position.x - step);
                    break;
                case 'ArrowRight':
                    imageData.position.x += step;
                    break;
            }
            
            // Update visual
            const wrapper = document.querySelector(`.image-wrapper[data-image-id="${selectedImageId}"]`);
            if (wrapper) {
                wrapper.style.left = `${imageData.position.x}px`;
                wrapper.style.top = `${imageData.position.y}px`;
            }
            
            debouncedSave();
        }
        return;
    }
    
    // Handle table shortcuts
    if (selectedTableId) {
        // Delete key - remove selected table
        if (e.key === 'Delete') {
            e.preventDefault();
            removeTable(selectedTableId);
            return;
        }
        
        // Escape key - deselect
        if (e.key === 'Escape') {
            e.preventDefault();
            deselectAllTables();
            return;
        }
        
        // Arrow keys - nudge position
        const tableData = getTableData(selectedTableId);
        if (tableData && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
            const step = e.shiftKey ? 10 : 1;
            
            switch(e.key) {
                case 'ArrowUp':
                    tableData.position.y = Math.max(0, tableData.position.y - step);
                    break;
                case 'ArrowDown':
                    tableData.position.y += step;
                    break;
                case 'ArrowLeft':
                    tableData.position.x = Math.max(0, tableData.position.x - step);
                    break;
                case 'ArrowRight':
                    tableData.position.x += step;
                    break;
            }
            
            // Update visual
            const wrapper = document.querySelector(`.table-wrapper[data-table-id="${selectedTableId}"]`);
            if (wrapper) {
                wrapper.style.left = `${tableData.position.x}px`;
                wrapper.style.top = `${tableData.position.y}px`;
            }
            
            debouncedSave();
        }
    }
});
</script>

<!-- Interact.js Library - Load at end after DOM elements exist -->
<script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.19/dist/interact.min.js"></script>

<script>
// Wait for Interact.js to load, then initialize interactions
(function waitForInteract() {
    if (typeof interact !== 'undefined') {
        console.log('Interact.js loaded successfully');
        // Re-initialize interactions after library loads with multiple attempts
        setTimeout(() => {
            console.log('Calling initializeImageInteractions...');
            initializeImageInteractions();
            initializeTableInteractions();
        }, 100);
        
        // Try again after 500ms to catch any late-rendered elements
        setTimeout(() => {
            console.log('Re-initializing after 500ms...');
            initializeImageInteractions();
            initializeTableInteractions();
        }, 500);
        
        // And again after 1 second
        setTimeout(() => {
            console.log('Re-initializing after 1s...');
            initializeImageInteractions();
            initializeTableInteractions();
        }, 1000);
    } else {
        console.log('Waiting for Interact.js...');
        setTimeout(waitForInteract, 50);
    }
})();
</script>

{% endblock %}
